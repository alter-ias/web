<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kira: Free Range (Safe Back)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; z-index: 100;
            pointer-events: none; color: #aaa; text-shadow: 0 0 4px #000;
            letter-spacing: 1px; font-size: 14px;
        }
        .key { color: #00ffff; font-weight: bold; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="info">
        RANGO LIBRE (PROTECCIÓN TRASERA)<br/>
        <span class="key">FLECHAS</span>: Mover &bull; <span class="key">W/S</span>: Profundidad &bull; <span class="key">H</span>: Ver Gizmo
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver } from 'three/addons/animation/CCDIKSolver.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN ---
        const CONFIG = {
            bloomStrength: 0, 
            bloomRadius: 0.3,
            orbColor: 0x00ffff,
            rimColor: 0xff00ff,
            camPos: new THREE.Vector3(0.92, 1.41, -1.64),
            camTarget: new THREE.Vector3(2.14, 1.11, -0.24),
            
            // FÍSICA
            moveSpeed: 0.04,     
            smoothFactor: 0.08,   
            
            // --- LÍMITES INTELIGENTES ---
            limits: {
                // X: Permitimos ir muy a la derecha (2.5), pero limitamos cruzar el pecho (-0.2)
                xMin: -0.2, xMax: 2.5,  
                
                // Y: Permitimos ir muy alto (2.5), pero no atravesar el asiento (0.5)
                yMin: 0.5,  yMax: 2.5,  
                
                // Z (Profundidad): ¡AQUÍ ESTÁ EL TRUCO!
                // zMax (2.5): Libertad total hacia adelante.
                // zMin (-0.15): La pared invisible justo en la espalda para evitar el glitch.
                zMin: -0.15, zMax: 2.5   
            }
        };

        let scene, camera, renderer, composer;
        let orbitControls, transformControls;
        let particlesMesh;
        const OOI = {};
        let IKSolver;
        const clock = new THREE.Clock();
        const v0 = new THREE.Vector3();

        const targetPos = new THREE.Vector3(); 
        let isGizmovisible = false; 

        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            w: false, s: false, W: false, S: false
        };

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.02);
            scene.background = new THREE.Color(0x050510);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.001, 5000);
            camera.position.copy(CONFIG.camPos);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = CONFIG.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            try {
                const gltf = await gltfLoader.loadAsync('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/kira.glb');
                
                gltf.scene.traverse(n => {
                    if (n.name === 'head') OOI.head = n;
                    if (n.name === 'hand_l') OOI.hand_l = n;
                    if (n.name === 'target_hand_l') OOI.target_hand_l = n;
                    if (n.name === 'boule') OOI.sphere = n;
                    if (n.name === 'Kira_Shirt_left') OOI.kira = n;
                    if (n.isMesh) { n.castShadow = true; n.receiveShadow = true; }
                });
                scene.add(gltf.scene);

                OOI.hand_l.attach(OOI.sphere);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: CONFIG.orbColor, wireframe: true, transparent: true, opacity: 0.8 });
                OOI.sphere.material = orbMaterial;
                
                const orbLight = new THREE.PointLight(CONFIG.orbColor, 0.8, 4);
                OOI.sphere.add(orbLight);

                targetPos.copy(OOI.sphere.position);

                OOI.kira.add(OOI.kira.skeleton.bones[0]);
                const iks = [{
                    target: 22, effector: 6,
                    links: [
                        { index: 5, rotationMin: new THREE.Vector3(1.2, -1.8, -.4), rotationMax: new THREE.Vector3(1.7, -1.1, .3) },
                        { index: 4, rotationMin: new THREE.Vector3(0.1, -0.7, -1.8), rotationMax: new THREE.Vector3(1.1, 0, -1.4) },
                    ],
                }];
                IKSolver = new CCDIKSolver(OOI.kira, iks);

                orbitControls = new OrbitControls(camera, renderer.domElement);
                orbitControls.enableDamping = true;
                orbitControls.dampingFactor = 0.05;
                orbitControls.target.copy(CONFIG.camTarget);
                
                transformControls = new TransformControls(camera, renderer.domElement);
                transformControls.size = 0.5;
                transformControls.space = 'world';
                transformControls.attach(OOI.target_hand_l);
                transformControls.visible = isGizmovisible;
                scene.add(transformControls);

                const ambient = new THREE.AmbientLight(0x404040, 1.5); 
                scene.add(ambient);
                const rimLight = new THREE.SpotLight(CONFIG.rimColor, 8);
                rimLight.position.set(-2, 3, -2);
                rimLight.lookAt(0,0,0);
                scene.add(rimLight);

                createParticles();
                setupInputs();
                
                window.addEventListener('resize', onWindowResize, false);
                renderer.setAnimationLoop(animate);

            } catch (e) { console.error(e); }
        }

        function setupInputs() {
            window.addEventListener('keydown', (e) => {
                if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key] = true;
                if(e.key.toLowerCase() === 'h') {
                    isGizmovisible = !isGizmovisible;
                    transformControls.visible = isGizmovisible;
                }
            });
            window.addEventListener('keyup', (e) => {
                if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key] = false;
            });
        }

        function updateMovementTarget() {
            const speed = CONFIG.moveSpeed;
            
            if (keys.ArrowRight) targetPos.x += speed;
            if (keys.ArrowLeft) targetPos.x -= speed;
            if (keys.ArrowUp) targetPos.y += speed;
            if (keys.ArrowDown) targetPos.y -= speed;
            if (keys.w || keys.W) targetPos.z -= speed;
            if (keys.s || keys.S) targetPos.z += speed;

            // LÍMITES ASIMÉTRICOS (Libertad + Seguridad)
            targetPos.x = THREE.MathUtils.clamp(targetPos.x, CONFIG.limits.xMin, CONFIG.limits.xMax);
            targetPos.y = THREE.MathUtils.clamp(targetPos.y, CONFIG.limits.yMin, CONFIG.limits.yMax);
            targetPos.z = THREE.MathUtils.clamp(targetPos.z, CONFIG.limits.zMin, CONFIG.limits.zMax);
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 300; i++) vertices.push((Math.random()-0.5)*5, (Math.random()-0.5)*5+2, (Math.random()-0.5)*5);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            particlesMesh = new THREE.Points(geometry, new THREE.PointsMaterial({ color: CONFIG.rimColor, size: 0.02, transparent: true, opacity: 0.4 }));
            scene.add(particlesMesh);
        }

        function animate() {
            const time = clock.getElapsedTime();

            if (OOI.target_hand_l) {
                updateMovementTarget();
                OOI.target_hand_l.position.lerp(targetPos, CONFIG.smoothFactor);
            }

            if (OOI.head && OOI.sphere) {
                OOI.sphere.getWorldPosition(v0);
                OOI.head.lookAt(v0);
                OOI.head.rotation.set(OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z);
            }
            if (IKSolver) IKSolver.update();

            if (particlesMesh) {
                particlesMesh.rotation.y = time * 0.02;
                particlesMesh.position.y = Math.sin(time * 0.3) * 0.1;
            }

            orbitControls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
