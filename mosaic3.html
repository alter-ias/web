<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kira: Dream Sequence (Final)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #888;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            color: #444;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="info">Interactive Dream Sequence</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver } from 'three/addons/animation/CCDIKSolver.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- TUS VARIABLES MAESTRAS (Extraídas de tu JSON) ---
        const CONFIG = {
            bloomStrength: 0,
            bloomRadius: 0.306,
            orbIntensity: 0.6,
            orbColor: 0x00ffff,
            rimIntensity: 6.12,
            rimColor: 0xff00ff,
            camPos: new THREE.Vector3(0.9245545038381124, 1.4142747970928973, -1.6477404380731393),
            camTarget: new THREE.Vector3(2.143176548309741, 1.110952765868537, -0.2431985467631249)
        };

        let scene, camera, renderer, composer;
        let orbitControls, transformControls;
        let particlesMesh;
        const OOI = {};
        let IKSolver;
        const clock = new THREE.Clock();
        const v0 = new THREE.Vector3();

        init();

        async function init() {
            // 1. ESCENA
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.03);
            scene.background = new THREE.Color(0x050510);

            // 2. CÁMARA (Posición exacta fijada)
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.001, 5000);
            camera.position.copy(CONFIG.camPos);

            // 3. LUCES (Valores exactos fijados)
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            // Luz de Orbe (Cian)
            const orbLight = new THREE.PointLight(CONFIG.orbColor, CONFIG.orbIntensity, 5);
            // Nota: Se añade a la escena o al objeto más adelante, aquí la creamos.

            // Luz de Contra (Magenta)
            const rimLight = new THREE.SpotLight(CONFIG.rimColor, CONFIG.rimIntensity);
            rimLight.position.set(-2, 2, -2);
            rimLight.lookAt(0, 1, 0);
            scene.add(rimLight);

            // 4. RENDERER & POST-PROCESADO
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            
            // Bloom Configurado
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = CONFIG.bloomStrength; // 0 según tu config
            bloomPass.radius = CONFIG.bloomRadius;     // 0.306 según tu config

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 5. CARGA DEL MODELO
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            try {
                const gltf = await gltfLoader.loadAsync('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/kira.glb');

                gltf.scene.traverse(n => {
                    if (n.name === 'head') OOI.head = n;
                    if (n.name === 'lowerarm_l') OOI.lowerarm_l = n;
                    if (n.name === 'Upperarm_l') OOI.Upperarm_l = n;
                    if (n.name === 'hand_l') OOI.hand_l = n;
                    if (n.name === 'target_hand_l') OOI.target_hand_l = n;
                    if (n.name === 'boule') OOI.sphere = n;
                    if (n.name === 'Kira_Shirt_left') OOI.kira = n;

                    if (n.isMesh) {
                        n.castShadow = true;
                        n.receiveShadow = true;
                        if (n.material) n.material.roughness = 0.4;
                    }
                });
                scene.add(gltf.scene);

                // Configurar Orbe
                OOI.hand_l.attach(OOI.sphere);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: CONFIG.orbColor, wireframe: true });
                OOI.sphere.material = orbMaterial;
                OOI.sphere.add(orbLight); // Añadimos la luz al orbe

                // Core blanco del orbe
                const coreGeo = new THREE.IcosahedronGeometry(0.05, 0);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const core = new THREE.Mesh(coreGeo, coreMat);
                OOI.sphere.add(core);

                // Configurar IK
                OOI.kira.add(OOI.kira.skeleton.bones[0]);
                const iks = [{
                    target: 22,
                    effector: 6,
                    links: [
                        { index: 5, rotationMin: new THREE.Vector3(1.2, -1.8, -.4), rotationMax: new THREE.Vector3(1.7, -1.1, .3) },
                        { index: 4, rotationMin: new THREE.Vector3(0.1, -0.7, -1.8), rotationMax: new THREE.Vector3(1.1, 0, -1.4) },
                    ],
                }];
                IKSolver = new CCDIKSolver(OOI.kira, iks);

                // SETUP CONTROLES
                orbitControls = new OrbitControls(camera, renderer.domElement);
                orbitControls.minDistance = 0.1;
                orbitControls.maxDistance = 10;
                orbitControls.enableDamping = true;
                
                // *** APLICAR TARGET DE CÁMARA (HEAD) ***
                orbitControls.target.copy(CONFIG.camTarget);
                orbitControls.update();

                // Flechas de control (TransformControls) - Mantenemos esto para interactividad
                transformControls = new TransformControls(camera, renderer.domElement);
                transformControls.size = 0.4;
                transformControls.showX = true; // Solo mostrar ejes necesarios para limpiar visualmente
                transformControls.showY = true;
                transformControls.showZ = true;
                transformControls.space = 'world';
                transformControls.attach(OOI.target_hand_l);
                scene.add(transformControls);

                // Eventos de control
                transformControls.addEventListener('mouseDown', () => orbitControls.enabled = false);
                transformControls.addEventListener('mouseUp', () => orbitControls.enabled = true);

                createFloatingParticles();
                
                window.addEventListener('resize', onWindowResize, false);
                renderer.setAnimationLoop(animate);

            } catch (error) {
                console.error("Error cargando modelo:", error);
            }
        }

        function createFloatingParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 400; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4 + 1,
                    (Math.random() - 0.5) * 4
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: CONFIG.rimColor, size: 0.015, transparent: true, opacity: 0.5 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        function animate() {
            const time = clock.getElapsedTime();

            // Animación sutil de partículas
            if (particlesMesh) {
                particlesMesh.rotation.y = time * 0.03;
                particlesMesh.position.y = Math.sin(time * 0.2) * 0.05;
            }

            // Latido del Orbe
            if (OOI.sphere) {
                const s = 1 + Math.sin(time * 2.5) * 0.1;
                OOI.sphere.scale.set(s, s, s);
            }

            // Lógica: Cabeza sigue al orbe
            if (OOI.head && OOI.sphere) {
                OOI.sphere.getWorldPosition(v0);
                OOI.head.lookAt(v0);
                OOI.head.rotation.set(OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z);
            }

            if (IKSolver) IKSolver.update();

            // Actualizar helper de huesos
            scene.traverse(o => { if (o.isSkinnedMesh) o.computeBoundingSphere(); });

            orbitControls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
