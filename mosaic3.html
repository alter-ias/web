<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kira: Dream Sequence (IK Integration)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #888;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #00ffff;
        }
        a { color: #00ffff; text-decoration: none; pointer-events: auto; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="info">
        KIRA: DREAM SEQUENCE | <a href="#" id="toggleIK">Toggle IK</a><br/>
        Mueve el orbe de energía
    </div>

    <script type="module">
        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver, CCDIKHelper } from 'three/addons/animation/CCDIKSolver.js';
        
        // Post-procesado (Efectos visuales)
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer;
        let orbitControls, transformControls;
        let mirrorSphereCamera;

        const OOI = {};
        let IKSolver;
        let particlesMesh; // Para las partículas flotantes

        // Configuración simplificada
        const conf = {
            followSphere: false,
            turnHead: true,
            ik_solver: true,
            update: updateIK
        };
        
        const v0 = new THREE.Vector3();
        const clock = new THREE.Clock();

        init();

        async function init() {

            // 1. ESCENA TIPO SUEÑO
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2( 0x050510, 0.03 ); // Niebla azulada oscura
            scene.background = new THREE.Color( 0x050510 );

            camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.001, 5000 );
            camera.position.set( 0.9, 1.1, 1.5 ); // Un poco más lejos para ver el ambiente
            camera.lookAt( scene.position );

            // 2. ILUMINACIÓN DRAMÁTICA
            const ambientLight = new THREE.AmbientLight( 0x222222 ); // Muy tenue
            scene.add( ambientLight );

            // Luz principal (azul neón) que vendrá del Orbe
            const orbLight = new THREE.PointLight( 0x00ffff, 2, 5 );
            scene.add( orbLight ); // La vincularemos al orbe luego

            // Luz de contra (Rim light) magenta para siluetear a Kira
            const rimLight = new THREE.SpotLight( 0xff00ff, 5 );
            rimLight.position.set( -2, 2, -2 );
            rimLight.lookAt(0,1,0);
            scene.add( rimLight );

            // 3. RENDERIZADOR
            renderer = new THREE.WebGLRenderer( { antialias: false, powerPreference: "high-performance" } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild( renderer.domElement );

            // 4. POST-PROCESADO (BLOOM)
            const renderScene = new RenderPass( scene, camera );
            const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2; // Intensidad del brillo
            bloomPass.radius = 0.5;

            composer = new EffectComposer( renderer );
            composer.addPass( renderScene );
            composer.addPass( bloomPass );

            // 5. CARGA DEL MODELO (Desde CDN para evitar errores 404)
            const dracoLoader = new DRACOLoader();
            // IMPORTANTE: Ruta al decoder en internet
            dracoLoader.setDecoderPath( 'https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/' ); 
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader( dracoLoader );

            // Usamos la ruta oficial de three.js examples
            const gltf = await gltfLoader.loadAsync( 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/kira.glb' );
            
            gltf.scene.traverse( n => {
                if ( n.name === 'head' ) OOI.head = n;
                if ( n.name === 'lowerarm_l' ) OOI.lowerarm_l = n;
                if ( n.name === 'Upperarm_l' ) OOI.Upperarm_l = n;
                if ( n.name === 'hand_l' ) OOI.hand_l = n;
                if ( n.name === 'target_hand_l' ) OOI.target_hand_l = n;
                if ( n.name === 'boule' ) OOI.sphere = n;
                if ( n.name === 'Kira_Shirt_left' ) OOI.kira = n;

                // Hacer que el modelo reciba sombras y luz
                if (n.isMesh) {
                    n.castShadow = true;
                    n.receiveShadow = true;
                    // Opcional: Hacer la ropa un poco brillante
                     if(n.material) n.material.roughness = 0.4;
                }
            } );
            scene.add( gltf.scene );

            // 6. CONFIGURACIÓN DEL ORBE (EL NÚCLEO)
            OOI.hand_l.attach( OOI.sphere );
            
            // Creamos un material emisivo para el orbe (para que brille con el Bloom)
            const orbMaterial = new THREE.MeshBasicMaterial( { 
                color: 0x00ffff, 
                wireframe: true 
            } );
            OOI.sphere.material = orbMaterial;
            
            // Ponemos una luz dentro del orbe
            OOI.sphere.add(orbLight); 

            // Esfera interna sólida
            const coreGeo = new THREE.IcosahedronGeometry( 0.05, 0 );
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const core = new THREE.Mesh(coreGeo, coreMat);
            OOI.sphere.add(core);


            // 7. SETUP DE CINEMÁTICA INVERSA (IK)
            OOI.kira.add( OOI.kira.skeleton.bones[ 0 ] );
            const iks = [
                {
                    target: 22, // "target_hand_l"
                    effector: 6, // "hand_l"
                    links: [
                        {
                            index: 5, // "lowerarm_l"
                            rotationMin: new THREE.Vector3( 1.2, - 1.8, - .4 ),
                            rotationMax: new THREE.Vector3( 1.7, - 1.1, .3 )
                        },
                        {
                            index: 4, // "Upperarm_l"
                            rotationMin: new THREE.Vector3( 0.1, - 0.7, - 1.8 ),
                            rotationMax: new THREE.Vector3( 1.1, 0, - 1.4 )
                        },
                    ],
                }
            ];
            IKSolver = new CCDIKSolver( OOI.kira, iks );

            // 8. CONTROLES
            orbitControls = new OrbitControls( camera, renderer.domElement );
            orbitControls.minDistance = 0.2;
            orbitControls.maxDistance = 1.5;
            orbitControls.enableDamping = true;
            
            // Transform control para mover el orbe
            transformControls = new TransformControls( camera, renderer.domElement );
            transformControls.size = 0.5;
            transformControls.showX = true; // Mostrar ejes para mover
            transformControls.space = 'world';
            transformControls.attach( OOI.target_hand_l );
            scene.add( transformControls.getHelper() );

            transformControls.addEventListener( 'mouseDown', () => orbitControls.enabled = false );
            transformControls.addEventListener( 'mouseUp', () => orbitControls.enabled = true );

            // 9. AÑADIR PARTÍCULAS (Ambiente)
            createFloatingParticles();

            window.addEventListener( 'resize', onWindowResize, false );
            
            // Loop de animación
            renderer.setAnimationLoop( animate );
        }

        function createFloatingParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 500; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4 + 1,
                    (Math.random() - 0.5) * 4
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xff00ff, size: 0.02, transparent: true, opacity: 0.6 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        function animate() {
            const time = clock.getElapsedTime();

            // Animación suave de partículas
            if(particlesMesh) {
                particlesMesh.rotation.y = time * 0.05;
                particlesMesh.position.y = Math.sin(time * 0.5) * 0.1;
            }

            // Animación del Orbe (Latido)
            if(OOI.sphere) {
                const s = 1 + Math.sin(time * 3) * 0.2;
                OOI.sphere.scale.set(s, s, s);
            }

            if ( OOI.head && OOI.sphere && conf.turnHead ) {
                OOI.sphere.getWorldPosition( v0 );
                OOI.head.lookAt( v0 );
                OOI.head.rotation.set( OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z );
            }

            if ( conf.ik_solver ) {
                updateIK();
            }

            orbitControls.update();
            
            // IMPORTANTE: Usar composer en lugar de renderer normal para ver el Bloom
            composer.render();
        }

        function updateIK() {
            if ( IKSolver ) IKSolver.update();
            scene.traverse( function ( object ) {
                if ( object.isSkinnedMesh ) object.computeBoundingSphere();
            } );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            composer.setSize( window.innerWidth, window.innerHeight );
        }
        </script>
</body>
</html>
