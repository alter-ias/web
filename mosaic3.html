<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kira: Calibration Tool</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; z-index: 100;
            pointer-events: none; color: #fff; text-shadow: 0 0 4px #000;
            letter-spacing: 1px; font-size: 14px;
        }
        .key { color: #ffff00; font-weight: bold; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="info">
        MODO CALIBRACI√ìN<br/>
        Usa el panel derecho para ajustar la <span class="key">CAJA AMARILLA</span>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver } from 'three/addons/animation/CCDIKSolver.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- CONFIGURACI√ìN INICIAL ---
        const CONFIG = {
            camPos: new THREE.Vector3(0.92, 1.41, -1.64),
            camTarget: new THREE.Vector3(2.14, 1.11, -0.24),
            moveSpeed: 0.04,     
            smoothFactor: 0.1,   
        };

        // VALORES INICIALES (MUY ABIERTOS PARA QUE T√ö LOS CIERRES)
        const LIMITS = {
            xMin: -1.0, xMax: 2.5,
            yMin: 0.0,  yMax: 2.5,
            zMin: -1.0, zMax: 2.5, // zMin es la pared de la espalda
            showBox: true
        };

        let scene, camera, renderer;
        let orbitControls, transformControls;
        let limitBoxMesh; // La caja visual
        const OOI = {};
        let IKSolver;
        const clock = new THREE.Clock();
        const v0 = new THREE.Vector3();
        const targetPos = new THREE.Vector3(); 
        let isGizmovisible = true; 

        // Teclado
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, w: false, s: false, W: false, S: false };

        init();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // Fondo gris para ver mejor

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.001, 5000);
            camera.position.copy(CONFIG.camPos);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Luces simples para trabajar
            const ambient = new THREE.AmbientLight(0xffffff, 2.5); 
            scene.add(ambient);

            // VISUALIZADOR DE L√çMITES (CAJA AMARILLA)
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true });
            limitBoxMesh = new THREE.Mesh(boxGeo, boxMat);
            scene.add(limitBoxMesh);

            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            try {
                const gltf = await gltfLoader.loadAsync('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/kira.glb');
                
                gltf.scene.traverse(n => {
                    if (n.name === 'head') OOI.head = n;
                    if (n.name === 'hand_l') OOI.hand_l = n;
                    if (n.name === 'target_hand_l') OOI.target_hand_l = n;
                    if (n.name === 'boule') OOI.sphere = n;
                    if (n.name === 'Kira_Shirt_left') OOI.kira = n;
                });
                scene.add(gltf.scene);

                OOI.hand_l.attach(OOI.sphere);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
                OOI.sphere.material = orbMaterial;
                targetPos.copy(OOI.sphere.position);

                OOI.kira.add(OOI.kira.skeleton.bones[0]);
                const iks = [{
                    target: 22, effector: 6,
                    links: [
                        { index: 5, rotationMin: new THREE.Vector3(1.2, -1.8, -.4), rotationMax: new THREE.Vector3(1.7, -1.1, .3) },
                        { index: 4, rotationMin: new THREE.Vector3(0.1, -0.7, -1.8), rotationMax: new THREE.Vector3(1.1, 0, -1.4) },
                    ],
                }];
                IKSolver = new CCDIKSolver(OOI.kira, iks);

                orbitControls = new OrbitControls(camera, renderer.domElement);
                orbitControls.target.copy(CONFIG.camTarget);
                
                transformControls = new TransformControls(camera, renderer.domElement);
                transformControls.size = 0.5;
                transformControls.space = 'world';
                transformControls.attach(OOI.target_hand_l);
                scene.add(transformControls);

                transformControls.addEventListener('mouseDown', () => orbitControls.enabled = false);
                transformControls.addEventListener('mouseUp', () => orbitControls.enabled = true);

                setupInputs();
                setupGUI(); // <--- AQU√ç EST√Å LA MAGIA
                updateBoxVisuals(); // Inicializar caja

                window.addEventListener('resize', onWindowResize, false);
                renderer.setAnimationLoop(animate);

            } catch (e) { console.error(e); }
        }

        function setupGUI() {
            const gui = new GUI();
            const folder = gui.addFolder('L√çMITES DE MOVIMIENTO');
            
            // Sliders para ajustar la caja en tiempo real
            folder.add(LIMITS, 'xMin', -2, 2).onChange(updateBoxVisuals).name('X Min (Izq)');
            folder.add(LIMITS, 'xMax', -2, 4).onChange(updateBoxVisuals).name('X Max (Der)');
            folder.add(LIMITS, 'yMin', 0, 3).onChange(updateBoxVisuals).name('Y Min (Suelo)');
            folder.add(LIMITS, 'yMax', 0, 3).onChange(updateBoxVisuals).name('Y Max (Techo)');
            folder.add(LIMITS, 'zMin', -2, 2).onChange(updateBoxVisuals).name('Z Min (ESPALDA)');
            folder.add(LIMITS, 'zMax', -2, 4).onChange(updateBoxVisuals).name('Z Max (Frente)');
            
            folder.add(LIMITS, 'showBox').name('Ver Caja').onChange(v => limitBoxMesh.visible = v);
            
            const printBtn = { print: () => {
                console.log("--- COPIA ESTOS VALORES ---");
                console.log(JSON.stringify(LIMITS, null, 2));
                alert("Valores impresos en Consola (F12)");
            }};
            gui.add(printBtn, 'print').name('üíæ IMPRIMIR EN CONSOLA');
            
            folder.open();
        }

        function updateBoxVisuals() {
            // Calcula el centro y el tama√±o de la caja bas√°ndose en los Min/Max
            const width = LIMITS.xMax - LIMITS.xMin;
            const height = LIMITS.yMax - LIMITS.yMin;
            const depth = LIMITS.zMax - LIMITS.zMin;

            const x = (LIMITS.xMax + LIMITS.xMin) / 2;
            const y = (LIMITS.yMax + LIMITS.yMin) / 2;
            const z = (LIMITS.zMax + LIMITS.zMin) / 2;

            limitBoxMesh.position.set(x, y, z);
            limitBoxMesh.scale.set(width, height, depth);
        }

        function setupInputs() {
            window.addEventListener('keydown', (e) => {
                if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key] = true;
                if(e.key.toLowerCase() === 'h') transformControls.visible = !transformControls.visible;
            });
            window.addEventListener('keyup', (e) => {
                if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key] = false;
            });
        }

        function updateMovementTarget() {
            const speed = CONFIG.moveSpeed;
            
            // Movimiento libre
            if (keys.ArrowRight) targetPos.x += speed;
            if (keys.ArrowLeft) targetPos.x -= speed;
            if (keys.ArrowUp) targetPos.y += speed;
            if (keys.ArrowDown) targetPos.y -= speed;
            if (keys.w || keys.W) targetPos.z -= speed;
            if (keys.s || keys.S) targetPos.z += speed;

            // APLICAR LOS L√çMITES DEL GUI
            targetPos.x = THREE.MathUtils.clamp(targetPos.x, LIMITS.xMin, LIMITS.xMax);
            targetPos.y = THREE.MathUtils.clamp(targetPos.y, LIMITS.yMin, LIMITS.yMax);
            targetPos.z = THREE.MathUtils.clamp(targetPos.z, LIMITS.zMin, LIMITS.zMax);
        }

        function animate() {
            if (OOI.target_hand_l) {
                updateMovementTarget();
                OOI.target_hand_l.position.lerp(targetPos, CONFIG.smoothFactor);
            }

            if (OOI.head && OOI.sphere) {
                OOI.sphere.getWorldPosition(v0);
                OOI.head.lookAt(v0);
                OOI.head.rotation.set(OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z);
            }
            if (IKSolver) IKSolver.update();

            orbitControls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
