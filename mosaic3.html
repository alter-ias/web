<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kira: Dream Sequence (Fixed)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #888;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 5px #00ffff;
        }
        a { color: #00ffff; text-decoration: none; pointer-events: auto; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="info">
        KIRA: DREAM SEQUENCE | <a href="#" id="toggleIK">Toggle IK</a><br/>
        Mueve el orbe de energía con las flechas
    </div>

    <script type="module">
        import * as THREE from 'three';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver, CCDIKHelper } from 'three/addons/animation/CCDIKSolver.js';
        
        // Post-procesado
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer;
        let orbitControls, transformControls;
        
        // Objeto "Of Interest" (OOI)
        const OOI = {};
        let IKSolver;
        let particlesMesh; 

        const conf = {
            followSphere: false,
            turnHead: true,
            ik_solver: true,
            update: updateIK
        };
        
        const v0 = new THREE.Vector3();
        const clock = new THREE.Clock();

        init();

        async function init() {

            // 1. ESCENA
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2( 0x050510, 0.03 ); 
            scene.background = new THREE.Color( 0x050510 );

            camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.001, 5000 );
            camera.position.set( 0.9, 1.1, 1.5 ); 
            camera.lookAt( scene.position );

            // 2. LUCES
            const ambientLight = new THREE.AmbientLight( 0x222222 ); 
            scene.add( ambientLight );

            const orbLight = new THREE.PointLight( 0x00ffff, 2, 5 );
            scene.add( orbLight ); 

            const rimLight = new THREE.SpotLight( 0xff00ff, 5 );
            rimLight.position.set( -2, 2, -2 );
            rimLight.lookAt(0,1,0);
            scene.add( rimLight );

            // 3. RENDERIZADOR
            renderer = new THREE.WebGLRenderer( { antialias: false, powerPreference: "high-performance" } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild( renderer.domElement );

            // 4. POST-PROCESADO (BLOOM)
            const renderScene = new RenderPass( scene, camera );
            const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer( renderer );
            composer.addPass( renderScene );
            composer.addPass( bloomPass );

            // 5. CARGAR MODELO
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath( 'https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/' ); 
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader( dracoLoader );

            try {
                const gltf = await gltfLoader.loadAsync( 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/kira.glb' );
                
                gltf.scene.traverse( n => {
                    if ( n.name === 'head' ) OOI.head = n;
                    if ( n.name === 'lowerarm_l' ) OOI.lowerarm_l = n;
                    if ( n.name === 'Upperarm_l' ) OOI.Upperarm_l = n;
                    if ( n.name === 'hand_l' ) OOI.hand_l = n;
                    if ( n.name === 'target_hand_l' ) OOI.target_hand_l = n;
                    if ( n.name === 'boule' ) OOI.sphere = n;
                    if ( n.name === 'Kira_Shirt_left' ) OOI.kira = n;

                    if (n.isMesh) {
                        n.castShadow = true;
                        n.receiveShadow = true;
                        if(n.material) n.material.roughness = 0.4;
                    }
                } );
                scene.add( gltf.scene );

                // 6. ORBE
                OOI.hand_l.attach( OOI.sphere );
                const orbMaterial = new THREE.MeshBasicMaterial( { color: 0x00ffff, wireframe: true } );
                OOI.sphere.material = orbMaterial;
                OOI.sphere.add(orbLight); 

                const coreGeo = new THREE.IcosahedronGeometry( 0.05, 0 );
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const core = new THREE.Mesh(coreGeo, coreMat);
                OOI.sphere.add(core);

                // 7. IK SETUP
                OOI.kira.add( OOI.kira.skeleton.bones[ 0 ] );
                const iks = [
                    {
                        target: 22, 
                        effector: 6, 
                        links: [
                            { index: 5, rotationMin: new THREE.Vector3( 1.2, - 1.8, - .4 ), rotationMax: new THREE.Vector3( 1.7, - 1.1, .3 ) },
                            { index: 4, rotationMin: new THREE.Vector3( 0.1, - 0.7, - 1.8 ), rotationMax: new THREE.Vector3( 1.1, 0, - 1.4 ) },
                        ],
                    }
                ];
                IKSolver = new CCDIKSolver( OOI.kira, iks );

                // 8. CONTROLES
                orbitControls = new OrbitControls( camera, renderer.domElement );
                orbitControls.minDistance = 0.2;
                orbitControls.maxDistance = 1.5;
                orbitControls.enableDamping = true;
                
                transformControls = new TransformControls( camera, renderer.domElement );
                transformControls.size = 0.5;
                transformControls.showX = true;
                transformControls.space = 'world';
                transformControls.attach( OOI.target_hand_l );
                
                // --- CORRECCIÓN AQUÍ ---
                // En versiones nuevas, añadimos el control directamente, NO .getHelper()
                scene.add( transformControls ); 
                // -----------------------

                transformControls.addEventListener( 'mouseDown', () => orbitControls.enabled = false );
                transformControls.addEventListener( 'mouseUp', () => orbitControls.enabled = true );

                // 9. PARTÍCULAS
                createFloatingParticles();

                window.addEventListener( 'resize', onWindowResize, false );
                
                // INICIAR ANIMACIÓN
                renderer.setAnimationLoop( animate );

            } catch ( error ) {
                console.error("Error cargando el modelo:", error);
            }
        }

        function createFloatingParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 500; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4 + 1,
                    (Math.random() - 0.5) * 4
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xff00ff, size: 0.02, transparent: true, opacity: 0.6 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        function animate() {
            const time = clock.getElapsedTime();

            if(particlesMesh) {
                particlesMesh.rotation.y = time * 0.05;
                particlesMesh.position.y = Math.sin(time * 0.5) * 0.1;
            }

            if(OOI.sphere) {
                const s = 1 + Math.sin(time * 3) * 0.2;
                OOI.sphere.scale.set(s, s, s);
            }

            if ( OOI.head && OOI.sphere && conf.turnHead ) {
                OOI.sphere.getWorldPosition( v0 );
                OOI.head.lookAt( v0 );
                OOI.head.rotation.set( OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z );
            }

            if ( conf.ik_solver ) {
                updateIK();
            }

            orbitControls.update();
            composer.render();
        }

        function updateIK() {
            if ( IKSolver ) IKSolver.update();
            scene.traverse( function ( object ) {
                if ( object.isSkinnedMesh ) object.computeBoundingSphere();
            } );
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
            composer.setSize( window.innerWidth, window.innerHeight );
        }
    </script>
</body>
</html>
