<!DOCTYPE html>
<html lang="en">
<head>
    <title>Kira: Keyboard Control</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #888;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            color: #444;
            text-transform: uppercase;
            letter-spacing: 2px;
            line-height: 1.5em;
        }
        .controls { color: #00ffff; font-weight: bold; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="info">
        Interactive Dream Sequence<br/>
        <span class="controls">FLECHAS:</span> Mover Arriba/Abajo/Lados &bull; <span class="controls">W / S:</span> Profundidad
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { CCDIKSolver } from 'three/addons/animation/CCDIKSolver.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN MAESTRA ---
        const CONFIG = {
            bloomStrength: 0,
            bloomRadius: 0.306,
            orbIntensity: 0.6,
            orbColor: 0x00ffff,
            rimIntensity: 6.12,
            rimColor: 0xff00ff,
            camPos: new THREE.Vector3(0.92, 1.41, -1.64),
            camTarget: new THREE.Vector3(2.14, 1.11, -0.24),
            moveSpeed: 0.03 // Velocidad de movimiento del teclado
        };

        let scene, camera, renderer, composer;
        let orbitControls, transformControls;
        let particlesMesh;
        const OOI = {};
        let IKSolver;
        const clock = new THREE.Clock();
        const v0 = new THREE.Vector3();

        // Estado del teclado
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            w: false,
            s: false,
            W: false,
            S: false
        };

        init();

        async function init() {
            // 1. ESCENA
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.03);
            scene.background = new THREE.Color(0x050510);

            // 2. CÁMARA
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.001, 5000);
            camera.position.copy(CONFIG.camPos);

            // 3. LUCES
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

            // Luz de Orbe (Cian) - Se añade luego al objeto
            const orbLight = new THREE.PointLight(CONFIG.orbColor, CONFIG.orbIntensity, 5);

            // Luz de Contra (Magenta)
            const rimLight = new THREE.SpotLight(CONFIG.rimColor, CONFIG.rimIntensity);
            rimLight.position.set(-2, 2, -2);
            rimLight.lookAt(0, 1, 0);
            scene.add(rimLight);

            // 4. RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = CONFIG.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 5. CARGA DEL MODELO
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            const gltfLoader = new GLTFLoader();
            gltfLoader.setDRACOLoader(dracoLoader);

            try {
                const gltf = await gltfLoader.loadAsync('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/models/gltf/kira.glb');

                gltf.scene.traverse(n => {
                    if (n.name === 'head') OOI.head = n;
                    if (n.name === 'lowerarm_l') OOI.lowerarm_l = n;
                    if (n.name === 'Upperarm_l') OOI.Upperarm_l = n;
                    if (n.name === 'hand_l') OOI.hand_l = n;
                    if (n.name === 'target_hand_l') OOI.target_hand_l = n;
                    if (n.name === 'boule') OOI.sphere = n;
                    if (n.name === 'Kira_Shirt_left') OOI.kira = n;

                    if (n.isMesh) {
                        n.castShadow = true;
                        n.receiveShadow = true;
                        if (n.material) n.material.roughness = 0.4;
                    }
                });
                scene.add(gltf.scene);

                // Configurar Orbe
                OOI.hand_l.attach(OOI.sphere);
                const orbMaterial = new THREE.MeshBasicMaterial({ color: CONFIG.orbColor, wireframe: true });
                OOI.sphere.material = orbMaterial;
                OOI.sphere.add(orbLight);

                const coreGeo = new THREE.IcosahedronGeometry(0.05, 0);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const core = new THREE.Mesh(coreGeo, coreMat);
                OOI.sphere.add(core);

                // Configurar IK
                OOI.kira.add(OOI.kira.skeleton.bones[0]);
                const iks = [{
                    target: 22,
                    effector: 6,
                    links: [
                        { index: 5, rotationMin: new THREE.Vector3(1.2, -1.8, -.4), rotationMax: new THREE.Vector3(1.7, -1.1, .3) },
                        { index: 4, rotationMin: new THREE.Vector3(0.1, -0.7, -1.8), rotationMax: new THREE.Vector3(1.1, 0, -1.4) },
                    ],
                }];
                IKSolver = new CCDIKSolver(OOI.kira, iks);

                // Setup Controles Cámara
                orbitControls = new OrbitControls(camera, renderer.domElement);
                orbitControls.minDistance = 0.1;
                orbitControls.maxDistance = 10;
                orbitControls.enableDamping = true;
                orbitControls.target.copy(CONFIG.camTarget);
                orbitControls.update();

                // Setup Controles Objeto (Visualizador)
                transformControls = new TransformControls(camera, renderer.domElement);
                transformControls.size = 0.4;
                transformControls.space = 'world';
                transformControls.attach(OOI.target_hand_l);
                // Ocultamos el gizmo visual si queremos que se vea más limpio, o lo dejamos:
                scene.add(transformControls);

                // Listener para desactivar órbita al arrastrar
                transformControls.addEventListener('mouseDown', () => orbitControls.enabled = false);
                transformControls.addEventListener('mouseUp', () => orbitControls.enabled = true);

                createFloatingParticles();
                setupKeyboard(); // Inicializamos el teclado
                
                window.addEventListener('resize', onWindowResize, false);
                renderer.setAnimationLoop(animate);

            } catch (error) {
                console.error("Error cargando modelo:", error);
            }
        }

        function createFloatingParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 400; i++) {
                vertices.push( (Math.random()-0.5)*4, (Math.random()-0.5)*4+1, (Math.random()-0.5)*4 );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: CONFIG.rimColor, size: 0.015, transparent: true, opacity: 0.5 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        // --- LÓGICA DE TECLADO ---
        function setupKeyboard() {
            window.addEventListener('keydown', (e) => {
                if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
                    keys[e.key] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
                    keys[e.key] = false;
                }
            });
        }

        function processKeyboardMovement() {
            if (!OOI.target_hand_l) return;

            const target = OOI.target_hand_l;
            const speed = CONFIG.moveSpeed;

            // X axis (Izquierda / Derecha)
            if (keys.ArrowRight) target.position.x += speed;
            if (keys.ArrowLeft) target.position.x -= speed;

            // Y axis (Arriba / Abajo)
            if (keys.ArrowUp) target.position.y += speed;
            if (keys.ArrowDown) target.position.y -= speed;

            // Z axis (Profundidad con W/S)
            if (keys.w || keys.W) target.position.z -= speed;
            if (keys.s || keys.S) target.position.z += speed;
        }

        function animate() {
            const time = clock.getElapsedTime();

            // 1. Procesar Movimiento de Teclado
            processKeyboardMovement();

            // 2. Animaciones Ambientales
            if (particlesMesh) {
                particlesMesh.rotation.y = time * 0.03;
                particlesMesh.position.y = Math.sin(time * 0.2) * 0.05;
            }
            if (OOI.sphere) {
                const s = 1 + Math.sin(time * 2.5) * 0.1;
                OOI.sphere.scale.set(s, s, s);
            }

            // 3. Cabeza sigue al orbe
            if (OOI.head && OOI.sphere) {
                OOI.sphere.getWorldPosition(v0);
                OOI.head.lookAt(v0);
                OOI.head.rotation.set(OOI.head.rotation.x, OOI.head.rotation.y + Math.PI, OOI.head.rotation.z);
            }

            // 4. Actualizar IK
            if (IKSolver) IKSolver.update();
            scene.traverse(o => { if (o.isSkinnedMesh) o.computeBoundingSphere(); });

            orbitControls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
