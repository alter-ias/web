<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IRIS MK.II | Modular System</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Montserrat:wght@300;400;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
        }
        /* --- LAYOUT SPLIT --- */
        #canvas-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 60%;
            height: 100vh;
            z-index: 10;
            /* Fondo sutilmente integrado */
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }
        #content-sidebar {
            position: relative;
            width: 40%;
            height: 100vh;
            overflow-y: auto;
            z-index: 20;
            background: linear-gradient(90deg, #050505 0%, #050505 90%, transparent 100%);
            scrollbar-width: none;
        }
        #content-sidebar::-webkit-scrollbar {
            display: none;
        }
        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 10%;
            box-sizing: border-box;
        }
        /* --- TYPOGRAPHY & UI --- */
        .content-box {
            padding: 40px 0;
            border-left: 2px solid #00E5FF;
            padding-left: 30px;
            opacity: 0;
            transform: translateY(30px);
            transition: 0.8s ease-out;
        }
        .content-box.visible {
            opacity: 1;
            transform: translateY(0);
        }
        h1 {
            font-family: 'Rajdhani';
            font-size: 80px;
            margin: 0;
            line-height: 0.9;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 0 20px rgba(0, 229, 255, 0.3);
        }
        h2 {
            font-family: 'Rajdhani';
            font-size: 40px;
            margin: 0 0 20px 0;
            color: #00E5FF;
            text-transform: uppercase;
        }
        p {
            font-size: 16px;
            line-height: 1.6;
            color: #ccc;
            margin-bottom: 20px;
            max-width: 400px;
        }
        .accent {
            color: #00E5FF;
            font-weight: 700;
        }
        .interaction-hint {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 30;
            text-align: right;
            font-size: 10px;
            color: #666;
            letter-spacing: 1px;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            backdrop-filter: blur(5px);
            border: 1px solid #222;
            line-height: 1.8;
        }
        .key {
            border: 1px solid #444;
            padding: 2px 4px;
            border-radius: 3px;
            color: #eee;
            background: #222;
        }
        .btn-cta {
            padding: 15px 40px;
            border: 1px solid #00E5FF;
            color: #00E5FF;
            background: transparent;
            font-family: 'Rajdhani';
            font-size: 18px;
            cursor: pointer;
            transition: 0.3s;
            text-decoration: none;
            display: inline-block;
            letter-spacing: 2px;
            margin-right: 10px;
            margin-bottom: 10px;
            text-align: center;
        }
        .btn-cta:hover {
            background: #00E5FF;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 229, 255, 0.4);
        }
        .btn-cta.secondary {
            border-color: #fff;
            color: #fff;
        }
        .btn-cta.secondary:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }
        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            body {
                height: 100vh;
            }
            #canvas-container {
                width: 100%;
                height: 50%;
                top: 0;
                left: 0;
            }
            #content-sidebar {
                width: 100%;
                height: 50%;
                position: absolute;
                bottom: 0;
                left: 0;
                border-top: 1px solid #222;
                background: #050505;
            }
            section {
                min-height: 50vh;
                padding: 40px 30px;
                border-bottom: 1px solid #111;
            }
            h1 {
                font-size: 50px;
            }
            h2 {
                font-size: 28px;
            }
            .interaction-hint {
                top: 10px;
                right: 10px;
                bottom: auto;
                font-size: 9px;
            }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.skypack.dev/three@0.136.0",
                "three/addons/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="interaction-hint">
        SCROLL : ROTAR / DETALLES<br>
        <span class="key">CTRL</span> + SCROLL : EXPLOSIÓN<br>
        (MÓVIL: PINCH ZOOM)<br>
        DRAG : ORBITAR
    </div>
    <div id="content-sidebar">
        <section id="sec-intro">
            <div class="content-box visible" style="border:none; padding-left:0;">
                <h1 style="color:#00E5FF">IRIS</h1>
                <h1 style="font-size: 30px; letter-spacing: 6px; color: #888;">MK.II MODULAR</h1>
                <br>
                <p>El sistema de control infinito. Configura tu rejilla. <span class="accent">Rompe los límites.</span>
                </p>
                <div style="margin-top: 40px; font-size: 12px; letter-spacing: 2px; color: #444;">▼ DESLIZA PARA VER
                </div>
            </div>
        </section>
        <section id="sec-grid">
            <div class="content-box">
                <h2>Grid Magnético</h2>
                <p>Sistema de anclaje de 9 puntos. Intercambia módulos en caliente sin latencia.</p>
                <p>Knobs, Faders, Pads y Touch Strips. Todo conectado mediante un bus de datos de <span
                        class="accent">alta velocidad</span>.</p>
            </div>
        </section>
        <section id="sec-light">
            <div class="content-box">
                <h2>Luz Reactiva</h2>
                <p>Cada módulo cuenta con retroiluminación LED direccionable individualmente.</p>
                <p>Feedback visual instantáneo de tus parámetros en entornos de baja luminosidad.</p>
            </div>
        </section>
        <section id="sec-explode">
            <div class="content-box" style="border:none;">
                <h2>ARQUITECTURA ABIERTA</h2>
                <p>Diseña tus propios módulos. Imprime. Conecta. Toca.</p>
                <br>
                <a href="#" class="btn-cta">PRE-ORDER</a>
                <a href="https://www.alterlabgen.lat/iris2.html" class="btn-cta secondary">IRIS APP</a>
                <div style="margin-top: 25px; font-size: 11px; color: #555; letter-spacing: 1px;">
                    Un proyecto de AlterLab Generative Systems
                </div>
            </div>
        </section>
        <div style="height: 20vh;"></div>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        // --- SCROLL & UI LOGIC ---
        const sidebar = document.getElementById('content-sidebar');
        const sections = document.querySelectorAll('section');
        let scrollY = 0;
        let pScroll = 0;
        function updateScroll() {
            scrollY = sidebar.scrollTop;
            const max = sidebar.scrollHeight - sidebar.clientHeight;
            pScroll = Math.max(0, Math.min(1, scrollY / max));
            sections.forEach(sec => {
                const rect = sec.getBoundingClientRect();
                // Simple visibility check based on sidebar overlap
                if (rect.top < window.innerHeight * 0.7) {
                    const box = sec.querySelector('.content-box');
                    if (box) box.classList.add('visible');
                }
            });
        }
        sidebar.addEventListener('scroll', updateScroll);
        updateScroll();
        // --- 3D CONFIGURATION ---
        const CONFIG = {
            moduleSize: 2.0,
            gap: 0.1,
            colors: {
                chassis: 0x1a1a1a,
                accent: 0x00E5FF,
                highlight: 0xffffff,
                ledOff: 0x222222
            }
        };
        const container = document.getElementById('canvas-container');
        // Renderer Setup
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        const scene = new THREE.Scene();
        // Fog to blend nicely with the split background
        scene.fog = new THREE.FogExp2(0x050505, 0.02);
        const camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(10, 14, 14);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        // --- POST PROCESSING (BLOOM) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        // Res, Strength, Radius, Threshold
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.2, 0.4, 0.85);
        composer.addPass(bloomPass);
        // --- LIGHTING ---
        RectAreaLightUniformsLib.init();
        const ambient = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambient);
        const spot1 = new THREE.SpotLight(0xffffff, 8);
        spot1.position.set(10, 20, 10);
        spot1.angle = Math.PI / 6;
        spot1.penumbra = 1;
        spot1.castShadow = true;
        scene.add(spot1);
        const spot2 = new THREE.SpotLight(0x00acc1, 5); // Cyan rim light
        spot2.position.set(-10, 5, -10);
        spot2.lookAt(0, 0, 0);
        scene.add(spot2);
        const rectLight = new THREE.RectAreaLight(0xffffff, 2, 20, 20);
        rectLight.position.set(0, 10, 0);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);
        // --- MATERIALS ---
        const materials = {
            chassis: new THREE.MeshStandardMaterial({ color: CONFIG.colors.chassis, roughness: 0.3, metalness: 0.8 }),
            panel: new THREE.MeshPhysicalMaterial({ color: 0x111111, roughness: 0.2, metalness: 0.1, clearcoat: 1.0 }),
            connector: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5, metalness: 0.9 }),
            led: new THREE.MeshStandardMaterial({ color: CONFIG.colors.accent, emissive: CONFIG.colors.accent, emissiveIntensity: 3.0, toneMapped: false }),
            glowText: new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.8 })
        };
        // --- MODULAR SYSTEM LOGIC ---
        const moduleGroup = new THREE.Group(); // Pivot group for rotation
        scene.add(moduleGroup);
        const modules = [];
        class Module {
            constructor(x, z, type) {
                this.homePos = new THREE.Vector3(x * (CONFIG.moduleSize + CONFIG.gap), 0, z * (CONFIG.moduleSize + CONFIG.gap));
                this.group = new THREE.Group();
                this.group.position.copy(this.homePos);
                this.parts = []; // Array of { mesh, homeLocalPos, speed }
                this.createChassis();
                this.createConnectors();
                if (type === 'fader') this.createFader();
                else if (type === 'knob') this.createKnobs();
                else if (type === 'pad') this.createPads();
                else if (type === 'touch') this.createTouch();
                else if (type === 'roller') this.createRoller();
                moduleGroup.add(this.group);
                modules.push(this);
            }
            createChassis() {
                const geo = new RoundedBoxGeometry(CONFIG.moduleSize, 0.5, CONFIG.moduleSize, 4, 0.05);
                const mesh = new THREE.Mesh(geo, materials.chassis);
                mesh.position.y = 0.25;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.group.add(mesh);
                // Top Panel
                const panelGeo = new RoundedBoxGeometry(CONFIG.moduleSize - 0.2, 0.05, CONFIG.moduleSize - 0.2, 2, 0.02);
                const panel = new THREE.Mesh(panelGeo, materials.panel);
                panel.position.y = 0.51;
                panel.receiveShadow = true;
                this.group.add(panel);
            }
            createConnectors() {
                const geo = new THREE.CylinderGeometry(0.05, 0.05, 0.55, 8);
                geo.rotateZ(Math.PI / 2);
                const sides = [
                    { x: CONFIG.moduleSize / 2, z: 0, rot: 0 },
                    { x: -CONFIG.moduleSize / 2, z: 0, rot: 0 },
                    { x: 0, z: CONFIG.moduleSize / 2, rot: Math.PI / 2 },
                    { x: 0, z: -CONFIG.moduleSize / 2, rot: Math.PI / 2 }
                ];
                sides.forEach(s => {
                    const m = new THREE.Mesh(geo, materials.connector);
                    m.position.set(s.x, 0.25, s.z);
                    m.rotation.y = s.rot;
                    this.group.add(m);
                });
            }
            addToParts(mesh, speed = 1.0) {
                this.group.add(mesh);
                this.parts.push({ mesh: mesh, home: mesh.position.clone(), speed: speed });
            }
            createFader() {
                const track = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.02, 1.4), new THREE.MeshStandardMaterial({ color: 0x000 }));
                track.position.set(0, 0.54, 0);
                this.group.add(track);
                const cap = new THREE.Mesh(new RoundedBoxGeometry(0.3, 0.4, 0.15, 4, 0.02), materials.chassis);
                cap.castShadow = true; cap.position.set(0, 0.7, 0);
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.05, 0.02), materials.led);
                line.position.set(0, 0.8, 0); cap.add(line);
                this.addToParts(cap, 2.0);
            }
            createKnobs() {
                const kGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.3, 32);
                const ringGeo = new THREE.TorusGeometry(0.3, 0.02, 4, 32); ringGeo.rotateX(Math.PI / 2);
                for (let i = 0; i < 4; i++) {
                    const x = (i % 2 === 0) ? -0.5 : 0.5;
                    const z = (i < 2) ? -0.5 : 0.5;
                    const kMesh = new THREE.Mesh(kGeo, materials.chassis);
                    kMesh.castShadow = true; kMesh.position.set(x, 0.65, z);
                    const ring = new THREE.Mesh(ringGeo, materials.led);
                    ring.position.set(x, 0.54, z); this.group.add(ring);
                    this.addToParts(kMesh, 1.5 + Math.random());
                }
            }
            createPads() {
                const padGeo = new RoundedBoxGeometry(0.3, 0.1, 0.3, 2, 0.02);
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const active = Math.random() > 0.8;
                        const mat = active ? materials.led : materials.connector;
                        const pad = new THREE.Mesh(padGeo, mat);
                        pad.position.set(-0.6 + c * 0.4, 0.55, -0.6 + r * 0.4);
                        pad.castShadow = true;
                        this.addToParts(pad, 1.0 + (r + c) * 0.1);
                    }
                }
            }
            createTouch() {
                const surfaceGeo = new THREE.PlaneGeometry(1.6, 1.6); surfaceGeo.rotateX(-Math.PI / 2);
                const surface = new THREE.Mesh(surfaceGeo, new THREE.MeshPhysicalMaterial({ color: 0x000000, roughness: 0.1, opacity: 0.9, transparent: true }));
                surface.position.set(0, 0.54, 0); this.group.add(surface);
                const cursor = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.12, 32), materials.led);
                cursor.rotation.x = -Math.PI / 2; cursor.position.set(0.2, 0.55, -0.3);
                this.addToParts(cursor, 0.5);
            }
            createRoller() {
                const rGroup = new THREE.Group();
                // Half-cylinder geometry
                // radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength
                // Half cylinder: thetaLength = PI
                const geo = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 64, 1, false, 0, Math.PI);
                const roller = new THREE.Mesh(geo, materials.chassis);
                // Let's try this specific orientation which is robust:
                roller.rotation.set(0, 0, 0); // reset
                roller.rotateZ(Math.PI / 2); // Axis along X
                roller.rotateX(-Math.PI / 2); // Rotate to face up
                roller.castShadow = true;
                // Stripe needs same rotation relative to roller
                const sGeo = new THREE.CylinderGeometry(0.81, 0.81, 0.05, 64, 1, false, 0, Math.PI);
                const stripe = new THREE.Mesh(sGeo, materials.led);
                stripe.rotation.copy(roller.rotation);
                rGroup.add(roller);
                rGroup.add(stripe);
                // Position group on top of chassis
                rGroup.position.set(0, 0.51, 0);
                const cradle = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.2, 0.8), materials.panel);
                cradle.position.set(0, 0.5, 0);
                this.group.add(cradle);
                this.addToParts(rGroup, 1.5);
            }
            update(explodeVal) {
                // Move entire module
                const centerDist = this.homePos.clone().normalize();
                this.group.position.x = this.homePos.x + (centerDist.x * explodeVal * 2.0);
                this.group.position.z = this.homePos.z + (centerDist.z * explodeVal * 2.0);
                // Explode parts
                this.parts.forEach(p => {
                    p.mesh.position.y = p.home.y + (explodeVal * p.speed);
                });
            }
        }
        // --- GRID GENERATION ---
        const layout = [
            ['knob', 'fader', 'knob'],
            ['pad', 'touch', 'pad'],
            ['roller', 'fader', 'roller']
        ];
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                new Module(c - 1, r - 1, layout[r][c]);
            }
        }
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.ShadowMaterial({ opacity: 0.2 }));
        floor.rotation.x = -Math.PI / 2; floor.position.y = -0.1;
        scene.add(floor);
        // --- INTERACTION LOGIC (MERGED) ---
        let explodeTarget = 0.0;
        let explodeCurrent = 0.0;
        // Desktop Wheel Interaction
        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                controls.enableZoom = false;
                explodeTarget += e.deltaY * 0.002;
                explodeTarget = Math.max(0, Math.min(2.0, explodeTarget));
            } else {
                controls.enableZoom = true;
            }
        }, { passive: false });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') controls.enableZoom = true;
        });
        // Mobile / Safari Gesture Interaction
        let lastScale = 1;
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
            lastScale = 1;
            controls.enabled = false;
        });
        document.addEventListener('gesturechange', (e) => {
            e.preventDefault();
            const delta = e.scale - lastScale;
            lastScale = e.scale;
            explodeTarget += delta * 3.0; // Sensibilidad
            explodeTarget = Math.max(0, Math.min(2.0, explodeTarget));
        });
        document.addEventListener('gestureend', (e) => {
            e.preventDefault();
            controls.enabled = true;
        });
        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            // 1. Scroll-based rotation (from original code)
            const targetRotY = pScroll * 0.5;
            const targetRotX = pScroll * 0.2;
            // Rotate the group holding all modules
            moduleGroup.rotation.y += (targetRotY - moduleGroup.rotation.y) * 0.05;
            moduleGroup.rotation.x += (targetRotX - moduleGroup.rotation.x) * 0.05;
            // 2. Explosion Logic
            explodeCurrent += (explodeTarget - explodeCurrent) * 0.1;
            modules.forEach(m => m.update(explodeCurrent));
            // 3. Render with Bloom
            composer.render();
        }
        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            composer.setSize(w, h);
        });
        animate();
    </script>
</body>
</html>
