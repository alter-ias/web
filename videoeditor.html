<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filtros de Video Artísticos en JS</title>
    <style>
        body {
            font-family: sans-serif;
            background-color: #222;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        h1 { margin-bottom: 10px; }

        .controls {
            background: #333;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 800px;
            text-align: center;
        }

        input[type=file] {
            margin-bottom: 15px;
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        button:hover { background-color: #777; }
        button.active { background-color: #00a8ff; }

        /* El canvas es donde se muestra el video procesado */
        #outputCanvas {
            max-width: 100%;
            border: 2px solid #555;
            background: #000;
            /* Inicialmente oculto hasta que se cargue un video */
            display: none; 
        }

        /* El elemento de video original permanece oculto, solo lo usamos como fuente */
        #sourceVideo {
            display: none;
        }
    </style>
</head>
<body>

    <h1>Procesador de Video Artístico</h1>

    <div class="controls">
        <p>1. Sube tu archivo de video (mp4, webm):</p>
        <input type="file" id="videoUpload" accept="video/*">
        
        <p>2. Selecciona un filtro mientras se reproduce:</p>
        <div class="filter-buttons" id="buttonContainer">
            </div>
    </div>

    <canvas id="outputCanvas"></canvas>
    <video id="sourceVideo" playsinline loop muted></video>

    <script>
        const videoUpload = document.getElementById('videoUpload');
        const sourceVideo = document.getElementById('sourceVideo');
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d', { willReadFrequently: true });
        const buttonContainer = document.getElementById('buttonContainer');

        let currentFilterStr = 'none';
        let animationId;

        // --- DEFINICIÓN DE FILTROS ---
        // Cada filtro es una función que manipula el array de píxeles (data)
        // data[i] = Rojo, data[i+1] = Verde, data[i+2] = Azul, data[i+3] = Alpha
        const filters = {
            'Original': (data) => { /* No hace nada */ },

            'Noir (Alto Contraste)': (data) => {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    // Convertir a escala de grises usando luminosidad percibida
                    let gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    // Aplicar un umbral fuerte para alto contraste
                    let val = gray > 100 ? 255 : 0;
                    data[i] = data[i+1] = data[i+2] = val;
                }
            },

            'Toxic (Mapa de Color)': (data) => {
                 for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    let gray = (r + g + b) / 3;
                    
                    // Mapear tonos de gris a colores tóxicos
                    if (gray < 60) { // Sombras oscuras -> Morado/Azul
                         data[i] = 50; data[i+1] = 0; data[i+2] = 150;
                    } else if (gray < 150) { // Tonos medios -> Verde radiactivo
                         data[i] = 0; data[i+1] = 255; data[i+2] = 50;
                    } else { // Luces altas -> Amarillo quemado
                         data[i] = 255; data[i+1] = 255; data[i+2] = 0;
                    }
                }
            },

            'Tinta/Fotocopia': (data) => {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    let gray = (r + g + b) / 3;
                    // Umbral simple e inversión para efecto de tinta
                    let val = gray > 120 ? 235 : 30; // No usar blanco/negro puro para efecto papel
                    data[i] = data[i+1] = data[i+2] = val;
                }
            },

             'Sepia Retro': (data) => {
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i+1], b = data[i+2];
                    // Fórmula estándar de sepia
                    data[i] = (r * 0.393) + (g * 0.769) + (b * 0.189); // Rojo
                    data[i+1] = (r * 0.349) + (g * 0.686) + (b * 0.168); // Verde
                    data[i+2] = (r * 0.272) + (g * 0.534) + (b * 0.131); // Azul
                }
            },
             'Cianotipo (Azul)': (data) => {
                for (let i = 0; i < data.length; i += 4) {
                    // Escala de grises invertida en el canal azul
                    let gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                    data[i] = 0; // R
                    data[i+1] = gray * 0.5; // G (un poco de verde para tono cian)
                    data[i+2] = gray + 50; // B (predominante)
                }
            }
        };

        // --- CONFIGURACIÓN DE LA INTERFAZ ---
        // Generar botones dinámicamente
        for (const key in filters) {
            const btn = document.createElement('button');
            btn.innerText = key;
            btn.addEventListener('click', () => {
                currentFilterStr = key;
                // Actualizar estado visual de los botones
                document.querySelectorAll('.filter-buttons button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
            buttonContainer.appendChild(btn);
        }
        buttonContainer.firstChild.classList.add('active'); // Activar el primero por defecto

        // --- MANEJO DE VIDEO ---
        
        // 1. Cargar el video cuando el usuario selecciona el archivo
        videoUpload.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                sourceVideo.src = fileURL;
                // Esperar a que el video tenga metadatos para ajustar el canvas
                sourceVideo.onloadedmetadata = () => {
                    outputCanvas.width = sourceVideo.videoWidth;
                    outputCanvas.height = sourceVideo.videoHeight;
                    outputCanvas.style.display = 'block';
                    sourceVideo.play();
                    processVideoFrame(); // Iniciar el bucle de procesamiento
                };
            }
        });


        // 2. El Bucle Principal de Procesamiento
        function processVideoFrame() {
            // Si el video está pausado o terminó, detener el bucle
            if (sourceVideo.paused || sourceVideo.ended) {
                animationId = requestAnimationFrame(processVideoFrame);
                return; 
            }

            // A. Dibujar el fotograma actual del video en el canvas
            ctx.drawImage(sourceVideo, 0, 0, outputCanvas.width, outputCanvas.height);

            // B. Si hay un filtro seleccionado, obtener los píxeles y manipularlos
            if (currentFilterStr !== 'Original') {
                // Obtener los datos crudos de la imagen (R,G,B,A para cada píxel)
                let frameData = ctx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
                let data = frameData.data;

                // Aplicar la función del filtro seleccionado
                filters[currentFilterStr](data);

                // Poner los datos modificados de vuelta en el canvas
                ctx.putImageData(frameData, 0, 0);
            }

            // C. Solicitar el siguiente fotograma de animación
            animationId = requestAnimationFrame(processVideoFrame);
        }
    </script>
</body>
</html>
