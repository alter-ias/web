<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Split Brain Loop Station</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; letter-spacing: 2px;
            background: rgba(0, 10, 20, 0.9); padding: 20px 40px; border-radius: 4px;
            border: 1px solid #0ff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            pointer-events: none; z-index: 10; text-align: center;
        }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Divisor de pantalla visual */
        #screen-divider {
            position: absolute; top: 0; bottom: 0; left: 50%; width: 1px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.2), transparent);
            z-index: 1;
        }
        .zone-label {
            position: absolute; top: 20px; color: rgba(255,255,255,0.3);
            font-size: 12px; font-weight: bold; letter-spacing: 4px;
        }
        #label-chords { left: 25%; transform: translateX(-50%); }
        #label-melody { right: 25%; transform: translateX(50%); }

        /* Pedalera */
        #pedalboard {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; z-index: 10; pointer-events: auto;
        }

        .pedal {
            width: 70px; height: 90px;
            background: linear-gradient(145deg, #222, #111);
            border: 2px solid #444; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            padding-bottom: 10px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.6);
            transition: transform 0.1s;
        }
        .pedal:active { transform: scale(0.95); }

        .pedal-light {
            width: 12px; height: 12px; border-radius: 50%; background: #333;
            margin-bottom: 15px; box-shadow: 0 0 5px rgba(0,0,0,0.5) inset;
            transition: all 0.2s;
        }
        .pedal-label { color: #888; font-size: 9px; font-weight: bold; text-transform: uppercase; }
        .pedal-key { color: #555; font-size: 8px; margin-top: 3px; }

        #pedal-sustain.active .pedal-light { background: #0f0; box-shadow: 0 0 10px #0f0; border-color: #0f0; }
        #pedal-sustain.active { border-color: #0f0; }
        
        #pedal-loop.recording .pedal-light { background: #f00; box-shadow: 0 0 10px #f00; }
        #pedal-loop.playing .pedal-light { background: #0f0; box-shadow: 0 0 10px #0f0; }
        #pedal-loop.recording { border-color: #f00; }
        #pedal-loop.playing { border-color: #0f0; }

        #hud-status {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            color: #0ff; font-size: 10px; font-family: monospace;
        }

        .lil-gui { --background-color: rgba(5, 5, 10, 0.9); }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- CONFIG ---
        const params = {
            key: 'A',
            bloomStrength: 1.2,
            opacity: 0.8,
            soundEnabled: true,
            sensitivity: 1.5
        };

        // --- TEORÍA MUSICAL ---
        const NOTES = { 'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88 };
        // Intervalos Pentatónica Menor para Melodía
        const PENTA_INTERVALS = [0, 3, 5, 7, 10]; 

        function getFrequency(baseFreq, semitones) { return baseFreq * Math.pow(2, semitones / 12); }

        function generateScale(rootKey) {
            const base = NOTES[rootKey] / 2; // Empezar grave
            const scale = [];
            // 3 octavas para la mano derecha
            for (let oct = 0; oct < 3; oct++) {
                PENTA_INTERVALS.forEach(interval => scale.push(getFrequency(base * Math.pow(2, oct), interval)));
            }
            return scale;
        }

        // Acordes funcionales para la mano izquierda (i - VI - VII)
        function generateChords(rootKey) {
            const base = NOTES[rootKey] / 4; // Bajo profundo
            // i (Menor)
            const chord1 = [getFrequency(base, 0), getFrequency(base, 3), getFrequency(base, 7), getFrequency(base, 12)];
            // VI (Mayor) - Movimiento cromático interesante en pentatónica menor
            const chord2 = [getFrequency(base, 8), getFrequency(base, 12), getFrequency(base, 15), getFrequency(base, 20)];
            // VII (Mayor)
            const chord3 = [getFrequency(base, 10), getFrequency(base, 14), getFrequency(base, 17), getFrequency(base, 22)];
            return [chord1, chord2, chord3];
        }

        let currentScale = generateScale(params.key);
        let currentChords = generateChords(params.key);

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.master = null;
                this.dest = null;
                
                // Melodía
                this.melOsc = null;
                this.melGain = null;

                // Acordes
                this.chordOscs = [];
                this.chordGain = null;
                this.chordFilter = null;

                this.isInit = false;
                this.sustain = false;
                this.lastChordIdx = -1;

                // Looper
                this.recorder = null;
                this.chunks = [];
                this.loopBuffer = null;
                this.loopSource = null;
                this.loopState = 'IDLE';
            }

            init() {
                if(this.isInit) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.8;
                this.master.connect(this.ctx.destination);
                
                // Grabador
                this.dest = this.ctx.createMediaStreamDestination();
                this.master.connect(this.dest);

                // --- CANAL MELODÍA (Derecha) ---
                this.melOsc = this.ctx.createOscillator();
                this.melOsc.type = 'triangle';
                this.melGain = this.ctx.createGain();
                this.melGain.gain.value = 0;
                
                // Delay Melodía
                const d = this.ctx.createDelay();
                d.delayTime.value = 0.3;
                const dF = this.ctx.createGain();
                dF.gain.value = 0.4;
                
                this.melOsc.connect(this.melGain);
                this.melGain.connect(this.master);
                this.melGain.connect(d);
                d.connect(dF); dF.connect(d); d.connect(this.master);
                this.melOsc.start();

                // --- CANAL ACORDES (Izquierda) ---
                this.chordGain = this.ctx.createGain();
                this.chordGain.gain.value = 0;
                this.chordFilter = this.ctx.createBiquadFilter();
                this.chordFilter.type = 'lowpass';
                this.chordFilter.frequency.value = 800;
                this.chordGain.connect(this.chordFilter);
                this.chordFilter.connect(this.master);

                // 4 osciladores para acordes densos
                for(let i=0; i<4; i++) {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    osc.detune.value = (Math.random()-0.5)*10; // Chorus natural
                    osc.connect(this.chordGain);
                    osc.start();
                    this.chordOscs.push(osc);
                }

                this.isInit = true;
                this.updateUI();
            }

            setKey(k) {
                params.key = k;
                currentScale = generateScale(k);
                currentChords = generateChords(k);
                this.updateUI();
            }

            updateUI() {
                if(this.isInit) document.getElementById('hud-status').innerText = `TONALIDAD: ${params.key} MENOR`;
            }

            // Input normalizado 0-1
            handleMelody(x, y, active) {
                if(!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                
                if(active) {
                    // Mapear X (0.5 a 1.0) a escala
                    // Normalizar X de 0.5-1.0 a 0.0-1.0
                    const localX = (x - 0.5) * 2; 
                    const idx = Math.floor(localX * currentScale.length);
                    const safeIdx = Math.min(Math.max(idx, 0), currentScale.length - 1);
                    
                    this.melOsc.frequency.setTargetAtTime(currentScale[safeIdx], t, 0.05);
                    this.melGain.gain.setTargetAtTime(Math.max(0, (1-y)*0.3), t, 0.1);
                } else {
                    this.melGain.gain.setTargetAtTime(0, t, 0.1);
                }
            }

            handleChords(x, y, active) {
                if(!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;

                if(active) {
                    // Mapear X (0.0 a 0.5) a acordes
                    // Normalizar X de 0.0-0.5 a 0.0-1.0
                    const localX = x * 2;
                    let cIdx = 0;
                    if(localX < 0.33) cIdx = 0;      // i
                    else if(localX < 0.66) cIdx = 1; // VI
                    else cIdx = 2;                   // VII

                    if(cIdx !== this.lastChordIdx || this.chordGain.gain.value < 0.01) {
                        const chord = currentChords[cIdx];
                        this.chordOscs.forEach((o, i) => o.frequency.setTargetAtTime(chord[i], t, 0.1));
                        this.lastChordIdx = cIdx;
                    }
                    this.chordGain.gain.setTargetAtTime(Math.max(0, (1-y)*0.2), t, 0.2);
                    // Abrir filtro si la mano sube
                    this.chordFilter.frequency.setTargetAtTime(400 + (1-y)*1000, t, 0.2);
                } else {
                    if(this.sustain) {
                        if(this.chordGain.gain.value < 0.15) this.chordGain.gain.setTargetAtTime(0.15, t, 0.5);
                    } else {
                        this.chordGain.gain.setTargetAtTime(0, t, 0.5);
                    }
                }
            }

            toggleSustain() {
                this.sustain = !this.sustain;
                document.getElementById('pedal-sustain').classList.toggle('active', this.sustain);
                if(!this.sustain) this.chordGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            }

            toggleLoop() {
                if(!this.isInit) return;
                const p = document.getElementById('pedal-loop');
                
                if(this.loopState === 'IDLE' || this.loopState === 'PLAYING') {
                    // Grabar
                    if(this.loopSource) { this.loopSource.stop(); this.loopSource = null; }
                    this.chunks = [];
                    this.recorder = new MediaRecorder(this.dest.stream);
                    this.recorder.ondataavailable = e => this.chunks.push(e.data);
                    this.recorder.start();
                    this.loopState = 'RECORDING';
                    p.className = 'pedal recording';
                } else {
                    // Play
                    this.recorder.stop();
                    this.recorder.onstop = async () => {
                        const blob = new Blob(this.chunks, {'type': 'audio/ogg; codecs=opus'});
                        const arr = await blob.arrayBuffer();
                        this.loopBuffer = await this.ctx.decodeAudioData(arr);
                        this.playLoop();
                    };
                    p.className = 'pedal playing';
                }
            }

            playLoop() {
                if(!this.loopBuffer) return;
                this.loopSource = this.ctx.createBufferSource();
                this.loopSource.buffer = this.loopBuffer;
                this.loopSource.loop = true;
                this.loopSource.connect(this.master);
                this.loopSource.start();
                this.loopState = 'PLAYING';
            }

            clearLoop() {
                if(this.loopSource) { this.loopSource.stop(); this.loopSource = null; }
                this.loopBuffer = null;
                this.loopState = 'IDLE';
                document.getElementById('pedal-loop').className = 'pedal';
            }
        }

        const audio = new AudioEngine();

        // --- VISUAL ENGINE (Dual System) ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.z = 12;
        const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.strength = params.bloomStrength;
        composer.addPass(bloom);

        // Texture Gen
        function createTex() {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const x = c.getContext('2d');
            const g = x.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)');
            x.fillStyle=g; x.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(c);
        }
        const tex = createTex();

        // Objects
        const trails = []; 
        const particles = [];

        // Clase Ribbon (Para Derecha/Melodía) - Preciso y afilado
        class Ribbon {
            constructor(color) {
                this.len = 20; this.pts = []; this.target = new THREE.Vector3(0,-100,0);
                for(let i=0;i<this.len;i++) this.pts.push(new THREE.Vector3(0,-100,0));
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.len*6), 3));
                this.mat = new THREE.MeshBasicMaterial({color:color, transparent:true, opacity:0.8, side:THREE.DoubleSide, blending:THREE.AdditiveBlending});
                this.mesh = new THREE.Mesh(geo, this.mat);
                scene.add(this.mesh);
            }
            update(t) {
                // Lerp head
                this.pts.shift(); 
                const head = this.pts[this.pts.length-1].clone().lerp(this.target, 0.3);
                this.pts.push(head);

                const curve = new THREE.CatmullRomCurve3(this.pts, false, 'catmullrom', 0.5);
                const p = curve.getPoints(this.len-1);
                const pos = this.mesh.geometry.attributes.position.array;
                
                for(let i=0; i<this.len; i++) {
                    const w = (i/this.len)*0.4;
                    pos[i*6]=p[i].x-w; pos[i*6+1]=p[i].y; pos[i*6+2]=p[i].z;
                    pos[i*6+3]=p[i].x+w; pos[i*6+4]=p[i].y; pos[i*6+5]=p[i].z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.visible = (this.target.y > -50);
            }
        }

        // Clase Particle (Para Izquierda/Acordes) - Etéreo y suave
        class Cloud {
            constructor(color) {
                this.max = 30; this.target = new THREE.Vector3(0,-100,0);
                this.parts = [];
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.max*3), 3));
                geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.max), 1));
                this.mat = new THREE.PointsMaterial({color:color, size:1, map:tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false});
                this.mesh = new THREE.Points(geo, this.mat);
                scene.add(this.mesh);
                for(let i=0;i<this.max;i++) this.parts.push({p:new THREE.Vector3(0,-100,0), v:new THREE.Vector3(), l:0});
            }
            update(t) {
                // Emit
                if(this.target.y > -50 && Math.random()>0.5) {
                    const p = this.parts.find(x => x.l <= 0);
                    if(p) {
                        p.l = 1; p.p.copy(this.target);
                        p.p.x += (Math.random()-0.5); p.p.y += (Math.random()-0.5);
                        p.v.set((Math.random()-0.5)*0.1, 0.05, (Math.random()-0.5)*0.1);
                    }
                }
                const pos = this.mesh.geometry.attributes.position.array;
                const size = this.mesh.geometry.attributes.size.array;
                this.parts.forEach((p,i) => {
                    if(p.l > 0) {
                        p.l -= 0.02; p.p.add(p.v);
                        pos[i*3]=p.p.x; pos[i*3+1]=p.p.y; pos[i*3+2]=p.p.z;
                        size[i] = p.l * 2.0;
                    } else size[i] = 0;
                });
                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.geometry.attributes.size.needsUpdate = true;
            }
        }

        // Crear instancias visuales (5 dedos x 2 manos = 10 slots)
        // Pero ahora los asignamos dinámicamente. 
        // Vamos a crear 10 Clouds y 10 Ribbons y usar el que corresponda según la zona.
        const clouds = Array(10).fill().map(() => new Cloud(0x00ffff)); // Cyan para acordes
        const ribbons = Array(10).fill().map(() => new Ribbon(0xff00ff)); // Magenta para melodía

        // --- MEDIAPIPE LOGIC ---
        const video = document.createElement('video');
        let vw = 10, vh = 10;

        function onResults(res) {
            document.getElementById('loading').style.display = 'none';
            let hasMelody = false;
            let hasChords = false;

            if(res.multiHandLandmarks) {
                res.multiHandLandmarks.forEach((lm, hIdx) => {
                    if(hIdx > 1) return; // Max 2 manos
                    
                    // Determinar Zona basado en la posición X de la muñeca (landmark 0) o dedo (8)
                    // MediaPipe X: 0 (Izq) -> 1 (Der).
                    const xPos = lm[8].x;
                    const isLeftZone = xPos < 0.5; // Zona Acordes
                    const isRightZone = xPos >= 0.5; // Zona Melodía

                    // Visual Update
                    [4,8,12,16,20].forEach((fid, i) => {
                        const tip = lm[fid];
                        const globalIdx = hIdx*5 + i;
                        
                        // Convertir a coordenadas 3D mundo
                        const wx = (tip.x - 0.5) * -vw * params.sensitivity;
                        const wy = (tip.y - 0.5) * -vh * params.sensitivity;
                        const wz = -tip.z * 20;

                        if (isLeftZone) {
                            // Usar nubes, esconder cintas
                            clouds[globalIdx].target.set(wx, wy, wz);
                            ribbons[globalIdx].target.set(0, -1000, 0);
                        } else {
                            // Usar cintas, esconder nubes
                            ribbons[globalIdx].target.set(wx, wy, wz);
                            clouds[globalIdx].target.set(0, -1000, 0);
                        }
                    });

                    // Audio Trigger (Solo dedo índice)
                    if (isLeftZone) {
                        hasChords = true;
                        audio.handleChords(lm[8].x, lm[8].y, true);
                    } else {
                        hasMelody = true;
                        audio.handleMelody(lm[8].x, lm[8].y, true);
                    }
                });
            }

            // Cleanup si no hay manos en las zonas
            if(!hasMelody) {
                audio.handleMelody(0,0,false);
                // Esconder ribbons inactivos
                // (Ya se maneja en el loop visual si el target está lejos)
            }
            if(!hasChords) {
                audio.handleChords(0,0,false);
            }
            
            // Si no se detectan manos en absoluto, resetear targets visuales
            if(!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) {
                clouds.forEach(c => c.target.set(0,-1000,0));
                ribbons.forEach(r => r.target.set(0,-1000,0));
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5});
        hands.onResults(onResults);
        
        const cam = new Camera(video, {onFrame: async()=>{await hands.send({image:video})}, width:1280, height:720});
        cam.start();

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now()*0.001;
            clouds.forEach(c => c.update(t));
            ribbons.forEach(r => r.update(t));
            composer.render();
        }
        animate();

        // --- UTILS ---
        window.addEventListener('resize', ()=>{
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            const fov = camera.fov * Math.PI/180;
            vh = 2 * Math.tan(fov/2) * camera.position.z; vw = vh * camera.aspect;
        });
        const fov = camera.fov * Math.PI/180; vh = 2 * Math.tan(fov/2) * camera.position.z; vw = vh * camera.aspect;

        // Controls
        window.addEventListener('keydown', e => {
            if(e.code==='Space') audio.toggleLoop();
            if(e.key.toLowerCase()==='s') audio.toggleSustain();
            if(e.key.toLowerCase()==='x') audio.clearLoop();
        });
        document.getElementById('pedal-sustain').onclick = () => audio.toggleSustain();
        document.getElementById('pedal-loop').onclick = () => audio.toggleLoop();
        document.getElementById('pedal-clear').onclick = () => audio.clearLoop();
        window.addEventListener('click', () => { if(!audio.isInit) audio.init(); if(audio.ctx.state==='suspended') audio.ctx.resume(); });

        // GUI
        const gui = new GUI({title:'Panel de Control'});
        gui.add(params, 'key', Object.keys(NOTES)).onChange(k => audio.setKey(k));
        gui.add(params, 'soundEnabled').name('Audio Master');
        gui.add(params, 'bloomStrength', 0, 3).onChange(v => bloom.strength = v);
    </script>

    <div id="loading">CARGANDO SISTEMA HÍBRIDO...</div>
    <div id="ui-layer">
        <div id="screen-divider"></div>
        <div id="label-chords" class="zone-label">ZONA ACORDES (PADS)</div>
        <div id="label-melody" class="zone-label">ZONA MELODÍA (LEAD)</div>
        <div id="hud-status">CLICK PARA ACTIVAR</div>
    </div>
    
    <div id="pedalboard">
        <div id="pedal-sustain" class="pedal">
            <div class="pedal-light"></div>
            <div class="pedal-label">Sustain</div>
            <div class="pedal-key">[ S ]</div>
        </div>
        <div id="pedal-loop" class="pedal">
            <div class="pedal-light"></div>
            <div class="pedal-label">Looper</div>
            <div class="pedal-key">[ SPACE ]</div>
        </div>
        <div id="pedal-clear" class="pedal">
            <div class="pedal-light" style="background:#555"></div>
            <div class="pedal-label">Clear</div>
            <div class="pedal-key">[ X ]</div>
        </div>
    </div>
</body>
</html>
