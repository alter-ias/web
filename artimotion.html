<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Band System (Smart Routing)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

        /* Divisor */
        #screen-divider {
            position: absolute; top: 0; bottom: 0; width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.5), transparent);
            left: 50%; transition: left 0.1s;
        }
        
        /* Etiquetas */
        .zone-label {
            position: absolute; top: 30px; 
            font-size: 14px; font-weight: 900; letter-spacing: 4px; text-transform: uppercase;
        }
        #label-left { 
            left: 25%; transform: translateX(-50%); color: #0ff; text-shadow: 0 0 20px #0ff;
        }
        #label-right { 
            right: 25%; transform: translateX(50%); color: #ffaa00; text-shadow: 0 0 20px #ffaa00;
        }

        /* Loading */
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; background: rgba(0, 10, 20, 0.95); 
            padding: 20px 40px; border: 1px solid #0ff; z-index: 20; text-align: center;
        }

        /* Pedalera */
        #pedalboard {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 10; pointer-events: auto;
        }
        .pedal {
            width: 65px; height: 90px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #333; border-radius: 6px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            padding-bottom: 12px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.8);
            transition: transform 0.1s, border-color 0.2s, box-shadow 0.2s;
        }
        .pedal.pressed { transform: scale(0.95); box-shadow: 0 2px 10px rgba(0,0,0,1); }

        .pedal-light {
            width: 10px; height: 10px; border-radius: 50%; background: #222;
            margin-bottom: 15px; box-shadow: 0 0 2px #000 inset; transition: all 0.2s;
        }
        .pedal-label { color: #666; font-size: 9px; font-weight: bold; text-transform: uppercase; text-align: center; }
        .pedal-key { color: #444; font-size: 8px; margin-top: 4px; font-family: monospace; }

        /* Estados */
        .pedal.active .pedal-light { background: #0f0; box-shadow: 0 0 10px #0f0; }
        .pedal.recording .pedal-light { background: #f00; box-shadow: 0 0 10px #f00; }
        .pedal.rhythm-on .pedal-light { background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }

        /* Menú */
        #bottom-menu {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; gap: 5px; z-index: 10; pointer-events: auto;
        }
        .mode-btn {
            background: rgba(0,0,0,0.6); color: #888; border: 1px solid #444;
            padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 10px;
        }
        .mode-btn.active { color: #0ff; border-color: #0ff; }

        .lil-gui { --background-color: rgba(5, 5, 10, 0.95); --text-color: #eee; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        const params = {
            key: 'A',
            splitPoint: 0.5,
            bloomStrength: 1.5,
            sensitivity: 2.0,
            soundEnabled: true,
            tempo: 100,
            particleSize: 1.5,
            reset: () => resetCanvas()
        };

        // --- AUDIO CONSTANTS ---
        const NOTES = { 'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88 };
        const PENTA_INTERVALS = [0, 3, 5, 7, 10]; 

        function getFrequency(baseFreq, semitones) { return baseFreq * Math.pow(2, semitones / 12); }
        function generateScale(rootKey) {
            const base = NOTES[rootKey]; 
            const scale = [];
            for (let oct = 0; oct < 3; oct++) PENTA_INTERVALS.forEach(i => scale.push(getFrequency(base * Math.pow(2, oct), i)));
            return scale;
        }
        function generateChords(rootKey) {
            const base = NOTES[rootKey] / 4;
            return [
                [getFrequency(base,0), getFrequency(base,3), getFrequency(base,7), getFrequency(base,10)], 
                [getFrequency(base,8), getFrequency(base,12), getFrequency(base,15), getFrequency(base,19)],
                [getFrequency(base,3), getFrequency(base,7), getFrequency(base,10), getFrequency(base,14)],
                [getFrequency(base,10), getFrequency(base,14), getFrequency(base,17), getFrequency(base,20)] 
            ];
        }

        let currentScale = generateScale(params.key);
        let currentChords = generateChords(params.key);

        // --- BATERÍA ---
        class DrumMachine {
            constructor(ctx, dest) {
                this.ctx = ctx; this.dest = dest;
                this.isPlaying = false; this.step = 0; this.genreIdx = 0;
                this.genres = ['ROCK', 'BLUES', 'LATIN', 'SWING'];
                this.patterns = {
                    'ROCK':  { k: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0], s: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0], h: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1] },
                    'BLUES': { k: [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0], s: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0], h: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0] },
                    'LATIN': { k: [1,0,0,1, 0,0,1,0, 0,0,1,0, 0,1,0,0], s: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0], h: [1,0,1,1, 1,0,1,0, 1,0,1,1, 1,0,1,0] },
                    'SWING': { k: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0], s: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0], h: [1,0,1,0, 0,0,1,0, 1,0,1,0, 0,0,1,0] }
                };
            }
            trigger(type) {
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.dest);
                if (type === 'kick') {
                    osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(0.01, t+0.5);
                    gain.gain.setValueAtTime(0.8, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.5);
                    osc.start(t); osc.stop(t+0.5);
                } else if (type === 'snare') {
                    const b = this.ctx.createBuffer(1, this.ctx.sampleRate*0.1, this.ctx.sampleRate);
                    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
                    const n = this.ctx.createBufferSource(); n.buffer=b;
                    const f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=1000;
                    n.connect(f); f.connect(gain); gain.connect(this.dest);
                    gain.gain.setValueAtTime(0.5, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.1); n.start(t);
                } else {
                    const b = this.ctx.createBuffer(1, this.ctx.sampleRate*0.05, this.ctx.sampleRate);
                    const d = b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
                    const n = this.ctx.createBufferSource(); n.buffer=b;
                    const f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5000;
                    n.connect(f); f.connect(gain); gain.connect(this.dest);
                    gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.05); n.start(t);
                }
            }
            nextGenre() {
                this.genreIdx = (this.genreIdx + 1) % (this.genres.length + 1);
                if(this.genreIdx === 0) { this.stop(); return 'OFF'; }
                if(!this.isPlaying) this.start(); return this.genres[this.genreIdx - 1];
            }
            start() { if(this.isPlaying) return; this.isPlaying=true; this.step=0; this.schedule(); }
            stop() { this.isPlaying=false; clearTimeout(this.timerID); }
            schedule() {
                if(!this.isPlaying) return;
                const stepTime = (60.0 / params.tempo) / 4;
                const pat = this.patterns[this.genres[this.genreIdx - 1]];
                if(pat) {
                    if(pat.k[this.step]) this.trigger('kick');
                    if(pat.s[this.step]) this.trigger('snare');
                    if(pat.h[this.step]) this.trigger('hat');
                }
                this.step = (this.step + 1) % 16;
                this.timerID = setTimeout(() => this.schedule(), stepTime * 1000);
            }
        }

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.isInit=false; this.drums=null;
                this.recorder=null; this.chunks=[]; this.loopBuffer=null; this.loopSource=null; this.loopState='IDLE';
                this.sustain=false; this.lastChordIdx=-1;
                this.melOsc=null; this.melGain=null; this.chordOscs=[]; this.chordGain=null;
                this.chordFilter = null;
                this.instBus = null; // NUEVO: Bus solo para instrumentos
            }
            init() {
                if(this.isInit) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                
                // 1. Master Gain (Salida General)
                this.master = this.ctx.createGain(); 
                this.master.gain.value = 0.8; 
                this.master.connect(this.ctx.destination);

                // 2. Bus de Instrumentos (Para grabar solo música, sin batería)
                this.instBus = this.ctx.createGain();
                this.instBus.connect(this.master); // Escuchamos los instrumentos

                // 3. Looper Destination (Graba del Bus de Instrumentos)
                this.loopDest = this.ctx.createMediaStreamDestination();
                this.instBus.connect(this.loopDest);
                
                // 4. Batería (Va directo al Master, salta la grabación)
                this.drums = new DrumMachine(this.ctx, this.master);

                // --- MELODÍA (Al Bus de Instrumentos) ---
                this.melOsc = this.ctx.createOscillator(); this.melOsc.type = 'triangle';
                this.melGain = this.ctx.createGain(); this.melGain.gain.value = 0;
                const d = this.ctx.createDelay(); d.delayTime.value=0.25;
                const df = this.ctx.createGain(); df.gain.value=0.4;
                
                this.melOsc.connect(this.melGain); 
                this.melGain.connect(this.instBus); // -> InstBus
                this.melGain.connect(d); d.connect(df); df.connect(d); 
                d.connect(this.instBus); // -> InstBus
                this.melOsc.start();

                // --- ACORDES (Al Bus de Instrumentos) ---
                this.chordGain = this.ctx.createGain(); 
                this.chordGain.gain.value = 0;
                
                this.chordFilter = this.ctx.createBiquadFilter(); 
                this.chordFilter.type='lowpass'; 
                this.chordFilter.frequency.value=600;
                
                this.chordGain.connect(this.chordFilter); 
                this.chordFilter.connect(this.instBus); // -> InstBus

                const lfo = this.ctx.createOscillator(); lfo.frequency.value = 0.2;
                const lfoGain = this.ctx.createGain(); lfoGain.gain.value = 300;
                lfo.connect(lfoGain); lfoGain.connect(this.chordFilter.frequency); lfo.start();

                for(let i=0;i<4;i++) {
                    const o = this.ctx.createOscillator(); 
                    o.type='sawtooth'; 
                    o.detune.value=(Math.random()-0.5)*12; 
                    o.connect(this.chordGain); 
                    o.start(); 
                    this.chordOscs.push(o);
                }
                this.isInit = true;
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('hud-status').innerText = "AUDIO ACTIVO - TOCAR PARA INICIAR";
            }
            setKey(k) { params.key=k; currentScale=generateScale(k); currentChords=generateChords(k); }
            
            handleMelody(x, y, active) {
                if(!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                if(active) {
                    const idx = Math.floor(x * currentScale.length);
                    const safeIdx = Math.min(Math.max(idx, 0), currentScale.length - 1);
                    this.melOsc.frequency.setTargetAtTime(currentScale[safeIdx], t, 0.05);
                    this.melGain.gain.setTargetAtTime(Math.max(0, (1-y)*0.4), t, 0.1);
                } else { this.melGain.gain.setTargetAtTime(0, t, 0.1); }
            }
            
            handleChords(x, y, active) {
                if(!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                if(active) {
                    let cIdx = Math.floor(x * 4); if(cIdx>3) cIdx=3; if(cIdx<0) cIdx=0;
                    if(cIdx !== this.lastChordIdx || this.chordGain.gain.value < 0.01) {
                        const chord = currentChords[cIdx];
                        this.chordOscs.forEach((o, i) => { if(chord[i]) o.frequency.setTargetAtTime(chord[i], t, 0.15); });
                        this.lastChordIdx = cIdx;
                    }
                    const targetVol = Math.max(0, (1.0 - y) * 0.35);
                    this.chordGain.gain.setTargetAtTime(targetVol, t, 0.3);
                    this.chordFilter.frequency.setTargetAtTime(500 + (1-y)*1500, t, 0.2); 
                } else {
                    if(!this.sustain) this.chordGain.gain.setTargetAtTime(0, t, 0.8);
                    else if(this.chordGain.gain.value < 0.2) this.chordGain.gain.setTargetAtTime(0.2, t, 0.5);
                }
            }
            
            toggleSustain() {
                this.sustain = !this.sustain;
                const p = document.getElementById('pedal-sustain');
                if(this.sustain) p.classList.add('active'); else p.classList.remove('active');
                if(!this.sustain) this.chordGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            }
            cycleRhythm() {
                if(!this.isInit) return;
                const genre = this.drums.nextGenre();
                const p = document.getElementById('pedal-rhythm');
                const l = document.getElementById('label-rhythm');
                if(genre==='OFF') { p.classList.remove('rhythm-on'); l.innerText='RHYTHM'; }
                else { p.classList.add('rhythm-on'); l.innerText=genre; }
            }
            toggleLoop() {
                if(!this.isInit) return;
                const p = document.getElementById('pedal-loop');
                if(this.loopState === 'IDLE' || this.loopState === 'PLAYING') {
                    this.chunks = []; if(this.loopSource) { this.loopSource.stop(); this.loopSource = null; }
                    this.recorder = new MediaRecorder(this.loopDest.stream); // GRABA DEL BUS DE INSTRUMENTOS
                    this.recorder.ondataavailable = e => this.chunks.push(e.data);
                    this.recorder.start();
                    this.loopState = 'RECORDING'; p.classList.add('recording'); p.classList.remove('active');
                } else {
                    this.recorder.stop();
                    this.recorder.onstop = async () => {
                        const b = new Blob(this.chunks, {'type':'audio/ogg; codecs=opus'});
                        this.loopBuffer = await this.ctx.decodeAudioData(await b.arrayBuffer());
                        this.playLoop();
                    };
                    p.classList.remove('recording'); p.classList.add('active');
                }
            }
            playLoop() {
                if(!this.loopBuffer) return;
                this.loopSource = this.ctx.createBufferSource();
                this.loopSource.buffer = this.loopBuffer;
                this.loopSource.loop = true;
                this.loopSource.connect(this.master); // Reproduce al master
                this.loopSource.start();
                this.loopState = 'PLAYING';
            }
            clearLoop() {
                if(this.loopSource) { this.loopSource.stop(); this.loopSource = null; }
                this.loopState = 'IDLE';
                const p = document.getElementById('pedal-loop');
                p.classList.remove('active'); p.classList.remove('recording');
            }
        }
        const audio = new AudioEngine();

        // --- VISUALES ---
        const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.z = 12;
        const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
        
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        function createTex() {
            const c=document.createElement('canvas'); c.width=32;c.height=32; const x=c.getContext('2d');
            const g=x.createRadialGradient(16,16,0,16,16,16); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)');
            x.fillStyle=g; x.fillRect(0,0,32,32); return new THREE.CanvasTexture(c);
        }
        const particleTex = createTex();

        class SmokeEmitter {
            constructor(idx) {
                this.idx = idx; this.target = new THREE.Vector3(0,-1000,0); this.lastPos = new THREE.Vector3(0,-1000,0);
                this.colorVal = new THREE.Color(0x00ffff);
                this.max=50;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(this.max*3);
                const size = new Float32Array(this.max);
                const col = new Float32Array(this.max*3);
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('size', new THREE.BufferAttribute(size, 1));
                geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
                this.mat = new THREE.PointsMaterial({ size:1, map:particleTex, transparent:true, vertexColors:true, blending:THREE.AdditiveBlending, depthWrite:false });
                this.mesh = new THREE.Points(geo, this.mat);
                scene.add(this.mesh);
                this.parts = Array(this.max).fill().map(()=>({p: new THREE.Vector3(0,-1000,0),v: new THREE.Vector3(),l: 0,c: new THREE.Color()}));
            }
            setTarget(x, y, z, colorHex) { this.target.set(x, y, z); this.colorVal.setHex(colorHex); }
            update(t) {
                const cur = new THREE.Vector3().lerpVectors(this.lastPos, this.target, 0.3);
                const dist = this.target.distanceTo(this.lastPos);
                if(dist > 0.01 || Math.random() < 0.2) {
                    const p = this.parts.find(x => x.l <= 0);
                    if(p) {
                        p.l = 1.0; p.p.copy(cur);
                        p.p.x += (Math.random()-0.5)*0.5; p.p.y += (Math.random()-0.5)*0.5;
                        p.v.set((Math.random()-0.5)*0.1, 0.05, (Math.random()-0.5)*0.1);
                        p.c.copy(this.colorVal);
                    }
                }
                this.lastPos.copy(cur);
                const pos = this.mesh.geometry.attributes.position.array;
                const size = this.mesh.geometry.attributes.size.array;
                const col = this.mesh.geometry.attributes.color.array;
                this.parts.forEach((p, i) => {
                    if(p.l > 0) {
                        p.l -= 0.02; p.p.add(p.v);
                        pos[i*3] = p.p.x; pos[i*3+1] = p.p.y; pos[i*3+2] = p.p.z;
                        size[i] = params.particleSize * 3 * Math.sin(p.l * Math.PI);
                        col[i*3] = p.c.r; col[i*3+1] = p.c.g; col[i*3+2] = p.c.b;
                    } else { size[i] = 0; }
                });
                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.geometry.attributes.size.needsUpdate = true;
                this.mesh.geometry.attributes.color.needsUpdate = true;
            }
        }

        const emitters = Array(10).fill().map((_,i) => new SmokeEmitter(i));
        function resetCanvas() { emitters.forEach(e => e.target.set(0,-1000,0)); }

        // --- MEDIAPIPE ---
        const videoElement = document.createElement('video');
        const fingerIndices = [4, 8, 12, 16, 20];
        let vw=10, vh=10;

        function onResults(results) {
            let melActive=false, chordActive=false;
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, hIdx) => {
                    if(hIdx > 1) return;
                    const rawX = landmarks[8].x;
                    const threshold = 1.0 - params.splitPoint;
                    const isVisualLeft = rawX > threshold; 

                    fingerIndices.forEach((fid, i) => {
                        const lm = landmarks[fid];
                        const x = (lm.x - 0.5) * -vw * params.sensitivity;
                        const y = (lm.y - 0.5) * -vh * params.sensitivity;
                        const z = -lm.z * 20;
                        const color = isVisualLeft ? 0x00ffff : 0xffaa00;
                        emitters[hIdx*5+i].setTarget(x, y, z, color);
                    });

                    if (isVisualLeft) {
                        chordActive = true;
                        const norm = (rawX - threshold) / (1.0 - threshold);
                        audio.handleChords(1.0 - norm, landmarks[8].y, true);
                    } else {
                        melActive = true;
                        const norm = (threshold - rawX) / threshold;
                        audio.handleMelody(norm, landmarks[8].y, true);
                    }
                });
            }
            if(!melActive) audio.handleMelody(0,0,false);
            if(!chordActive) audio.handleChords(0,0,false);
        }

        const hands = new Hands({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.5});
        hands.onResults(onResults);
        const cam = new Camera(videoElement, {onFrame:async()=>{await hands.send({image:videoElement})}, width:1280, height:720});
        cam.start();

        // --- UTILS & UI ---
        function resize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            const fov = camera.fov * Math.PI/180;
            vh = 2 * Math.tan(fov/2) * camera.position.z; vw = vh * camera.aspect;
        }
        window.addEventListener('resize', resize); resize();

        function updateDivider() {
            const p = params.splitPoint * 100;
            document.getElementById('screen-divider').style.left = p + '%';
            document.getElementById('label-left').style.left = (p/2) + '%';
            document.getElementById('label-right').style.right = ((100-p)/2) + '%';
        }

        function animatePedal(id) {
            const p = document.getElementById(id);
            p.classList.add('pressed');
            setTimeout(() => p.classList.remove('pressed'), 150);
        }

        window.addEventListener('keydown', e => {
            if(!audio.isInit) { audio.init(); if(audio.ctx) audio.ctx.resume(); }
            switch(e.code) {
                case 'Space': 
                    e.preventDefault(); audio.toggleLoop(); animatePedal('pedal-loop'); break;
                case 'KeyS': 
                    audio.toggleSustain(); animatePedal('pedal-sustain'); break;
                case 'KeyX': 
                    audio.clearLoop(); animatePedal('pedal-clear'); break;
                case 'KeyD': 
                    audio.cycleRhythm(); animatePedal('pedal-rhythm'); break;
                case 'KeyR': 
                    resetCanvas(); break;
            }
        });

        window.addEventListener('click', () => { 
            if(!audio.isInit) audio.init(); 
            if(audio.ctx && audio.ctx.state==='suspended') audio.ctx.resume(); 
        });

        document.getElementById('pedal-sustain').onclick = () => { audio.toggleSustain(); animatePedal('pedal-sustain'); };
        document.getElementById('pedal-loop').onclick = () => { audio.toggleLoop(); animatePedal('pedal-loop'); };
        document.getElementById('pedal-clear').onclick = () => { audio.clearLoop(); animatePedal('pedal-clear'); };
        document.getElementById('pedal-rhythm').onclick = () => { audio.cycleRhythm(); animatePedal('pedal-rhythm'); };

        const bgGroup = new THREE.Group(); scene.add(bgGroup);
        let gridHelper, starField;
        function initBackgrounds() {
            gridHelper = new THREE.GridHelper(100, 40, 0x00ffff, 0x222222); gridHelper.position.y = -10; gridHelper.visible = false; bgGroup.add(gridHelper);
            gridHelper.add(gridHelper.clone().translateY(20));
            const starGeo = new THREE.BufferGeometry();
            const pos = new Float32Array(2000*3); for(let i=0;i<2000*3;i++) pos[i]=(Math.random()-0.5)*100;
            starGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
            starField = new THREE.Points(starGeo, new THREE.PointsMaterial({size:0.2, color:0xffffff, transparent:true, opacity:0.8}));
            starField.visible = false; bgGroup.add(starField);
        }
        initBackgrounds();

        document.getElementById('btn-void').onclick = () => { gridHelper.visible=false; starField.visible=false; };
        document.getElementById('btn-grid').onclick = () => { gridHelper.visible=true; starField.visible=false; };
        document.getElementById('btn-warp').onclick = () => { gridHelper.visible=false; starField.visible=true; };

        const gui = new GUI({title:'CONTROL PANEL'});
        gui.add(params, 'splitPoint', 0.2, 0.8).onChange(updateDivider);
        gui.add(params, 'tempo', 60, 200).name('BPM');
        gui.add(params, 'key', Object.keys(NOTES)).onChange(k=>audio.setKey(k));
        gui.add(params, 'particleSize', 0.5, 3.0);

        function animate() {
            requestAnimationFrame(animate);
            const t = performance.now()*0.001;
            emitters.forEach(e => e.update(t));
            if(gridHelper.visible) gridHelper.position.z = (t*2)%10;
            if(starField.visible) starField.rotation.z = t*0.1;
            composer.render();
        }
        animate();
    </script>

    <div id="loading">SISTEMA CORRECTO CARGADO<br>Audio ruteado y Pads enriquecidos</div>
    
    <div id="ui-layer">
        <div id="screen-divider"></div>
        <div id="label-left" class="zone-label">PADS (CYAN)</div>
        <div id="label-right" class="zone-label">LEAD (GOLD)</div>
        <div id="hud-status" style="position:absolute; top:60px; width:100%; text-align:center; color:#888; font-family:monospace; font-size:10px;">
            [ESPACIO]=Grabar Loop | [S]=Sustain | [D]=Ritmos
        </div>
    </div>

    <div id="pedalboard">
        <div id="pedal-sustain" class="pedal">
            <div class="pedal-light"></div>
            <div class="pedal-label">Sustain</div>
            <div class="pedal-key">[ S ]</div>
        </div>
        <div id="pedal-loop" class="pedal">
            <div class="pedal-light"></div>
            <div class="pedal-label">Looper</div>
            <div class="pedal-key">[ ESPACIO ]</div>
        </div>
        <div id="pedal-clear" class="pedal">
            <div class="pedal-light" style="background:#555"></div>
            <div class="pedal-label">Clear</div>
            <div class="pedal-key">[ X ]</div>
        </div>
        <div id="pedal-rhythm" class="pedal">
            <div class="pedal-light"></div>
            <div id="label-rhythm" class="pedal-label">RHYTHM</div>
            <div class="pedal-key">[ D ]</div>
        </div>
    </div>

    <div id="bottom-menu">
        <div id="btn-void" class="mode-btn active">Void</div>
        <div id="btn-grid" class="mode-btn">Grid</div>
        <div id="btn-warp" class="mode-btn">Warp</div>
    </div>
</body>
</html>
