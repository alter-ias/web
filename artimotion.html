<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Level 4: Organic Ribbons</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; }
        canvas { display: block; }
        #loading { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #fff; font-family: sans-serif; font-size: 14px; 
            background: rgba(0,0,0,0.8); padding: 15px 30px; border-radius: 30px;
            border: 1px solid #444; pointer-events: none;
        }
        /* Estilo para el panel de control */
        .lil-gui { --background-color: rgba(10, 10, 10, 0.9); --text-color: #eee; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- PARÁMETROS GLOBALES (CONTROLABLES) ---
        const params = {
            lineWidth: 0.6,
            trailLength: 40,
            bloomStrength: 1.5,
            bloomRadius: 0.6,
            relaxation: 0.2, // Qué tan rápido sigue al dedo (menor = más 'gomoso')
            colorSpeed: 1.0,
            opacity: 0.8,
            mode: 'Spectral' // Preset de color
        };

        // --- 1. SETUP ESCENA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 12;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- 2. POST-PROCESAMIENTO ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;
        composer.addPass(bloomPass);

        // --- 3. CLASE: RIBBON TRAIL (LA CINTA ORGÁNICA) ---
        // Genera una malla (Mesh) en lugar de una línea, permitiendo grosor real.
        class RibbonTrail {
            constructor(idx) {
                this.idx = idx;
                this.length = 50; // Capacidad máxima del buffer
                this.points = []; // Puntos de control para el spline
                
                // Inicializar puntos fuera de pantalla
                for(let i=0; i<this.length; i++) {
                    this.points.push(new THREE.Vector3(0,-100,0));
                }

                // Geometría: Una tira de triángulos (Triangle Strip)
                // Cada segmento del trail necesita 2 vértices (izquierda y derecha)
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.length * 2 * 3); // 2 verts por punto * 3 coords (xyz)
                const uvs = new Float32Array(this.length * 2 * 2);
                
                // Generar UVs para texturizado/gradientes
                for(let i=0; i<this.length; i++) {
                    const u = i / (this.length - 1);
                    uvs[i*4 + 0] = u; uvs[i*4 + 1] = 0; // Vertice abajo
                    uvs[i*4 + 2] = u; uvs[i*4 + 3] = 1; // Vertice arriba
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

                // Indices para formar triángulos
                const indices = [];
                for(let i=0; i < this.length - 1; i++) {
                    const v = i * 2;
                    indices.push(v, v+1, v+2);
                    indices.push(v+2, v+1, v+3);
                }
                geometry.setIndex(indices);
                geometry.attributes.position.dynamic = true;

                // Material Shader simple para colores suaves
                this.material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: params.opacity,
                    blending: THREE.AdditiveBlending,
                    depthTest: false // Para que se vean unos sobre otros sin cortes feos
                });

                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.frustumCulled = false; // Siempre dibujar
                scene.add(this.mesh);

                this.target = new THREE.Vector3(0,-100,0);
                this.current = new THREE.Vector3(0,-100,0);
            }

            update(x, y, z, time) {
                // 1. Física suave (Lerp)
                this.target.set(x, y, z);
                this.current.lerp(this.target, params.relaxation);

                // 2. Gestión del historial (Cola)
                // En lugar de shift/push (que es lento para arrays grandes), usamos un ciclo
                // pero por simplicidad de lectura usaremos shift/push en el array de control
                this.points.shift();
                this.points.push(this.current.clone());

                // 3. Generar la curva suave (Spline)
                const curve = new THREE.CatmullRomCurve3(this.points, false, 'catmullrom', 0.5);
                // Tomamos menos puntos para la geometría que para el historial si queremos optimizar,
                // pero aquí mapeamos 1 a 1 para suavidad máxima.
                const splinePoints = curve.getPoints(this.length - 1);

                // 4. Construir la cinta (Expandir vértices)
                const pos = this.mesh.geometry.attributes.position.array;
                const widthBase = params.lineWidth;

                for(let i=0; i < splinePoints.length; i++) {
                    let p = splinePoints[i];
                    let nextP = splinePoints[Math.min(i+1, splinePoints.length-1)];
                    
                    // Calculamos la dirección del segmento
                    let dir = new THREE.Vector3().subVectors(nextP, p).normalize();
                    // Vector "Derecha" relativo a la cámara (Cross product con eje Z)
                    // Esto hace que la cinta siempre mire a la cámara (Billboarding)
                    let right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,0,1)).normalize();

                    // Grosor variable: Delgado al final (cola), grueso al inicio (cabeza)
                    // i=0 es la cola (viejo), i=length es la cabeza (nuevo)
                    let scale = (i / this.length); 
                    // Función de forma: Tapering
                    scale = Math.pow(scale, 0.5); // Raíz cuadrada hace que se mantenga grueso más tiempo
                    
                    let w = widthBase * scale;

                    // Vertice 1 (Izquierda)
                    pos[i*6 + 0] = p.x - right.x * w;
                    pos[i*6 + 1] = p.y - right.y * w;
                    pos[i*6 + 2] = p.z;

                    // Vertice 2 (Derecha)
                    pos[i*6 + 3] = p.x + right.x * w;
                    pos[i*6 + 4] = p.y + right.y * w;
                    pos[i*6 + 5] = p.z;
                }
                
                this.mesh.geometry.attributes.position.needsUpdate = true;

                // 5. Color Dinámico
                let hue = 0;
                if(params.mode === 'Spectral') hue = (time * params.colorSpeed * 0.1 + (this.idx * 0.05)) % 1;
                if(params.mode === 'Fire') hue = (0.0 + (Math.sin(time + this.idx)*0.05)) % 1; // Rojo/Naranja
                if(params.mode === 'Ocean') hue = (0.6 + (Math.sin(time + this.idx)*0.1)) % 1; // Azules

                this.material.color.setHSL(hue, 1.0, 0.5);
                this.material.opacity = params.opacity;
            }
        }

        // --- 4. INICIALIZACIÓN ---
        const trails = [];
        for(let i=0; i<10; i++) trails.push(new RibbonTrail(i));

        // --- 5. MEDIAPIPE ---
        const videoElement = document.createElement('video');
        const fingerIndices = [4, 8, 12, 16, 20];

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            const time = performance.now();

            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((landmarks, handIndex) => {
                    if (handIndex > 1) return;
                    
                    fingerIndices.forEach((fingerIdx, i) => {
                        const lm = landmarks[fingerIdx];
                        // Mapeo más amplio
                        const x = (lm.x - 0.5) * -18; 
                        const y = (lm.y - 0.5) * -12;
                        const z = -lm.z * 15;
                        
                        const globalIdx = (handIndex * 5) + i;
                        trails[globalIdx].update(x, y, z, time);
                    });
                });
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        // --- 6. GUI (PANEL DE CONTROL) ---
        const gui = new GUI({ title: 'Control Panel' });
        
        const folderVisuals = gui.addFolder('Visuals');
        folderVisuals.add(params, 'lineWidth', 0.1, 2.0).name('Grosor Línea');
        folderVisuals.add(params, 'opacity', 0.1, 1.0).name('Opacidad');
        folderVisuals.add(params, 'bloomStrength', 0.0, 3.0).onChange(v => bloomPass.strength = v).name('Brillo (Glow)');
        folderVisuals.add(params, 'bloomRadius', 0.0, 1.5).onChange(v => bloomPass.radius = v).name('Difusión');
        
        const folderPhysics = gui.addFolder('Physics');
        folderPhysics.add(params, 'relaxation', 0.01, 0.5).name('Fluidez (Lag)');
        
        const folderColors = gui.addFolder('Colors');
        folderColors.add(params, 'mode', ['Spectral', 'Fire', 'Ocean']).name('Paleta');
        folderColors.add(params, 'colorSpeed', 0.0, 5.0).name('Velocidad Color');

        // --- 7. ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            // Sutil movimiento de cámara
            camera.position.x = Math.sin(performance.now() * 0.0005) * 0.5;
            camera.position.y = Math.cos(performance.now() * 0.0005) * 0.5;
            camera.lookAt(0,0,0);
            
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <div id="loading">CARGANDO MOTOR GRÁFICO...</div>
</body>
</html>
