<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Hand Tracking Visuals</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        video { display: none; }
        canvas { display: block; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: monospace; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // NOTA: Ya no importamos Hands ni Camera aquí porque ya las cargamos arriba como scripts globales.

        // --- CONFIGURACIÓN THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 2.0;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- OBJETOS VISUALES ---
        const jointGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const jointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const joints = [];
        
        for(let i=0; i<42; i++) {
            const sphere = new THREE.Mesh(jointGeometry, jointMaterial);
            scene.add(sphere);
            joints.push(sphere);
            sphere.visible = false;
        }

        // Estelas (Trails)
        const TRAIL_LENGTH = 30;
        const trailGeometries = [];
        const trails = [];
        const fingerTips = [4, 8, 12, 16, 20, 25, 29, 33, 37, 41]; 
        
        for (let i = 0; i < fingerTips.length; i++) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(TRAIL_LENGTH * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const color = new THREE.Color();
            color.setHSL(i / fingerTips.length, 1.0, 0.5);
            
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                opacity: 0.8, 
                transparent: true,
                linewidth: 2 
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            trails.push({
                mesh: line,
                positions: [],
                targetIndex: -1
            });
            trailGeometries.push(geometry);
        }

        // --- LÓGICA DE MEDIAPIPE ---
        const videoElement = document.createElement('video');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            joints.forEach(j => j.visible = false);

            if (results.multiHandLandmarks) {
                let handIndex = 0;
                for (const landmarks of results.multiHandLandmarks) {
                    for (let i = 0; i < landmarks.length; i++) {
                        const idx = handIndex * 21 + i;
                        if (idx >= joints.length) break;

                        const joint = joints[idx];
                        const x = (landmarks[i].x - 0.5) * -10;
                        const y = (landmarks[i].y - 0.5) * -6; 
                        const z = -landmarks[i].z * 10;

                        joint.position.set(x, y, z);
                        joint.visible = true;

                        if ([4,8,12,16,20].includes(i)) {
                            const trailIdx = (handIndex * 5) + ([4,8,12,16,20].indexOf(i));
                            updateTrail(trailIdx, x, y, z);
                        }
                    }
                    handIndex++;
                }
            }
        }

        function updateTrail(index, x, y, z) {
            if(index >= trails.length) return;
            const trail = trails[index];
            trail.positions.push({x, y, z});
            if (trail.positions.length > TRAIL_LENGTH) trail.positions.shift();

            const positions = trail.mesh.geometry.attributes.position.array;
            let posIdx = 0;
            
            for (let i = 0; i < trail.positions.length; i++) {
                positions[posIdx++] = trail.positions[i].x;
                positions[posIdx++] = trail.positions[i].y;
                positions[posIdx++] = trail.positions[i].z;
            }
            
            const lastPos = trail.positions[trail.positions.length - 1];
            if(lastPos){
                while (posIdx < positions.length) {
                    positions[posIdx++] = lastPos.x;
                    positions[posIdx++] = lastPos.y;
                    positions[posIdx++] = lastPos.z;
                }
            }
            trail.mesh.geometry.attributes.position.needsUpdate = true;
        }

        // Inicializamos Hands (ahora es una variable global gracias a los scripts de arriba)
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Inicializamos Camera (también global)
        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        cameraFeed.start();

        function animate() {
            requestAnimationFrame(animate);
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
    <div id="loading">Cargando modelo de IA... (Acepta los permisos de cámara)</div>
</body>
</html>
