<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - External Audio Reactive</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; letter-spacing: 2px;
            background: rgba(0, 10, 20, 0.9); padding: 20px 40px; border-radius: 4px;
            border: 1px solid #0ff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            pointer-events: none; z-index: 10;
            text-align: center;
        }

        #bottom-menu {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 5;
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .mode-btn {
            background: rgba(20, 20, 20, 0.8); color: #888; border: 1px solid #444;
            padding: 10px 20px; border-radius: 8px; cursor: pointer;
            font-weight: bold; text-transform: uppercase; font-size: 12px;
            transition: all 0.3s ease;
            min-width: 80px; text-align: center;
        }

        .mode-btn:hover { background: #333; color: #fff; border-color: #fff; }
        .mode-btn.active { background: #0ff; color: #000; border-color: #0ff; box-shadow: 0 0 15px #0ff; }
        
        /* Botón de reacción activo */
        .mode-btn.react-active { background: #ff0055; color: #fff; border-color: #ff0055; box-shadow: 0 0 20px #ff0055; }
        
        #audio-hint {
            position: absolute; top: 20px; right: 20px; 
            color: rgba(255,255,255,0.5); font-size: 10px; z-index: 5;
            text-align: right;
            line-height: 1.5;
        }

        .lil-gui { --background-color: rgba(5, 5, 10, 0.9); --text-color: #ddd; --title-background-color: #111; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- PARÁMETROS ---
        const params = {
            key: 'A', 
            trailStyle: 'Ribbon', 
            lineWidth: 0.8,
            bloomStrength: 1.5,
            bloomRadius: 0.5,
            relaxation: 0.15,
            colorSpeed: 1.5,
            opacity: 0.85,
            particleSize: 1.0, 
            mode: 'Spectral',
            inputSensitivity: 1.5,
            soundEnabled: true,
            audioReact: false, 
            audioSource: 'Internal', // 'Internal' o 'Microphone'
            micGain: 3.0, // Amplificación extra para el micrófono
            reset: () => resetCanvas()
        };

        // --- TEORÍA MUSICAL ---
        const NOTES = { 'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88 };
        const PENTA_INTERVALS = [0, 3, 5, 7, 10];

        function getFrequency(baseFreq, semitones) { return baseFreq * Math.pow(2, semitones / 12); }

        function generateScale(rootKey) {
            const base = NOTES[rootKey] / 2; 
            const scale = [];
            for (let oct = 0; oct < 3; oct++) {
                PENTA_INTERVALS.forEach(interval => scale.push(getFrequency(base * Math.pow(2, oct), interval)));
            }
            return scale;
        }

        function generateChords(rootKey) {
            const base = NOTES[rootKey] / 4; 
            return [
                [getFrequency(base, 0), getFrequency(base, 3), getFrequency(base, 7)],
                [getFrequency(base, 8), getFrequency(base, 12), getFrequency(base, 15)],
                [getFrequency(base, 10), getFrequency(base, 14), getFrequency(base, 17)]
            ];
        }

        let currentScale = generateScale(params.key);
        let currentChords = generateChords(params.key);

        // --- MOTOR DE AUDIO & MICRÓFONO ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                
                // Internal Synth Nodes
                this.melodyOsc = null;
                this.chordOscs = []; 
                this.gainMelody = null;
                this.gainChord = null;
                this.masterGain = null;
                this.synthAnalyser = null;
                this.synthDataArray = null;

                // Microphone Nodes
                this.micStream = null;
                this.micSource = null;
                this.micAnalyser = null;
                this.micDataArray = null;
                this.isMicActive = false;

                this.isInit = false;
            }

            init() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                // 1. SETUP SINTETIZADOR INTERNO
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;
                
                this.synthAnalyser = this.ctx.createAnalyser();
                this.synthAnalyser.fftSize = 256;
                this.synthDataArray = new Uint8Array(this.synthAnalyser.frequencyBinCount);

                this.masterGain.connect(this.synthAnalyser);
                this.synthAnalyser.connect(this.ctx.destination);

                // Canal Melodía
                this.melodyOsc = this.ctx.createOscillator();
                this.melodyOsc.type = 'triangle';
                this.gainMelody = this.ctx.createGain();
                this.gainMelody.gain.value = 0;
                
                const delay = this.ctx.createDelay(); delay.delayTime.value = 0.25;
                const delayGain = this.ctx.createGain(); delayGain.gain.value = 0.3;
                
                this.melodyOsc.connect(this.gainMelody);
                this.gainMelody.connect(this.masterGain);
                this.gainMelody.connect(delay);
                delay.connect(delayGain); delayGain.connect(delay); delay.connect(this.masterGain);
                this.melodyOsc.start();

                // Canal Acordes
                this.gainChord = this.ctx.createGain();
                this.gainChord.gain.value = 0;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
                this.gainChord.connect(filter); filter.connect(this.masterGain);

                for(let i=0; i<3; i++) {
                    const osc = this.ctx.createOscillator(); osc.type = 'sine';
                    osc.connect(this.gainChord); osc.start();
                    this.chordOscs.push(osc);
                }

                this.isInit = true;
                this.updateUI();
            }

            async enableMicrophone() {
                if (this.isMicActive) return;
                try {
                    // Pedir permiso al navegador
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    this.micStream = stream;
                    
                    // Crear fuente y analizador
                    this.micSource = this.ctx.createMediaStreamSource(stream);
                    this.micAnalyser = this.ctx.createAnalyser();
                    this.micAnalyser.fftSize = 256;
                    this.micDataArray = new Uint8Array(this.micAnalyser.frequencyBinCount);

                    // IMPORTANTE: Conectar Mic -> Analyser. 
                    // NO CONECTAR A DESTINATION (Speakers) para evitar feedback.
                    this.micSource.connect(this.micAnalyser);
                    
                    this.isMicActive = true;
                    console.log("Micrófono activado correctamente");
                } catch (err) {
                    console.error("Error al acceder al micrófono:", err);
                    alert("No se pudo acceder al micrófono. Verifica los permisos.");
                    params.audioSource = 'Internal'; // Revertir a interno
                }
            }

            stopMicrophone() {
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => track.stop());
                    this.isMicActive = false;
                }
            }

            // Obtener volumen según la fuente seleccionada
            getVolume() {
                if (!this.isInit) return 0;

                let array, analyser;
                let multiplier = 1.0;

                if (params.audioSource === 'Microphone' && this.isMicActive) {
                    array = this.micDataArray;
                    analyser = this.micAnalyser;
                    multiplier = params.micGain; // El mic suele necesitar boost
                } else {
                    array = this.synthDataArray;
                    analyser = this.synthAnalyser;
                }

                if (!analyser) return 0;

                analyser.getByteFrequencyData(array);
                let sum = 0;
                for (let i = 0; i < array.length; i++) sum += array[i];
                const average = sum / array.length;
                
                // Normalizar y aplicar multiplicador, clampear a 1.0 máx para evitar explosión visual
                return Math.min((average / 255) * multiplier, 1.0); 
            }

            updateUI() {
                const src = params.audioSource === 'Microphone' ? 'MICRÓFONO (Externo)' : 'SINTETIZADOR (Manos)';
                document.getElementById('audio-hint').innerHTML = `AUDIO: ACTIVO<br>Fuente: ${src}<br>Tonalidad: ${params.key} Menor`;
            }

            setKey(newKey) {
                currentScale = generateScale(newKey);
                currentChords = generateChords(newKey);
                this.updateUI();
            }

            updateMelody(normX, normY, active) {
                if (!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                if (active) {
                    const index = Math.floor(normX * currentScale.length);
                    const safeIndex = Math.min(Math.max(index, 0), currentScale.length - 1);
                    this.melodyOsc.frequency.setTargetAtTime(currentScale[safeIndex], t, 0.05);
                    this.gainMelody.gain.setTargetAtTime(Math.max(0, (1.0 - normY) * 0.2), t, 0.1);
                } else {
                    this.gainMelody.gain.setTargetAtTime(0, t, 0.2);
                }
            }

            updateChords(normX, normY, active) {
                if (!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                if (active) {
                    let idx = normX < 0.33 ? 0 : (normX < 0.66 ? 1 : 2);
                    const targetChord = currentChords[idx];
                    this.chordOscs.forEach((osc, i) => osc.frequency.setTargetAtTime(targetChord[i], t, 0.1));
                    this.gainChord.gain.setTargetAtTime(Math.max(0, (1.0 - normY) * 0.25), t, 0.2);
                } else {
                    this.gainChord.gain.setTargetAtTime(0, t, 0.5);
                }
            }
        }
        
        const audioSys = new AudioEngine();

        // --- VISUALES (Simplificado para integración) ---
        function createSoftTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createSoftTexture();

        const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.z = 12;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        // Fondos
        const bgGroup = new THREE.Group(); scene.add(bgGroup);
        let gridHelper, starField;
        gridHelper = new THREE.GridHelper(100, 40, 0x00ffff, 0x222222); gridHelper.position.y = -10; gridHelper.visible = false; bgGroup.add(gridHelper);
        const gridTop = gridHelper.clone(); gridTop.position.y = 10; gridHelper.add(gridTop);
        const starGeo = new THREE.BufferGeometry(); const posArray = new Float32Array(6000);
        for(let i=0; i<6000; i++) posArray[i] = (Math.random() - 0.5) * 100;
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        starField = new THREE.Points(starGeo, new THREE.PointsMaterial({size: 0.2, color: 0xffffff, transparent: true, opacity: 0.8}));
        starField.visible = false; bgGroup.add(starField);

        function setScenario(name) {
            gridHelper.visible = false; starField.visible = false;
            scene.background = new THREE.Color(0x000000);
            document.querySelectorAll('.mode-btn').forEach(b => { if(!b.id.includes('react')) b.classList.remove('active'); });
            document.getElementById(`btn-${name.toLowerCase()}`).classList.add('active');
            if (name === 'Grid') { gridHelper.visible = true; scene.background = new THREE.Color(0x050510); }
            else if (name === 'Warp') { starField.visible = true; scene.background = new THREE.Color(0x000010); }
        }

        // --- TRAZOS REACTIVOS ---
        class RibbonTrail {
            constructor(idx) {
                this.idx = idx; this.length = 50; this.points = []; this.visible = true;
                this.target = new THREE.Vector3(0,-1000,0); this.current = new THREE.Vector3(0,-1000,0);
                for(let i=0; i<this.length; i++) this.points.push(new THREE.Vector3(0,-1000,0));
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.length*6), 3));
                
                this.material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: params.opacity, blending: THREE.AdditiveBlending });
                this.mesh = new THREE.Mesh(geo, this.material); scene.add(this.mesh); this.mesh.frustumCulled = false;
            }
            setTarget(x,y,z) { this.target.set(x,y,z); }
            reset() { this.target.set(0,-1000,0); this.current.set(0,-1000,0); }
            
            tick(time, audioLevel) {
                if(!this.visible) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                this.current.lerp(this.target, params.relaxation);
                this.points.shift(); this.points.push(this.current.clone());

                const curve = new THREE.CatmullRomCurve3(this.points, false, 'catmullrom', 0.5);
                const pts = curve.getPoints(this.length - 1);
                const pos = this.mesh.geometry.attributes.position.array;
                
                // AUDIO REACT: Modificar grosor
                let width = params.lineWidth + (params.audioReact ? audioLevel * 2.0 : 0);

                for(let i=0; i<pts.length; i++) {
                    const dir = new THREE.Vector3().subVectors(pts[Math.min(i+1, pts.length-1)], pts[i]).normalize();
                    if(dir.lengthSq()===0) dir.set(0,1,0);
                    const right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,0,1)).normalize();
                    const w = width * Math.pow(i/this.length, 0.5);
                    pos[i*6+0] = pts[i].x - right.x*w; pos[i*6+1] = pts[i].y - right.y*w; pos[i*6+2] = pts[i].z;
                    pos[i*6+3] = pts[i].x + right.x*w; pos[i*6+4] = pts[i].y + right.y*w; pos[i*6+5] = pts[i].z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
                
                let hue = 0;
                if(params.mode==='Spectral') hue=(time*params.colorSpeed*0.1+(this.idx*0.05))%1;
                else if(params.mode==='Fire') hue=(Math.sin(time+this.idx)*0.05)%1;
                else hue=(0.6+Math.sin(time+this.idx)*0.1)%1;
                this.material.color.setHSL(hue, 1.0, 0.5 + (audioLevel * 0.2)); // Brillo extra con audio
            }
        }

        class ParticleEmitter {
            constructor(idx) {
                this.idx = idx; this.visible = false; this.particles = []; this.maxParticles = 50;
                this.target = new THREE.Vector3(0,-1000,0); this.lastPos = new THREE.Vector3(0,-1000,0);
                
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.maxParticles*3), 3));
                geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.maxParticles), 1));
                geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.maxParticles*3), 3));
                
                this.mesh = new THREE.Points(geo, new THREE.PointsMaterial({ size: 1.0, map: particleTexture, transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false }));
                scene.add(this.mesh); this.mesh.frustumCulled = false;

                for(let i=0; i<this.maxParticles; i++) this.particles.push({pos: new THREE.Vector3(0,-1000,0), vel: new THREE.Vector3(), life: 0, color: new THREE.Color()});
            }
            setTarget(x,y,z) { this.target.set(x,y,z); }
            reset() { this.target.set(0,-1000,0); this.lastPos.set(0,-1000,0); }

            tick(time, audioLevel) {
                if(!this.visible) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                const currentPos = new THREE.Vector3().lerpVectors(this.lastPos, this.target, 0.3);
                const isSmoke = params.trailStyle === 'Smoke';
                const spread = (isSmoke ? 0.1 : 0.2) + (params.audioReact ? audioLevel : 0);

                if (this.target.distanceTo(this.lastPos) > 0.01 || Math.random() < 0.1) {
                    const p = this.particles.find(p => p.life <= 0);
                    if(p) {
                        p.life = 1.0; p.pos.copy(currentPos);
                        p.vel.set((Math.random()-0.5)*spread, (Math.random()-0.5)*spread + (isSmoke?0.02:-0.05), (Math.random()-0.5)*spread);
                        let hue = 0;
                        if(params.mode==='Spectral') hue=(time*params.colorSpeed*0.1+(this.idx*0.05))%1;
                        else if(params.mode==='Fire') hue=(0.05+Math.random()*0.1);
                        else hue=(0.6+Math.random()*0.1);
                        p.color.setHSL(hue, 1.0, 0.5);
                    }
                }
                this.lastPos.copy(currentPos);

                const positions = this.mesh.geometry.attributes.position.array;
                const sizes = this.mesh.geometry.attributes.size.array;
                const colors = this.mesh.geometry.attributes.color.array;

                this.particles.forEach((p, i) => {
                    if(p.life > 0) {
                        p.life -= isSmoke ? 0.01 : 0.04;
                        p.pos.add(p.vel);
                        let size = (isSmoke ? params.particleSize*3 : params.particleSize) * p.life;
                        if(params.audioReact) size += audioLevel * 3.0; // Particulas explotan con sonido

                        positions[i*3]=p.pos.x; positions[i*3+1]=p.pos.y; positions[i*3+2]=p.pos.z;
                        sizes[i] = size;
                        colors[i*3]=p.color.r; colors[i*3+1]=p.color.g; colors[i*3+2]=p.color.b;
                    } else { sizes[i] = 0; positions[i*3+1] = -1000; }
                });
                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.geometry.attributes.size.needsUpdate = true;
                this.mesh.geometry.attributes.color.needsUpdate = true;
            }
        }

        const ribbons = []; const particles = [];
        for(let i=0; i<10; i++) { ribbons.push(new RibbonTrail(i)); particles.push(new ParticleEmitter(i)); }
        function resetCanvas() { ribbons.forEach(r=>r.reset()); particles.forEach(p=>p.reset()); }

        // --- MEDIAPIPE ---
        const videoElement = document.createElement('video');
        let melodyHandActive = false, chordHandActive = false;
        
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            document.getElementById('loading').style.display = 'none';
            melodyHandActive = false; chordHandActive = false;
            
            if (results.multiHandLandmarks) {
                results.multiHandLandmarks.forEach((lm, index) => {
                    if (index > 1) return;
                    [4,8,12,16,20].forEach((fIdx, i) => {
                        const globalIdx = (index * 5) + i;
                        const x = (lm[fIdx].x - 0.5) * -((camera.aspect*camera.position.z*0.8)*params.inputSensitivity);
                        const y = (lm[fIdx].y - 0.5) * -((camera.position.z*0.8)*params.inputSensitivity);
                        const z = -lm[fIdx].z * 20;
                        ribbons[globalIdx].setTarget(x,y,z); particles[globalIdx].setTarget(x,y,z);
                    });
                    
                    if (index===0) { melodyHandActive=true; audioSys.updateMelody(lm[8].x, lm[8].y, true); }
                    else { chordHandActive=true; audioSys.updateChords(lm[8].x, lm[8].y, true); }
                });
            }
            if(!melodyHandActive) audioSys.updateMelody(0,0,false);
            if(!chordHandActive) audioSys.updateChords(0,0,false);
        });

        const cameraFeed = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 1280, height: 720 });
        cameraFeed.start();

        // --- GUI & CONTROL ---
        const gui = new GUI({ title: 'System Core' });
        
        const fStyle = gui.addFolder('Visual Style');
        fStyle.add(params, 'trailStyle', ['Ribbon', 'Particles', 'Smoke']).onChange(v => {
            ribbons.forEach(r => r.visible = (v === 'Ribbon')); particles.forEach(p => p.visible = (v !== 'Ribbon'));
        });
        fStyle.add(params, 'particleSize', 0.1, 5.0);
        fStyle.add(params, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength=v);
        
        const fAudio = gui.addFolder('Audio & Mic');
        fAudio.add(params, 'soundEnabled').name('Sound ON/OFF');
        fAudio.add(params, 'audioReact').name('Visual Reaction').onChange(v => {
            const btn = document.getElementById('btn-react');
            btn.innerText = v ? "REACT: ON" : "REACT: OFF";
            btn.classList.toggle('react-active', v);
        });
        
        // SELECTOR DE FUENTE DE AUDIO
        fAudio.add(params, 'audioSource', ['Internal', 'Microphone'])
            .name('Input Source')
            .onChange(async (val) => {
                if(val === 'Microphone') await audioSys.enableMicrophone();
                else audioSys.stopMicrophone();
                audioSys.updateUI();
            });

        fAudio.add(params, 'micGain', 1.0, 10.0).name('Mic Sensitivity');
        
        const fKey = gui.addFolder('Music Key');
        fKey.add(params, 'key', ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']).onChange(v=>audioSys.setKey(v));

        const initAudio = () => { audioSys.init(); if(audioSys.ctx?.state==='suspended') audioSys.ctx.resume(); };
        window.addEventListener('click', initAudio); window.addEventListener('touchstart', initAudio);
        window.addEventListener('keydown', e => { if(e.key.toLowerCase()==='r') resetCanvas(); });

        document.getElementById('btn-void').onclick = () => setScenario('Void');
        document.getElementById('btn-grid').onclick = () => setScenario('Grid');
        document.getElementById('btn-warp').onclick = () => setScenario('Warp');
        
        const btnReact = document.getElementById('btn-react');
        btnReact.onclick = () => {
            params.audioReact = !params.audioReact;
            btnReact.innerText = params.audioReact ? "REACT: ON" : "REACT: OFF";
            btnReact.classList.toggle('react-active', params.audioReact);
            gui.controllers.find(c => c.property === 'audioReact').updateDisplay();
        };

        ribbons.forEach(r=>r.visible=true);
        setScenario('Void');

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            
            // Lógica Reactiva
            let audioLevel = 0;
            if (params.audioReact) audioLevel = audioSys.getVolume();

            // Efectos globales reactivos
            if (params.audioReact) {
                bloomPass.strength = params.bloomStrength + (audioLevel * 2.5); // Bloom pulsa
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, 12 - (audioLevel * 1.5), 0.1); // Zoom sutil
            } else {
                bloomPass.strength = params.bloomStrength;
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, 12, 0.1);
            }

            for(let i=0; i<10; i++) {
                if(params.trailStyle === 'Ribbon') ribbons[i].tick(time, audioLevel);
                else particles[i].tick(time, audioLevel);
            }

            if(gridHelper.visible) gridHelper.position.z = (time*2)%10;
            if(starField.visible) { starField.rotation.z=time*0.1; starField.rotation.x=Math.sin(time*0.2)*0.2; }
            composer.render();
        }
        animate();
        
        window.onresize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); };
    </script>

    <div id="loading">INICIALIZANDO SISTEMA...</div>
    <div id="audio-hint">CLICK PARA ACTIVAR AUDIO</div>
    
    <div id="bottom-menu">
        <div id="btn-void" class="mode-btn active">Void</div>
        <div id="btn-grid" class="mode-btn">Cyber Grid</div>
        <div id="btn-warp" class="mode-btn">Warp Hole</div>
        <div id="btn-react" class="mode-btn">REACT: OFF</div>
    </div>
</body>
</html>
