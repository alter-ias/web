<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - AlterLabGen Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Pantalla de Bienvenida / Overlay */
        #overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 5, 10, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; transition: opacity 0.8s ease;
        }

        #overlay.hidden { opacity: 0; pointer-events: none; }

        .title-container {
            text-align: center; color: #0ff; margin-bottom: 30px;
        }

        .main-title {
            font-size: 24px; letter-spacing: 4px; font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            margin-bottom: 10px;
        }

        .sub-title {
            font-size: 14px; color: #88c; letter-spacing: 2px;
        }

        #start-btn {
            background: transparent; color: #0ff; 
            border: 2px solid #0ff; padding: 15px 40px;
            font-size: 16px; letter-spacing: 3px; cursor: pointer;
            text-transform: uppercase; border-radius: 30px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        #start-btn:hover {
            background: #0ff; color: #000; box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        #bottom-menu {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 5;
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.5s; opacity: 0; /* Oculto al inicio */
        }

        .mode-btn {
            background: rgba(20, 20, 20, 0.8); color: #888; border: 1px solid #444;
            padding: 10px 20px; border-radius: 8px; cursor: pointer;
            font-weight: bold; text-transform: uppercase; font-size: 12px;
            transition: all 0.3s ease;
        }

        .mode-btn:hover { background: #333; color: #fff; border-color: #fff; }
        .mode-btn.active { background: #0ff; color: #000; border-color: #0ff; box-shadow: 0 0 15px #0ff; }
        
        #audio-hint {
            position: absolute; top: 20px; right: 20px; 
            color: rgba(255,255,255,0.5); font-size: 10px; z-index: 5;
            opacity: 0; transition: opacity 0.5s;
        }

        .lil-gui { --background-color: rgba(5, 5, 10, 0.9); --text-color: #ddd; --title-background-color: #111; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- ESTADO DEL SISTEMA ---
        let isRunning = false;

        // --- PARÁMETROS GLOBALES ---
        const params = {
            trailStyle: 'Ribbon', 
            lineWidth: 0.8,
            bloomStrength: 1.5,
            bloomRadius: 0.5,
            relaxation: 0.15,
            colorSpeed: 1.5,
            opacity: 0.85,
            particleSize: 1.0, 
            mode: 'Spectral',
            inputSensitivity: 1.5,
            soundEnabled: true,
            reset: () => resetCanvas()
        };

        // --- MOTOR DE AUDIO (SYNTH) ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.osc1 = null;
                this.osc2 = null;
                this.gainNode = null;
                this.filter = null;
                this.isInit = false;
            }

            init() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                this.osc1 = this.ctx.createOscillator();
                this.osc1.type = 'sine';
                
                this.osc2 = this.ctx.createOscillator();
                this.osc2.type = 'triangle';
                this.osc2.detune.value = 10;

                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 1000;

                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.3;
                const delayFeedback = this.ctx.createGain();
                delayFeedback.gain.value = 0.4;
                const delayFilter = this.ctx.createBiquadFilter();
                delayFilter.frequency.value = 800;

                this.gainNode = this.ctx.createGain();
                this.gainNode.gain.value = 0; 

                this.osc1.connect(this.filter);
                this.osc2.connect(this.filter);
                this.filter.connect(this.gainNode);
                this.gainNode.connect(this.ctx.destination);
                this.gainNode.connect(delay);
                delay.connect(delayFilter);
                delayFilter.connect(delayFeedback);
                delayFeedback.connect(delay);
                delay.connect(this.ctx.destination);

                this.osc1.start();
                this.osc2.start();
                this.isInit = true;
                
                document.getElementById('audio-hint').innerText = "AUDIO: ACTIVO";
            }

            update(normX, normY, hasHand) {
                if (!this.isInit || !params.soundEnabled) return;

                if (hasHand && isRunning) {
                    const minFreq = 150;
                    const maxFreq = 600;
                    const freq = minFreq + (normX * (maxFreq - minFreq));
                    const vol = Math.max(0, (1.0 - normY) * 0.3);

                    const t = this.ctx.currentTime;
                    this.osc1.frequency.setTargetAtTime(freq, t, 0.1);
                    this.osc2.frequency.setTargetAtTime(freq * 1.5, t, 0.1);
                    this.gainNode.gain.setTargetAtTime(vol, t, 0.1);
                    this.filter.frequency.setTargetAtTime(freq * 2, t, 0.1);
                } else {
                    const t = this.ctx.currentTime;
                    this.gainNode.gain.setTargetAtTime(0, t, 0.5);
                }
            }
        }
        
        const audioSys = new AudioEngine();

        // --- TEXTURAS ---
        function createSoftTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createSoftTexture();

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 12;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        let visibleWidth, visibleHeight;
        function updateVisibleArea() {
            const vFOV = camera.fov * Math.PI / 180;
            visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            visibleWidth = visibleHeight * camera.aspect;
        }
        updateVisibleArea();

        // --- POST-PROCESAMIENTO ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = params.bloomStrength;
        bloomPass.radius = params.bloomRadius;
        composer.addPass(bloomPass);

        // --- BACKGROUNDS ---
        const bgGroup = new THREE.Group();
        scene.add(bgGroup);
        let gridHelper, starField;

        function initBackgrounds() {
            gridHelper = new THREE.GridHelper(100, 40, 0x00ffff, 0x222222);
            gridHelper.position.y = -10;
            gridHelper.visible = false;
            bgGroup.add(gridHelper);
            
            const gridTop = gridHelper.clone();
            gridTop.position.y = 20; // Ajustado para que esté arriba relativo al padre si fuera necesario, pero clone no copia hijos.
            gridTop.rotation.x = Math.PI; // Espejo
            bgGroup.add(gridTop); // Agregamos al grupo, no al helper

            const starGeo = new THREE.BufferGeometry();
            const starCount = 2000;
            const posArray = new Float32Array(starCount * 3);
            for(let i=0; i<starCount*3; i++) posArray[i] = (Math.random() - 0.5) * 100;
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starMat = new THREE.PointsMaterial({size: 0.2, color: 0xffffff, transparent: true, opacity: 0.8});
            starField = new THREE.Points(starGeo, starMat);
            starField.visible = false;
            bgGroup.add(starField);
        }
        initBackgrounds();

        function setScenario(name) {
            gridHelper.visible = false;
            starField.visible = false;
            scene.background = new THREE.Color(0x000000);
            scene.fog.color.setHex(0x000000);
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById(`btn-${name.toLowerCase()}`);
            if(btn) btn.classList.add('active');

            if (name === 'Grid') {
                gridHelper.visible = true;
                scene.background = new THREE.Color(0x050510);
                scene.fog.color.setHex(0x050510);
            } else if (name === 'Warp') {
                starField.visible = true;
                scene.background = new THREE.Color(0x000010);
            }
        }

        // --- CLASES VISUALES ---
        class RibbonTrail {
            constructor(idx) {
                this.idx = idx;
                this.length = 50; 
                this.points = []; 
                this.visible = true;
                this.target = new THREE.Vector3(0,-1000,0);
                this.current = new THREE.Vector3(0,-1000,0);
                
                for(let i=0; i<this.length; i++) this.points.push(new THREE.Vector3(0,-1000,0));

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.length * 2 * 3);
                const uvs = new Float32Array(this.length * 2 * 2);
                for(let i=0; i<this.length; i++) {
                    const u = i / (this.length - 1);
                    uvs[i*4 + 0] = u; uvs[i*4 + 1] = 0;
                    uvs[i*4 + 2] = u; uvs[i*4 + 3] = 1;
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
                
                // CORRECCIÓN DE DEPRECATION: Usamos StreamDrawUsage en lugar de dynamic = true
                geometry.attributes.position.usage = THREE.StreamDrawUsage;

                const indices = [];
                for(let i=0; i < this.length - 1; i++) {
                    const v = i * 2;
                    indices.push(v, v+1, v+2); indices.push(v+2, v+1, v+3);
                }
                geometry.setIndex(indices);

                this.material = new THREE.MeshBasicMaterial({
                    color: 0xffffff, side: THREE.DoubleSide, transparent: true,
                    opacity: params.opacity, blending: THREE.AdditiveBlending, depthTest: false
                });

                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.frustumCulled = false;
                scene.add(this.mesh);
            }

            setTarget(x, y, z) { this.target.set(x, y, z); }
            reset() { this.target.set(0,-1000,0); this.current.set(0,-1000,0); for(let p of this.points) p.set(0,-1000,0); }

            tick(time) {
                if(!this.visible) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                this.current.lerp(this.target, params.relaxation);
                this.points.shift();
                this.points.push(this.current.clone());

                const curve = new THREE.CatmullRomCurve3(this.points, false, 'catmullrom', 0.5);
                const splinePoints = curve.getPoints(this.length - 1);
                const pos = this.mesh.geometry.attributes.position.array;
                const widthBase = params.lineWidth;

                for(let i=0; i < splinePoints.length; i++) {
                    let p = splinePoints[i];
                    let nextP = splinePoints[Math.min(i+1, splinePoints.length-1)];
                    let dir = new THREE.Vector3().subVectors(nextP, p).normalize();
                    if (dir.lengthSq() === 0) dir.set(0,1,0); 
                    
                    let right = new THREE.Vector3().crossVectors(dir, new THREE.Vector3(0,0,1)).normalize();
                    let scale = Math.pow(i / this.length, 0.5); 
                    let w = widthBase * scale;

                    pos[i*6 + 0] = p.x - right.x * w; pos[i*6 + 1] = p.y - right.y * w; pos[i*6 + 2] = p.z;
                    pos[i*6 + 3] = p.x + right.x * w; pos[i*6 + 4] = p.y + right.y * w; pos[i*6 + 5] = p.z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;

                let hue = 0;
                if(params.mode === 'Spectral') hue = (time * params.colorSpeed * 0.1 + (this.idx * 0.05)) % 1;
                if(params.mode === 'Fire') hue = (0.0 + (Math.sin(time + this.idx)*0.05)) % 1; 
                if(params.mode === 'Ocean') hue = (0.6 + (Math.sin(time + this.idx)*0.1)) % 1; 
                this.material.color.setHSL(hue, 1.0, 0.5);
                this.material.opacity = params.opacity;
            }
        }

        class ParticleEmitter {
            constructor(idx) {
                this.idx = idx;
                this.visible = false;
                this.particles = [];
                this.maxParticles = 50; 
                this.target = new THREE.Vector3(0,-1000,0);
                this.lastPos = new THREE.Vector3(0,-1000,0);

                this.geometry = new THREE.BufferGeometry();
                const posArray = new Float32Array(this.maxParticles * 3);
                const sizeArray = new Float32Array(this.maxParticles);
                const colorArray = new Float32Array(this.maxParticles * 3);
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizeArray, 1));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
                
                // Corrección deprecation
                this.geometry.attributes.position.usage = THREE.StreamDrawUsage;
                this.geometry.attributes.size.usage = THREE.StreamDrawUsage;
                this.geometry.attributes.color.usage = THREE.StreamDrawUsage;

                this.material = new THREE.PointsMaterial({
                    size: 1.0, map: particleTexture, transparent: true,
                    vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
                });

                this.mesh = new THREE.Points(this.geometry, this.material);
                this.mesh.frustumCulled = false;
                scene.add(this.mesh);

                for(let i=0; i<this.maxParticles; i++) {
                    this.particles.push({
                        pos: new THREE.Vector3(0,-1000,0), vel: new THREE.Vector3(0,0,0),
                        life: 0, maxLife: 1.0, baseColor: new THREE.Color()
                    });
                }
            }

            setTarget(x, y, z) { this.target.set(x, y, z); }
            reset() { this.target.set(0,-1000,0); this.lastPos.set(0,-1000,0); for(let p of this.particles) p.life = 0; }

            tick(time) {
                if(!this.visible) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                const dist = this.target.distanceTo(this.lastPos);
                const currentPos = new THREE.Vector3().lerpVectors(this.lastPos, this.target, 0.3);
                
                const isSmoke = params.trailStyle === 'Smoke';
                const gravity = isSmoke ? 0.02 : -0.05; 
                const spread = isSmoke ? 0.1 : 0.2;

                if (dist > 0.01 || Math.random() < 0.1) {
                    const p = this.particles.find(p => p.life <= 0);
                    if (p) {
                        p.life = 1.0;
                        p.pos.copy(currentPos);
                        p.pos.x += (Math.random() - 0.5) * spread;
                        p.pos.y += (Math.random() - 0.5) * spread;
                        p.vel.set((Math.random() - 0.5) * spread, (Math.random() - 0.5) * spread + gravity, (Math.random() - 0.5) * spread);

                        let hue = 0;
                        if(params.mode === 'Spectral') hue = (time * params.colorSpeed * 0.1 + (this.idx * 0.05)) % 1;
                        else if(params.mode === 'Fire') hue = (0.05 + Math.random()*0.1); 
                        else if(params.mode === 'Ocean') hue = (0.6 + Math.random()*0.1);
                        p.baseColor.setHSL(hue, 1.0, 0.5);
                    }
                }
                this.lastPos.copy(currentPos);

                const positions = this.mesh.geometry.attributes.position.array;
                const sizes = this.mesh.geometry.attributes.size.array;
                const colors = this.mesh.geometry.attributes.color.array;

                this.particles.forEach((p, i) => {
                    if (p.life > 0) {
                        p.life -= (isSmoke ? 0.01 : 0.04);
                        p.pos.add(p.vel);
                        const lifeScale = isSmoke ? Math.sin(p.life * Math.PI) : p.life;
                        const baseSize = isSmoke ? params.particleSize * 3 : params.particleSize;
                        
                        positions[i*3] = p.pos.x; positions[i*3+1] = p.pos.y; positions[i*3+2] = p.pos.z;
                        sizes[i] = baseSize * lifeScale;
                        colors[i*3] = p.baseColor.r; colors[i*3+1] = p.baseColor.g; colors[i*3+2] = p.baseColor.b;
                    } else {
                        positions[i*3] = 0; positions[i*3+1] = -1000;
                        sizes[i] = 0;
                    }
                });
                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.geometry.attributes.size.needsUpdate = true;
                this.mesh.geometry.attributes.color.needsUpdate = true;
            }
        }

        // --- INICIALIZAR ARRAYS ---
        const ribbons = [];
        const particles = [];
        for(let i=0; i<10; i++) {
            ribbons.push(new RibbonTrail(i));
            particles.push(new ParticleEmitter(i));
        }

        function resetCanvas() {
            ribbons.forEach(t => t.reset());
            particles.forEach(p => p.reset());
        }

        // --- MEDIAPIPE ---
        const videoElement = document.createElement('video');
        const fingerIndices = [4, 8, 12, 16, 20];
        let handDetected = false;

        function onResults(results) {
            // Solo procesamos lógica visual si el sistema está corriendo
            if (!isRunning) return;

            handDetected = false;
            let mainFingerX = 0; 
            let mainFingerY = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                
                results.multiHandLandmarks.forEach((landmarks, handIndex) => {
                    if (handIndex > 1) return;
                    
                    if (handIndex === 0) {
                        mainFingerX = landmarks[8].x;
                        mainFingerY = landmarks[8].y;
                    }

                    fingerIndices.forEach((fingerIdx, i) => {
                        const lm = landmarks[fingerIdx];
                        const x = (lm.x - 0.5) * -visibleWidth * params.inputSensitivity; 
                        const y = (lm.y - 0.5) * -visibleHeight * params.inputSensitivity;
                        const z = -lm.z * 20; 
                        
                        const globalIdx = (handIndex * 5) + i;
                        if(ribbons[globalIdx]) ribbons[globalIdx].setTarget(x, y, z);
                        if(particles[globalIdx]) particles[globalIdx].setTarget(x, y, z);
                    });
                });
            }

            audioSys.update(mainFingerX, mainFingerY, handDetected);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        // --- GUI ---
        const gui = new GUI({ title: 'System Core' });
        
        const folderStyle = gui.addFolder('Estilo de Trazo');
        folderStyle.add(params, 'trailStyle', ['Ribbon', 'Particles', 'Smoke']).name('Tipo').onChange(val => {
            ribbons.forEach(r => r.visible = (val === 'Ribbon'));
            particles.forEach(p => p.visible = (val !== 'Ribbon'));
        });
        folderStyle.add(params, 'particleSize', 0.1, 5.0).name('Tamaño Partícula');

        const folderVisuals = gui.addFolder('Visuals');
        folderVisuals.add(params, 'lineWidth', 0.1, 2.0);
        folderVisuals.add(params, 'bloomStrength', 0.0, 3.0).onChange(v => bloomPass.strength = v);
        folderVisuals.add(params, 'inputSensitivity', 1.0, 3.0).name('Sensibilidad');
        
        const folderAudio = gui.addFolder('Audio');
        folderAudio.add(params, 'soundEnabled').name('Sonido Activado');

        const folderColors = gui.addFolder('Colors');
        folderColors.add(params, 'mode', ['Spectral', 'Fire', 'Ocean']).name('Paleta');
        folderColors.add(params, 'colorSpeed', 0.0, 5.0);

        gui.add(params, 'reset').name('REINICIAR (R)');

        window.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'r') resetCanvas();
        });

        document.getElementById('btn-void').onclick = () => setScenario('Void');
        document.getElementById('btn-grid').onclick = () => setScenario('Grid');
        document.getElementById('btn-warp').onclick = () => setScenario('Warp');

        // --- INICIO DE EXPERIENCIA (Lógica del Botón) ---
        const startBtn = document.getElementById('start-btn');
        const overlay = document.getElementById('overlay');
        const bottomMenu = document.getElementById('bottom-menu');
        const audioHint = document.getElementById('audio-hint');

        startBtn.addEventListener('click', () => {
            // 1. Iniciar Audio (Debe ser en evento de usuario)
            audioSys.init();
            if(audioSys.ctx && audioSys.ctx.state === 'suspended') {
                audioSys.ctx.resume();
            }

            // 2. Ocultar Overlay
            overlay.classList.add('hidden');
            
            // 3. Mostrar UI
            bottomMenu.style.opacity = 1;
            audioHint.style.opacity = 1;

            // 4. Activar Lógica Visual
            isRunning = true;
        });

        ribbons.forEach(r => r.visible = true);
        particles.forEach(p => p.visible = false);

        // --- ANIMATE ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            for(let i=0; i<10; i++) {
                if(params.trailStyle === 'Ribbon') ribbons[i].tick(time);
                else particles[i].tick(time);
            }

            if(gridHelper && gridHelper.visible) gridHelper.position.z = (time * 2) % 10;
            if(starField && starField.visible) {
                starField.rotation.z = time * 0.1;
                starField.rotation.x = Math.sin(time * 0.2) * 0.2;
            }

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            updateVisibleArea();
        });

        setScenario('Void');
    </script>

    <div id="overlay">
        <div class="title-container">
            <div class="main-title">EL MUNDO EN TUS MANOS</div>
            <div class="sub-title">Un proyecto de AlterLabGen</div>
        </div>
        <button id="start-btn">INICIAR EXPERIENCIA</button>
    </div>

    <div id="audio-hint">AUDIO: ESPERANDO...</div>
    
    <div id="bottom-menu">
        <div id="btn-void" class="mode-btn active">Void</div>
        <div id="btn-grid" class="mode-btn">Cyber Grid</div>
        <div id="btn-warp" class="mode-btn">Warp Hole</div>
    </div>
</body>
</html>
