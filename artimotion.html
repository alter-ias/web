<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Level 3: Liquid Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; display: flex; justify-content: center; align-items: center;
        }
        #loading { 
            color: #00ffff; font-family: 'Courier New', monospace; 
            font-size: 16px; letter-spacing: 3px; text-transform: uppercase;
            text-shadow: 0 0 20px #00ffff;
            background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #00ffff;
        }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { AfterimagePass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/AfterimagePass.js';

        // --- CONFIGURACIÓN VISUAL ---
        const VISUALS = {
            trailLength: 25,     // Longitud de la estela
            trailWidth: 200,     // Cantidad de puntos en la curva suavizada
            bloomStrength: 2.5,  // Intensidad del brillo
            particleCount: 400   // Partículas por mano
        };

        // --- 1. ESCENA ---
        const scene = new THREE.Scene();
        // Fondo sutilmente estrellado o nebuloso se logra mejor con partículas, pero usaremos color sólido + post-proceso
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio para rendimiento
        document.body.appendChild(renderer.domElement);

        // --- 2. POST-PROCESAMIENTO (LA MAGIA VISUAL) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        // Afterimage: Crea ese rastro fantasma que se desvanece suavemente
        const afterimagePass = new AfterimagePass();
        afterimagePass.uniforms["damp"].value = 0.85; // 0.9 = rastro muy largo, 0.7 = corto
        composer.addPass(afterimagePass);

        // Bloom: El brillo neón
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = VISUALS.bloomStrength;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.1;
        composer.addPass(bloomPass);

        // --- 3. CLASE: SPLINE TRAIL (Estela Líquida) ---
        // Usa curvas matemáticas para suavizar movimientos bruscos
        class LiquidTrail {
            constructor(hueOffset) {
                this.points = []; // Puntos reales de la mano
                this.maxPoints = VISUALS.trailLength;
                this.hueOffset = hueOffset;
                
                // Geometría para la línea suavizada
                // Usamos muchos más vértices que puntos de control para que sea curva
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(VISUALS.trailWidth * 3);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Material que permite colores por vértice (gradiente)
                const material = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.8,
                    linewidth: 2
                });

                this.mesh = new THREE.Line(geometry, material);
                
                // Inicializar colores del gradiente
                const colors = new Float32Array(VISUALS.trailWidth * 3);
                this.mesh.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                scene.add(this.mesh);
                
                // Inicializar fuera de pantalla
                for(let i=0; i<this.maxPoints; i++) this.points.push(new THREE.Vector3(0, -50, 0));
            }

            update(targetPos, time) {
                // 1. Agregar nuevo punto al historial (cola de serpiente)
                this.points.shift();
                this.points.push(targetPos.clone());

                // 2. Crear la curva CatmullRom (Matemática de fluidos)
                const curve = new THREE.CatmullRomCurve3(this.points, false, 'catmullrom', 0.5);
                
                // 3. Obtener puntos suavizados a lo largo de la curva
                const smoothPoints = curve.getPoints(VISUALS.trailWidth - 1);
                
                // 4. Actualizar geometría y colores
                const positions = this.mesh.geometry.attributes.position.array;
                const colors = this.mesh.geometry.attributes.color.array;
                const colorObj = new THREE.Color();

                for (let i = 0; i < VISUALS.trailWidth; i++) {
                    const p = smoothPoints[i];
                    positions[i * 3] = p.x;
                    positions[i * 3 + 1] = p.y;
                    positions[i * 3 + 2] = p.z;

                    // Gradiente de color: Cabeza brillante, cola oscura
                    // Ciclo de color basado en tiempo + índice
                    const hue = (time * 0.1 + this.hueOffset + (i * 0.002)) % 1;
                    const lightness = (i / VISUALS.trailWidth); // 0 en la cola, 1 en la cabeza
                    
                    colorObj.setHSL(hue, 1.0, lightness * 0.6); // * 0.6 para no saturar al blanco
                    
                    colors[i * 3] = colorObj.r;
                    colors[i * 3 + 1] = colorObj.g;
                    colors[i * 3 + 2] = colorObj.b;
                }

                this.mesh.geometry.attributes.position.needsUpdate = true;
                this.mesh.geometry.attributes.color.needsUpdate = true;
            }
        }

        // --- 4. CLASE: EMISOR DE PARTÍCULAS (Chispas) ---
        class ParticleEmitter {
            constructor() {
                this.poolSize = 1000;
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.poolSize * 3);
                this.velocities = []; 
                this.lifetimes = new Float32Array(this.poolSize); // 0 = muerta, 1 = viva
                
                for(let i=0; i<this.poolSize; i++) {
                    this.velocities.push({x:0, y:0, z:0});
                    this.lifetimes[i] = 0;
                    this.positions[i*3+1] = -100; // Esconder
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                
                const material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.15,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                this.mesh = new THREE.Points(this.geometry, material);
                scene.add(this.mesh);
                
                this.nextIdx = 0;
            }

            emit(pos, velocity) {
                // Emitir varias partículas por frame para densidad
                for(let k=0; k<2; k++) {
                    const idx = this.nextIdx;
                    this.nextIdx = (this.nextIdx + 1) % this.poolSize;

                    this.positions[idx*3] = pos.x + (Math.random()-0.5)*0.2;
                    this.positions[idx*3+1] = pos.y + (Math.random()-0.5)*0.2;
                    this.positions[idx*3+2] = pos.z + (Math.random()-0.5)*0.2;

                    // La partícula hereda velocidad de la mano + turbulencia aleatoria
                    this.velocities[idx].x = velocity.x * 0.5 + (Math.random()-0.5) * 0.1;
                    this.velocities[idx].y = velocity.y * 0.5 + (Math.random()-0.5) * 0.1;
                    this.velocities[idx].z = velocity.z * 0.5 + (Math.random()-0.5) * 0.1;

                    this.lifetimes[idx] = 1.0; // Vida llena
                }
            }

            update(time) {
                const posAttr = this.mesh.geometry.attributes.position.array;
                
                for(let i=0; i<this.poolSize; i++) {
                    if(this.lifetimes[i] > 0) {
                        // Física simple
                        this.velocities[i].x *= 0.96; // Fricción
                        this.velocities[i].y *= 0.96;
                        this.velocities[i].z *= 0.96;
                        
                        // Gravedad leve hacia arriba (como fuego/humo)
                        this.velocities[i].y += 0.002; 

                        posAttr[i*3] += this.velocities[i].x;
                        posAttr[i*3+1] += this.velocities[i].y;
                        posAttr[i*3+2] += this.velocities[i].z;

                        this.lifetimes[i] -= 0.015; // Decaer
                    } else {
                        posAttr[i*3] = 0;
                        posAttr[i*3+1] = -100; // Ocultar lejos
                    }
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
                
                // Color cíclico general para las partículas
                const hue = (time * 0.2) % 1;
                this.mesh.material.color.setHSL(hue, 0.8, 0.6);
            }
        }

        // --- INICIALIZACIÓN DE OBJETOS ---
        const trails = [];
        // Creamos 10 estelas (5 dedos x 2 manos)
        for(let i=0; i<10; i++) {
            trails.push(new LiquidTrail(i * 0.1));
        }

        const emitter = new ParticleEmitter();

        // Líneas de conexión (Red neuronal entre dedos)
        const connectionsMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending });
        const connectionsGeo = new THREE.BufferGeometry();
        // Reserva para 20 líneas posibles
        connectionsGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(20 * 2 * 3), 3)); 
        const connectionsMesh = new THREE.LineSegments(connectionsGeo, connectionsMat);
        scene.add(connectionsMesh);

        // --- MEDIAPIPE LOGIC ---
        const videoElement = document.createElement('video');
        const fingerIndices = [4, 8, 12, 16, 20]; // Puntas de los dedos
        
        // Almacenar posiciones anteriores para calcular velocidad
        let prevHandPositions = Array(10).fill(new THREE.Vector3(0,0,0));

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            // Limpiar conexiones si no hay manos
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                connectionsMesh.visible = false;
                return;
            }
            connectionsMesh.visible = true;

            const time = performance.now() * 0.001;
            let currentFingerPoints = [];

            results.multiHandLandmarks.forEach((landmarks, handIndex) => {
                if (handIndex > 1) return;

                fingerIndices.forEach((fingerIdx, i) => {
                    const lm = landmarks[fingerIdx];
                    // Mapeo de coordenadas (invertimos X para modo espejo)
                    const x = (lm.x - 0.5) * -16; 
                    const y = (lm.y - 0.5) * -10;
                    const z = -lm.z * 20;
                    
                    const currentPos = new THREE.Vector3(x, y, z);
                    const globalIdx = (handIndex * 5) + i;

                    // 1. Actualizar Trail Líquido
                    trails[globalIdx].update(currentPos, time);

                    // 2. Calcular Velocidad para partículas
                    const velocity = currentPos.clone().sub(prevHandPositions[globalIdx]);
                    
                    // Solo emitir si se mueve rápido
                    if(velocity.length() > 0.05) {
                        emitter.emit(currentPos, velocity);
                    }

                    // Guardar para siguiente frame
                    prevHandPositions[globalIdx].copy(currentPos);
                    
                    // Guardar para calcular conexiones
                    currentFingerPoints.push(currentPos);
                });
            });

            // 3. Actualizar Emisor
            emitter.update(time);

            // 4. Dibujar Conexiones (Red)
            // Conecta puntos que estén cerca entre sí dinámicamente
            let linePositions = connectionsMesh.geometry.attributes.position.array;
            let lineIdx = 0;
            
            for(let i=0; i<currentFingerPoints.length; i++) {
                for(let j=i+1; j<currentFingerPoints.length; j++) {
                    const p1 = currentFingerPoints[i];
                    const p2 = currentFingerPoints[j];
                    const dist = p1.distanceTo(p2);

                    // Si están cerca (ej. pellizco, o manos juntas) dibujamos línea
                    if(dist < 4) { // Umbral de distancia
                        if(lineIdx < linePositions.length - 6) {
                            linePositions[lineIdx++] = p1.x;
                            linePositions[lineIdx++] = p1.y;
                            linePositions[lineIdx++] = p1.z;
                            
                            linePositions[lineIdx++] = p2.x;
                            linePositions[lineIdx++] = p2.y;
                            linePositions[lineIdx++] = p2.z;
                        }
                    }
                }
            }
            
            // Limpiar el resto del buffer de líneas
            for(let k=lineIdx; k<linePositions.length; k++) linePositions[k] = 0;
            
            connectionsMesh.geometry.attributes.position.needsUpdate = true;
            // Color pulsante para la red
            connectionsMesh.material.color.setHSL((time * 0.5)%1, 0.9, 0.5);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        // Loop de renderizado
        function animate() {
            requestAnimationFrame(animate);
            // Rotación sutil de la cámara para dar dinamismo 3D
            const t = performance.now() * 0.0001;
            camera.position.x = Math.sin(t) * 1; 
            camera.lookAt(0,0,0);
            
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>

    <div id="ui-layer">
        <div id="loading">Inicializando Núcleo Visual...</div>
    </div>
</body>
</html>
