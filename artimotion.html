<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Hand Tracking Visuals</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        video { display: none; } /* Ocultamos el video raw */
        canvas { display: block; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: monospace; }
    </style>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

        // --- 1. CONFIGURACIÓN DE THREE.JS ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // POST-PROCESAMIENTO (BLOOM para el brillo "potente")
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 2.0; // Intensidad del brillo
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- 2. CREACIÓN DE OBJETOS VISUALES ---
        // Partículas para las articulaciones
        const jointGeometry = new THREE.SphereGeometry(0.05, 16, 16);
        const jointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const joints = [];
        
        // Creamos 42 esferas (2 manos * 21 puntos)
        for(let i=0; i<42; i++) {
            const sphere = new THREE.Mesh(jointGeometry, jointMaterial);
            scene.add(sphere);
            joints.push(sphere);
            sphere.visible = false;
        }

        // Líneas de conexión (Trails)
        const TRAIL_LENGTH = 30;
        const trailGeometries = [];
        const trails = [];
        
        // Creamos estelas solo para las puntas de los dedos (índices 4, 8, 12, 16, 20 de cada mano)
        const fingerTips = [4, 8, 12, 16, 20, 25, 29, 33, 37, 41]; // Índices ajustados para el array plano
        
        for (let i = 0; i < fingerTips.length; i++) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(TRAIL_LENGTH * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Color dinámico para cada dedo
            const color = new THREE.Color();
            color.setHSL(i / fingerTips.length, 1.0, 0.5);
            
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                opacity: 0.8, 
                transparent: true,
                linewidth: 2 
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            
            trails.push({
                mesh: line,
                positions: [], // Historial de posiciones
                targetIndex: -1 // Asignaremos dinámicamente
            });
            trailGeometries.push(geometry);
        }

        // --- 3. MEDIAPIPE (Detección de Manos) ---
        const videoElement = document.createElement('video');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            // Ocultar todo por defecto
            joints.forEach(j => j.visible = false);

            if (results.multiHandLandmarks) {
                let handIndex = 0;
                
                for (const landmarks of results.multiHandLandmarks) {
                    // Dibujar articulaciones
                    for (let i = 0; i < landmarks.length; i++) {
                        const idx = handIndex * 21 + i;
                        if (idx >= joints.length) break;

                        const joint = joints[idx];
                        // Convertir coordenadas normalizadas (0-1) a coordenadas de mundo Three.js
                        const x = (landmarks[i].x - 0.5) * -10; // Invertir X para efecto espejo
                        const y = (landmarks[i].y - 0.5) * -6; 
                        const z = -landmarks[i].z * 10; // Profundidad

                        joint.position.set(x, y, z);
                        joint.visible = true;

                        // Actualizar estelas para puntas de dedos
                        if ([4,8,12,16,20].includes(i)) {
                            // Encontrar el trail correspondiente o uno libre
                            // (Simplificación: asignamos basado en índice fijo para demo)
                            const trailIdx = (handIndex * 5) + ([4,8,12,16,20].indexOf(i));
                            updateTrail(trailIdx, x, y, z);
                        }
                    }
                    handIndex++;
                }
            }
        }

        function updateTrail(index, x, y, z) {
            const trail = trails[index];
            trail.positions.push({x, y, z});
            
            if (trail.positions.length > TRAIL_LENGTH) {
                trail.positions.shift();
            }

            const positions = trail.mesh.geometry.attributes.position.array;
            let posIdx = 0;
            
            // Rellenar el buffer con el historial
            for (let i = 0; i < trail.positions.length; i++) {
                positions[posIdx++] = trail.positions[i].x;
                positions[posIdx++] = trail.positions[i].y;
                positions[posIdx++] = trail.positions[i].z;
            }
            
            // Repetir la última posición para el resto del buffer si es necesario
            const lastPos = trail.positions[trail.positions.length - 1];
            while (posIdx < positions.length) {
                positions[posIdx++] = lastPos.x;
                positions[posIdx++] = lastPos.y;
                positions[posIdx++] = lastPos.z;
            }

            trail.mesh.geometry.attributes.position.needsUpdate = true;
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        cameraFeed.start();

        // --- 4. ANIMACIÓN ---
        function animate() {
            requestAnimationFrame(animate);
            // Renderizar con efecto Bloom
            composer.render();
        }
        animate();

        // Manejo de resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
    <div id="loading">Cargando modelo de IA...</div>
</body>
</html>
