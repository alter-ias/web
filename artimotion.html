<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Full Band System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* --- UI LAYER --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

        /* Divisor Dinámico */
        #screen-divider {
            position: absolute; top: 0; bottom: 0; width: 2px;
            background: linear-gradient(to bottom, transparent, #0ff, transparent);
            box-shadow: 0 0 15px #0ff;
            left: 50%; /* Se actualiza con JS */
            transition: left 0.1s;
        }
        
        .zone-label {
            position: absolute; top: 30px; 
            font-size: 16px; font-weight: 900; letter-spacing: 4px; text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        /* Las posiciones de las etiquetas ahora se calculan en JS relativas al divisor */

        /* Loading */
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; background: rgba(0, 10, 20, 0.95); 
            padding: 20px 40px; border: 1px solid #0ff; z-index: 20; text-align: center;
        }

        /* Pedalera */
        #pedalboard {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 10; pointer-events: auto;
        }
        .pedal {
            width: 65px; height: 90px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #333; border-radius: 6px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            padding-bottom: 12px; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.8);
            transition: transform 0.1s, border-color 0.2s;
        }
        .pedal:active { transform: scale(0.95); }
        .pedal-light {
            width: 10px; height: 10px; border-radius: 50%; background: #222;
            margin-bottom: 15px; box-shadow: 0 0 2px #000 inset; transition: all 0.2s;
        }
        .pedal-label { color: #666; font-size: 9px; font-weight: bold; text-transform: uppercase; text-align: center; }
        .pedal-key { color: #444; font-size: 8px; margin-top: 4px; font-family: monospace; }

        /* Estados Activos */
        .pedal.active { border-color: #0f0; }
        .pedal.active .pedal-light { background: #0f0; box-shadow: 0 0 10px #0f0; }
        
        .pedal.recording { border-color: #f00; }
        .pedal.recording .pedal-light { background: #f00; box-shadow: 0 0 10px #f00; }

        .pedal.rhythm-on { border-color: #ff00ff; }
        .pedal.rhythm-on .pedal-light { background: #ff00ff; box-shadow: 0 0 10px #ff00ff; }

        /* Menú de Escenarios */
        #bottom-menu {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; gap: 5px; z-index: 10; pointer-events: auto;
        }
        .mode-btn {
            background: rgba(0,0,0,0.6); color: #888; border: 1px solid #444;
            padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 10px;
        }
        .mode-btn.active { color: #0ff; border-color: #0ff; }

        .lil-gui { --background-color: rgba(5, 5, 10, 0.95); --text-color: #eee; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        const params = {
            key: 'A',
            splitPoint: 0.5, // 0.0 a 1.0 (50% pantalla)
            bloomStrength: 1.5,
            sensitivity: 2.0, // Aumentada por defecto
            soundEnabled: true,
            tempo: 100,
            reset: () => resetCanvas()
        };

        // --- TEORÍA MUSICAL ---
        const NOTES = { 'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88 };
        const PENTA_INTERVALS = [0, 3, 5, 7, 10]; 

        function getFrequency(baseFreq, semitones) { return baseFreq * Math.pow(2, semitones / 12); }
        function generateScale(rootKey) {
            const base = NOTES[rootKey]; 
            const scale = [];
            for (let oct = 0; oct < 3; oct++) PENTA_INTERVALS.forEach(i => scale.push(getFrequency(base * Math.pow(2, oct), i)));
            return scale;
        }
        function generateChords(rootKey) {
            const base = NOTES[rootKey] / 4;
            return [
                [getFrequency(base,0), getFrequency(base,3), getFrequency(base,7), getFrequency(base,12)],
                [getFrequency(base,8), getFrequency(base,12), getFrequency(base,15), getFrequency(base,20)],
                [getFrequency(base,10), getFrequency(base,14), getFrequency(base,17), getFrequency(base,22)]
            ];
        }

        let currentScale = generateScale(params.key);
        let currentChords = generateChords(params.key);

        // --- DRUM MACHINE (Sintetizador de Batería) ---
        class DrumMachine {
            constructor(ctx, dest) {
                this.ctx = ctx;
                this.dest = dest;
                this.isPlaying = false;
                this.step = 0;
                this.genreIdx = 0;
                this.genres = ['ROCK', 'BLUES', 'LATIN', 'SWING'];
                this.timerID = null;
                
                // Patrones (16 pasos)
                // K=Kick, S=Snare, H=Hat, -=Silencio
                this.patterns = {
                    'ROCK':  { k: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0], s: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0], h: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1] },
                    'BLUES': { k: [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0], s: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0], h: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0] }, // Shuffle feel simulated
                    'LATIN': { k: [1,0,0,1, 0,0,1,0, 0,0,1,0, 0,1,0,0], s: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0], h: [1,0,1,1, 1,0,1,0, 1,0,1,1, 1,0,1,0] }, // Percussive
                    'SWING': { k: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0], s: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0], h: [1,0,1,0, 0,0,1,0, 1,0,1,0, 0,0,1,0] }
                };
            }

            trigger(type) {
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.dest);

                if (type === 'kick') {
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
                    gain.gain.setValueAtTime(0.8, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
                    osc.start(t); osc.stop(t + 0.5);
                } else if (type === 'snare') {
                    // Ruido simple
                    const bufferSize = this.ctx.sampleRate * 0.1; // 100ms
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const noiseFilter = this.ctx.createBiquadFilter();
                    noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 1000;
                    noise.connect(noiseFilter); noiseFilter.connect(gain);
                    gain.connect(this.dest);
                    
                    gain.gain.setValueAtTime(0.5, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    noise.start(t);
                } else if (type === 'hat') {
                    const bufferSize = this.ctx.sampleRate * 0.05;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const noiseFilter = this.ctx.createBiquadFilter();
                    noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 5000;
                    noise.connect(noiseFilter); noiseFilter.connect(gain);
                    gain.connect(this.dest);
                    gain.gain.setValueAtTime(0.3, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                    noise.start(t);
                }
            }

            nextGenre() {
                this.genreIdx = (this.genreIdx + 1) % (this.genres.length + 1);
                // 0=OFF, 1=Rock, etc
                if(this.genreIdx === 0) { this.stop(); return 'OFF'; }
                const name = this.genres[this.genreIdx - 1];
                if(!this.isPlaying) this.start();
                return name;
            }

            start() {
                if(this.isPlaying) return;
                this.isPlaying = true;
                this.step = 0;
                this.schedule();
            }

            stop() {
                this.isPlaying = false;
                clearTimeout(this.timerID);
            }

            schedule() {
                if(!this.isPlaying) return;
                const secondsPerBeat = 60.0 / params.tempo;
                const stepTime = secondsPerBeat / 4; // 16th notes
                
                const gName = this.genres[this.genreIdx - 1];
                const pat = this.patterns[gName];

                if(pat) {
                    if(pat.k[this.step]) this.trigger('kick');
                    if(pat.s[this.step]) this.trigger('snare');
                    if(pat.h[this.step]) this.trigger('hat');
                }

                this.step = (this.step + 1) % 16;
                this.timerID = setTimeout(() => this.schedule(), stepTime * 1000);
            }
        }

        // --- AUDIO ENGINE PRINCIPAL ---
        class AudioEngine {
            constructor() {
                this.isInit = false;
                this.drums = null;
                this.recorder = null; this.chunks = []; this.loopBuffer = null; this.loopSource = null; this.loopState = 'IDLE';
                this.sustain = false; this.lastChordIdx = -1;
                // Synths
                this.melOsc=null; this.melGain=null;
                this.chordOscs=[]; this.chordGain=null;
            }

            init() {
                if(this.isInit) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                this.master = this.ctx.createGain(); this.master.gain.value = 0.8; this.master.connect(this.ctx.destination);
                this.loopDest = this.ctx.createMediaStreamDestination(); this.master.connect(this.loopDest);

                // Drums
                this.drums = new DrumMachine(this.ctx, this.master);

                // Melodía
                this.melOsc = this.ctx.createOscillator(); this.melOsc.type = 'triangle';
                this.melGain = this.ctx.createGain(); this.melGain.gain.value = 0;
                const d = this.ctx.createDelay(); d.delayTime.value=0.25;
                const df = this.ctx.createGain(); df.gain.value=0.4;
                this.melOsc.connect(this.melGain); this.melGain.connect(this.master);
                this.melGain.connect(d); d.connect(df); df.connect(d); d.connect(this.master);
                this.melOsc.start();

                // Acordes
                this.chordGain = this.ctx.createGain(); this.chordGain.gain.value = 0;
                const cf = this.ctx.createBiquadFilter(); cf.type='lowpass'; cf.frequency.value=800;
                this.chordGain.connect(cf); cf.connect(this.master);
                for(let i=0;i<3;i++) {
                    const o = this.ctx.createOscillator(); o.type='sawtooth'; o.detune.value=(Math.random()-0.5)*10;
                    o.connect(this.chordGain); o.start(); this.chordOscs.push(o);
                }
                this.isInit = true;
            }

            setKey(k) { params.key=k; currentScale=generateScale(k); currentChords=generateChords(k); }

            handleMelody(normX, normY, active) {
                if(!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                if(active) {
                    // normX viene de 0 a 1. Mapeamos a notas
                    const idx = Math.floor(normX * currentScale.length);
                    const safeIdx = Math.min(Math.max(idx, 0), currentScale.length - 1);
                    this.melOsc.frequency.setTargetAtTime(currentScale[safeIdx], t, 0.02);
                    this.melGain.gain.setTargetAtTime(Math.max(0, (1-normY)*0.4), t, 0.05);
                } else {
                    this.melGain.gain.setTargetAtTime(0, t, 0.1);
                }
            }

            handleChords(normX, normY, active) {
                if(!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;
                if(active) {
                    let cIdx = 0; if(normX < 0.33) cIdx = 0; else if(normX < 0.66) cIdx = 1; else cIdx = 2;
                    if(cIdx !== this.lastChordIdx || this.chordGain.gain.value < 0.01) {
                        const chord = currentChords[cIdx];
                        this.chordOscs.forEach((o, i) => { if(chord[i]) o.frequency.setTargetAtTime(chord[i], t, 0.1); });
                        this.lastChordIdx = cIdx;
                    }
                    this.chordGain.gain.setTargetAtTime(Math.max(0, (1-normY)*0.3), t, 0.2);
                } else {
                    if(!this.sustain) this.chordGain.gain.setTargetAtTime(0, t, 0.5);
                    else if(this.chordGain.gain.value < 0.2) this.chordGain.gain.setTargetAtTime(0.2, t, 0.5);
                }
            }

            toggleSustain() {
                this.sustain = !this.sustain;
                document.getElementById('pedal-sustain').classList.toggle('active', this.sustain);
                if(!this.sustain) this.chordGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            }

            cycleRhythm() {
                if(!this.isInit) return;
                const genre = this.drums.nextGenre();
                const p = document.getElementById('pedal-rhythm');
                const label = document.getElementById('label-rhythm');
                if(genre === 'OFF') {
                    p.className = 'pedal';
                    label.innerText = 'RHYTHM';
                } else {
                    p.className = 'pedal rhythm-on';
                    label.innerText = genre;
                }
            }

            // Looper simple
            toggleLoop() {
                if(!this.isInit) return;
                const p = document.getElementById('pedal-loop');
                if(this.loopState === 'IDLE' || this.loopState === 'PLAYING') {
                    this.chunks = []; 
                    if(this.loopSource) { this.loopSource.stop(); this.loopSource = null; }
                    this.recorder = new MediaRecorder(this.loopDest.stream);
                    this.recorder.ondataavailable = e => this.chunks.push(e.data);
                    this.recorder.start();
                    this.loopState = 'RECORDING'; p.className = 'pedal recording';
                } else {
                    this.recorder.stop();
                    this.recorder.onstop = async () => {
                        const b = new Blob(this.chunks, {'type':'audio/ogg; codecs=opus'});
                        this.loopBuffer = await this.ctx.decodeAudioData(await b.arrayBuffer());
                        this.playLoop();
                    };
                    p.className = 'pedal active';
                }
            }
            playLoop() {
                if(!this.loopBuffer) return;
                this.loopSource = this.ctx.createBufferSource();
                this.loopSource.buffer = this.loopBuffer;
                this.loopSource.loop = true;
                this.loopSource.connect(this.master);
                this.loopSource.start();
                this.loopState = 'PLAYING';
            }
            clearLoop() {
                if(this.loopSource) { this.loopSource.stop(); this.loopSource = null; }
                this.loopState = 'IDLE';
                document.getElementById('pedal-loop').className = 'pedal';
            }
        }
        const audio = new AudioEngine();

        // --- VISUALES ---
        const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); camera.position.z = 12;
        const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
        
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        // Partículas & Cintas
        function createTex() {
            const c=document.createElement('canvas'); c.width=32;c.height=32; const x=c.getContext('2d');
            const g=x.createRadialGradient(16,16,0,16,16,16); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)');
            x.fillStyle=g; x.fillRect(0,0,32,32); return new THREE.CanvasTexture(c);
        }
        const tex = createTex();

        class Ribbon {
            constructor() {
                this.pts = Array(20).fill().map(()=>new THREE.Vector3(0,-1000,0));
                this.target = new THREE.Vector3(0,-1000,0);
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(20*6),3));
                this.mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color:0xff00ff, transparent:true, opacity:0.8, side:THREE.DoubleSide, blending:THREE.AdditiveBlending}));
                scene.add(this.mesh);
            }
            update() {
                // Suavizado agresivo para respuesta rápida
                this.pts.shift();
                this.pts.push(this.pts[this.pts.length-1].clone().lerp(this.target, 0.4)); // Más rápido
                
                const curve = new THREE.CatmullRomCurve3(this.pts, false, 'catmullrom', 0.1);
                const p = curve.getPoints(19);
                const pos = this.mesh.geometry.attributes.position.array;
                for(let i=0;i<20;i++){
                    const w = (i/20)*0.5; // Cinta más gruesa
                    pos[i*6]=p[i].x-w; pos[i*6+1]=p[i].y; pos[i*6+2]=p[i].z;
                    pos[i*6+3]=p[i].x+w; pos[i*6+4]=p[i].y; pos[i*6+5]=p[i].z;
                }
                this.mesh.geometry.attributes.position.needsUpdate=true;
                // Ocultar si está muy abajo
                this.mesh.visible = this.target.y > -500;
            }
        }

        class Particles {
            constructor() {
                this.max=50; this.target = new THREE.Vector3(0,-1000,0);
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.max*3),3));
                geo.setAttribute('size', new THREE.BufferAttribute(new Float32Array(this.max),1));
                this.mesh = new THREE.Points(geo, new THREE.PointsMaterial({color:0x00ffff, size:1, map:tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false}));
                scene.add(this.mesh);
                this.parts = Array(this.max).fill().map(()=>({p:new THREE.Vector3(0,-1000,0), v:new THREE.Vector3(), l:0}));
            }
            update() {
                if(this.target.y > -500 && Math.random()>0.2) {
                    const p = this.parts.find(x=>x.l<=0);
                    if(p) {
                        p.l=1; p.p.copy(this.target);
                        p.v.set((Math.random()-0.5)*0.2, 0.05, (Math.random()-0.5)*0.2);
                    }
                }
                const pos = this.mesh.geometry.attributes.position.array;
                const s = this.mesh.geometry.attributes.size.array;
                this.parts.forEach((p,i)=>{
                    if(p.l>0) {
                        p.l-=0.02; p.p.add(p.v);
                        pos[i*3]=p.p.x; pos[i*3+1]=p.p.y; pos[i*3+2]=p.p.z;
                        s[i]=p.l*2;
                    } else s[i]=0;
                });
                this.mesh.geometry.attributes.position.needsUpdate=true;
                this.mesh.geometry.attributes.size.needsUpdate=true;
            }
        }

        const ribbons = Array(10).fill().map(()=>new Ribbon());
        const clouds = Array(10).fill().map(()=>new Particles());
        function resetCanvas() { ribbons.forEach(r=>r.target.set(0,-1000,0)); clouds.forEach(c=>c.target.set(0,-1000,0)); }

        // --- CORE LOGIC ---
        const video = document.createElement('video');
        let visibleWidth=10, visibleHeight=10;

        function onResults(res) {
            document.getElementById('loading').style.display='none';
            let melActive=false, chordActive=false;

            if(res.multiHandLandmarks) {
                res.multiHandLandmarks.forEach((lm, hIdx) => {
                    if(hIdx > 1) return;
                    
                    // LÓGICA DE ESPEJO Y DIVISIÓN
                    // MediaPipe rawX: 0(Izq) -> 1(Der)
                    // Visualmente en espejo: rawX > splitPoint es IZQUIERDA, rawX < splitPoint es DERECHA
                    // Esto es confuso, simplifiquemos:
                    // Si el slider está al 50% (0.5), el divisor está en medio.
                    // Si yo muevo mi mano a la derecha visual (melodía), MediaPipe me da valores BAJOS (ej 0.2).
                    // Si muevo mi mano a la izquierda visual (acordes), MediaPipe me da valores ALTOS (ej 0.8).
                    // Pero ojo: params.splitPoint es un valor de 0 a 1 visual (izquierda a derecha).
                    // El "corte" en rawX es (1.0 - params.splitPoint).
                    
                    const rawX = lm[8].x;
                    const splitThreshold = 1.0 - params.splitPoint;
                    
                    const isVisualLeft = rawX > splitThreshold; // Zona Acordes

                    [4,8,12,16,20].forEach((fid,i)=>{
                        const t = lm[fid];
                        const x = (t.x - 0.5) * -visibleWidth * params.sensitivity; // Expandido
                        const y = (t.y - 0.5) * -visibleHeight * params.sensitivity;
                        const z = -t.z * 20;
                        const idx = hIdx*5+i;

                        if(isVisualLeft) {
                            clouds[idx].target.set(x,y,z); ribbons[idx].target.set(0,-1000,0);
                        } else {
                            ribbons[idx].target.set(x,y,z); clouds[idx].target.set(0,-1000,0);
                        }
                    });

                    // AUDIO MAPEO
                    if(isVisualLeft) {
                        chordActive = true;
                        // Mapear rawX (1.0 a threshold) -> 0 a 1
                        // rawX va de 1.0 (borde izq visual) a threshold (centro)
                        const range = 1.0 - splitThreshold;
                        const norm = (rawX - splitThreshold) / range; // 0 (centro) a 1 (borde)
                        // Invertimos para que acorde 1 esté al centro o al borde?
                        // Mejor: Borde Izq = Acorde 1, Centro = Acorde 3
                        // norm va de 0 a 1.
                        audio.handleChords(1.0 - norm, lm[8].y, true); 
                    } else {
                        melActive = true;
                        // Mapear rawX (threshold a 0) -> 0 a 1
                        const range = splitThreshold;
                        const norm = (splitThreshold - rawX) / range; // 0 (centro) a 1 (borde derecho)
                        audio.handleMelody(norm, lm[8].y, true);
                    }
                });
            }
            if(!melActive) audio.handleMelody(0,0,false);
            if(!chordActive) audio.handleChords(0,0,false);
        }

        const hands = new Hands({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.5});
        hands.onResults(onResults);
        const cam = new Camera(video, {onFrame:async()=>{await hands.send({image:video})}, width:1280, height:720});
        cam.start();

        // --- UI & LOOP ---
        function updateDivider() {
            const pct = params.splitPoint * 100;
            document.getElementById('screen-divider').style.left = pct + '%';
            document.getElementById('label-left').style.left = (pct / 2) + '%';
            document.getElementById('label-right').style.right = ((100-pct) / 2) + '%';
        }

        const gui = new GUI({title:'CONTROL PANEL'});
        gui.add(params, 'splitPoint', 0.2, 0.8).name('Calibrar Mitad').onChange(updateDivider);
        gui.add(params, 'sensitivity', 1.0, 3.0).name('Sensibilidad');
        gui.add(params, 'tempo', 60, 180).name('Tempo BPM');
        gui.add(params, 'key', Object.keys(NOTES)).onChange(k=>audio.setKey(k));

        window.addEventListener('resize', ()=>{
            camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            const fov = camera.fov * Math.PI/180;
            visibleHeight = 2 * Math.tan(fov/2) * camera.position.z; visibleWidth = visibleHeight * camera.aspect;
        });
        const fov = camera.fov * Math.PI/180; visibleHeight = 2 * Math.tan(fov/2) * camera.position.z; visibleWidth = visibleHeight * camera.aspect;

        window.addEventListener('keydown', e=>{
            if(e.code==='Space') audio.toggleLoop();
            if(e.key.toLowerCase()==='d') audio.cycleRhythm();
            if(e.key.toLowerCase()==='s') audio.toggleSustain();
            if(e.key.toLowerCase()==='x') audio.clearLoop();
        });
        document.getElementById('pedal-sustain').onclick=()=>audio.toggleSustain();
        document.getElementById('pedal-loop').onclick=()=>audio.toggleLoop();
        document.getElementById('pedal-clear').onclick=()=>audio.clearLoop();
        document.getElementById('pedal-rhythm').onclick=()=>audio.cycleRhythm();
        window.addEventListener('click', ()=>{ if(!audio.isInit) audio.init(); if(audio.ctx.state==='suspended') audio.ctx.resume(); });

        function animate() {
            requestAnimationFrame(animate);
            ribbons.forEach(r=>r.update());
            clouds.forEach(c=>c.update());
            composer.render();
        }
        animate();
    </script>

    <div id="loading">SISTEMA FULL BAND CARGADO<br>Calibrado y con Ritmos</div>
    
    <div id="ui-layer">
        <div id="screen-divider"></div>
        <div id="label-left" class="zone-label" style="color:rgba(0,255,255,0.5)">PADS</div>
        <div id="label-right" class="zone-label" style="color:rgba(255,0,255,0.5)">LEAD</div>
    </div>

    <div id="pedalboard">
        <div id="pedal-sustain" class="pedal">
            <div class="pedal-light"></div>
            <div class="pedal-label">Sustain</div>
            <div class="pedal-key">[ S ]</div>
        </div>
        <div id="pedal-loop" class="pedal">
            <div class="pedal-light"></div>
            <div class="pedal-label">Looper</div>
            <div class="pedal-key">[ SPACE ]</div>
        </div>
        <div id="pedal-clear" class="pedal">
            <div class="pedal-light" style="background:#555"></div>
            <div class="pedal-label">Clear</div>
            <div class="pedal-key">[ X ]</div>
        </div>
        <div id="pedal-rhythm" class="pedal">
            <div class="pedal-light"></div>
            <div id="label-rhythm" class="pedal-label">RHYTHM</div>
            <div class="pedal-key">[ D ]</div>
        </div>
    </div>
</body>
</html>
