<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Ultimate VJ Station 2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', monospace; }
        
        #overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            transition: opacity 0.5s ease; text-align: center;
        }

        .keys-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            color: #888; margin-top: 30px; text-align: left; font-size: 14px;
        }
        .key { color: #0ff; font-weight: bold; border: 1px solid #0ff; padding: 2px 6px; border-radius: 4px;}
        
        button#start-btn {
            padding: 20px 60px; font-size: 24px; color: #0ff; background: transparent;
            border: 2px solid #0ff; border-radius: 5px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0,255,255,0.2); text-transform: uppercase; letter-spacing: 4px;
            margin-bottom: 20px; transition: all 0.2s;
        }
        button#start-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 60px rgba(0,255,255,1); }

        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; text-shadow: 0 0 5px #000; pointer-events: none;
        }
        .hud-line { margin-bottom: 5px; font-size: 12px; opacity: 0.8; }
        .hud-value { color: #0ff; font-weight: bold; }

        #file-input { display: none; }
        
        #notification {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 1px solid #0ff; color: #0ff;
            padding: 10px 30px; border-radius: 20px; font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 15;
        }
    </style>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- ESTADO GLOBAL ---
        const state = {
            effectMode: 1, // 1-10 (Deformaciones)
            styleMode: 0,  // 0:Normal, 1:Malla, 2:Puntos, 3:Hex, 4:Hologram, 5:Binary
            mixRatio: 0.0, // 0 = Video, 1 = Cam
            distortion: 2.0,
            micGain: 5.0,
            bloom: 1.5,
            tint: new THREE.Color(1, 1, 1),
            tintMix: 0.0, 
            activeSlot: null,
            loadingSlot: null
        };

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() { this.ctx = null; this.analyser = null; this.data = null; this.freq = null; this.ready = false; }
            async init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, autoGainControl: false } });
                    this.analyser = this.ctx.createAnalyser(); this.analyser.fftSize = 512;
                    this.ctx.createMediaStreamSource(stream).connect(this.analyser);
                    this.data = new Uint8Array(this.analyser.frequencyBinCount);
                    this.freq = new Uint8Array(this.analyser.frequencyBinCount);
                    this.ready = true; return true;
                } catch(e) { console.error(e); return false; }
            }
            getLevels() {
                if(!this.ready) return { vol: 0, bass: 0, high: 0 };
                this.analyser.getByteTimeDomainData(this.data);
                this.analyser.getByteFrequencyData(this.freq);
                let sum=0; for(let i=0;i<this.data.length;i++){ const v=(this.data[i]-128)/128; sum+=v*v; }
                const vol = Math.sqrt(sum/this.data.length) * state.micGain;
                const bass = this.freq[5] / 255.0;
                const high = this.freq[200] / 255.0;
                return { vol, bass, high };
            }
        }
        const audio = new AudioEngine();

        // --- SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 9;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- TEXTURES ---
        const videoSlots = { 'g': null, 'h': null, 'j': null, 'k': null, 'l': null };
        const activeVideoTex = new THREE.VideoTexture(document.createElement('video')); 
        const webcamEl = document.createElement('video');
        webcamEl.muted = true; webcamEl.playsInline = true;
        const webcamTex = new THREE.VideoTexture(webcamEl);

        function createNoise() {
            const c=document.createElement('canvas'); c.width=64; c.height=64;
            const x=c.getContext('2d'); x.fillStyle='#111'; x.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const noiseTex = createNoise();

        // --- SHADER UNIFORMS ---
        const uniforms = {
            uTexVideo: { value: noiseTex },
            uTexCam: { value: noiseTex },
            uMix: { value: 0.0 },
            uTime: { value: 0.0 },
            uBass: { value: 0.0 },
            uHigh: { value: 0.0 },
            uVol: { value: 0.0 },
            uMode: { value: 1 },    // Deformaciones
            uStyle: { value: 0 },   // NUEVO: Estilos Geométricos
            uTint: { value: new THREE.Color(1,1,1) },
            uTintMix: { value: 0.0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        const fragmentShader = `
            uniform sampler2D uTexVideo;
            uniform sampler2D uTexCam;
            uniform float uMix;
            uniform float uTime;
            uniform float uBass;
            uniform float uHigh;
            uniform float uVol;
            uniform int uMode;
            uniform int uStyle; // NUEVO
            uniform vec3 uTint;
            uniform float uTintMix;
            uniform vec2 uResolution;
            varying vec2 vUv;

            // Utils
            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            
            vec3 rgbSplit(sampler2D tex, vec2 uv, float amount) {
                float r = texture2D(tex, uv - vec2(amount, 0.0)).r;
                float g = texture2D(tex, uv).g;
                float b = texture2D(tex, uv + vec2(amount, 0.0)).b;
                return vec3(r,g,b);
            }

            // Funciones Geométricas
            float grid(vec2 uv, float size, float thickness) {
                vec2 grid = fract(uv * size);
                return step(thickness, grid.x) * step(thickness, grid.y);
            }

            float dots(vec2 uv, float size, float radius) {
                vec2 grid = fract(uv * size) - 0.5;
                return 1.0 - step(radius, length(grid));
            }

            void main() {
                vec2 uv = vUv;
                
                // --- 1. DEFORMACIONES DE COORDENADAS (uMode 1-10) ---
                
                // 3: Mirror X
                if(uMode == 3) uv.x = abs(uv.x - 0.5) + 0.5;
                
                // 4: Kaleidoscope
                if(uMode == 4) {
                    vec2 centered = uv - 0.5;
                    float r = length(centered);
                    float a = atan(centered.y, centered.x);
                    float sides = 6.0;
                    a = mod(a, 3.14159 * 2.0 / sides);
                    a = abs(a - 3.14159 / sides);
                    uv = 0.5 + r * vec2(cos(a), sin(a));
                }

                // 5: Twist
                if(uMode == 5) {
                    float dist = length(uv - 0.5);
                    float angle = atan(uv.y-0.5, uv.x-0.5) + (uBass*5.0) * (1.0-dist);
                    uv = 0.5 + dist * vec2(cos(angle), sin(angle));
                }

                // 9: Liquid Wave
                if(uMode == 9) {
                    uv.x += sin(uv.y * 10.0 + uTime) * 0.05 * uVol;
                    uv.y += cos(uv.x * 10.0 + uTime) * 0.05 * uVol;
                }

                // --- 2. SAMPLING COLOR ---
                vec3 colorVid = texture2D(uTexVideo, uv).rgb;
                vec3 colorCam = texture2D(uTexCam, uv).rgb;

                // 2: RGB Split
                if(uMode == 2) {
                    colorVid = rgbSplit(uTexVideo, uv, uBass * 0.05);
                    colorCam = rgbSplit(uTexCam, uv, uBass * 0.05);
                }

                // Mezcla Camara/Video
                vec3 color = mix(colorVid, colorCam, uMix);

                // --- 3. EFECTOS DE COLOR (uMode) ---
                
                // 7: Invert Flash
                if(uMode == 7 && uBass > 0.6) color = 1.0 - color;

                // 8: Neon Edge
                if(uMode == 8) {
                    vec3 c1 = texture2D(uTexVideo, uv + vec2(0.002, 0.0)).rgb;
                    vec3 c2 = texture2D(uTexVideo, uv - vec2(0.002, 0.0)).rgb;
                    vec3 c3 = texture2D(uTexVideo, uv + vec2(0.0, 0.002)).rgb;
                    vec3 c4 = texture2D(uTexVideo, uv - vec2(0.0, 0.002)).rgb;
                    vec3 edge = abs(color - c1) + abs(color - c2) + abs(color - c3) + abs(color - c4);
                    color = edge * 2.0; 
                }

                // 10: Glitch Blocks
                if(uMode == 10) {
                    vec2 block = floor(uv * 10.0);
                    float n = rand(block + floor(uTime * 10.0));
                    if(n < uBass * 0.5) color = vec3(1.0);
                }
                
                // 1: Scanlines Clásicas
                if(uMode == 1) {
                    float scan = sin(uv.y * 800.0 + uTime * 5.0) * 0.5 + 0.5;
                    color *= (0.8 + 0.2 * scan);
                }

                // --- 4. NUEVOS ESTILOS GEOMÉTRICOS (uStyle Z-B) ---
                
                float luminance = dot(color, vec3(0.299, 0.587, 0.114));

                // Z: MALLA DIGITAL (Wireframe Grid)
                if (uStyle == 1) {
                    float gridSize = 40.0;
                    vec2 g = fract(uv * gridSize + uTime * 0.5);
                    // Líneas finas
                    float lines = step(0.9, g.x) + step(0.9, g.y);
                    // El color se muestra solo en las líneas
                    color = color * lines * 2.0;
                    // Fondo negro sutil
                    color += vec3(0.05, 0.0, 0.1); 
                }

                // X: NUBE DE PUNTOS (LED Matrix)
                if (uStyle == 2) {
                    float dotSize = 80.0;
                    vec2 st = fract(uv * dotSize);
                    vec2 center = vec2(0.5);
                    float d = distance(st, center);
                    // El tamaño del punto depende del brillo de la imagen
                    float radius = luminance * 0.5; 
                    float mask = step(d, radius);
                    color = color * mask * 1.5;
                }

                // C: HEXAGRID / PANAL
                if (uStyle == 3) {
                    vec2 r = vec2(uv.x * 30.0, uv.y * 17.32); // Proporción hex
                    vec2 h = r + vec2(0.5 * mod(floor(r.y), 2.0), 0.0);
                    vec2 f = fract(h) - 0.5;
                    float l = length(f);
                    // Borde hexagonal brillante
                    float hex = step(l, 0.45) - step(l, 0.4);
                    color = color * 0.2 + vec3(hex) * color * 3.0;
                }

                // V: HOLOGRAM INTERFERENCE
                if (uStyle == 4) {
                    float bar = step(0.5, sin(uv.y * 200.0 + uTime * 10.0));
                    float noise = rand(uv * uTime) * 0.3;
                    vec3 holoColor = vec3(0.0, 1.0, 0.8) * luminance;
                    color = mix(color, holoColor, 0.8) * bar + noise;
                }

                // B: BINARY RAIN / ASCII SIMULATION
                if (uStyle == 5) {
                    vec2 block = floor(uv * vec2(40.0, 20.0));
                    float fall = mod(block.y + uTime * 10.0, 20.0);
                    float trail = 1.0 - (fall / 20.0);
                    float symbol = step(0.5, rand(block + floor(uTime)));
                    color = vec3(0.0, 1.0, 0.2) * symbol * trail * luminance * 2.0;
                }

                // TINTING FINAL
                color = mix(color, color * uTint, uTintMix);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const vertexShader = `
            uniform float uVol;
            uniform float uBass;
            uniform float uTime;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec3 pos = position;
                // Deformación Z básica
                float noise = sin(pos.x * 2.0 + uTime) * cos(pos.y * 1.5 + uTime);
                pos.z += noise * uVol * 3.0;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms, vertexShader, fragmentShader, side: THREE.DoubleSide
        });

        const geometry = new THREE.PlaneGeometry(16, 9, 100, 100);
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloom);

        // --- TECLADO ---
        const fileInput = document.getElementById('file-input');
        
        const colors = {
            'q': [1, 0, 0], 'w': [0, 1, 0], 'e': [0, 0, 1],
            'r': [0, 1, 1], 't': [1, 0, 1], 'y': [1, 1, 0]
        };

        const hudMode = document.getElementById('hud-mode');
        const hudStyle = document.getElementById('hud-style');
        const hudSlot = document.getElementById('hud-slot');
        const hudColor = document.getElementById('hud-color');
        
        function showNotify(msg) {
            const n = document.getElementById('notification');
            n.innerText = msg; n.style.opacity = 1;
            setTimeout(() => n.style.opacity = 0, 2000);
        }

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // 1. Efectos Base (1-0)
            if(!isNaN(parseInt(key))) {
                let mode = parseInt(key);
                if(mode === 0) mode = 10;
                state.effectMode = mode;
                showNotify(`DEFORMACIÓN: ${mode}`);
                hudMode.innerText = mode;
            }

            // 2. Colores (Q-Y)
            if(colors[key]) {
                state.tint.setRGB(...colors[key]);
                state.tintMix = 1.0;
                showNotify(`TINT: ${key.toUpperCase()}`);
                hudColor.innerText = key.toUpperCase();
                hudColor.style.color = `rgb(${colors[key][0]*255},${colors[key][1]*255},${colors[key][2]*255})`;
            }
            if(key === 'u') {
                state.tintMix = 0.0;
                showNotify("TINT: OFF");
                hudColor.innerText = "OFF";
                hudColor.style.color = "#fff";
            }

            // 3. NUEVOS ESTILOS GEOMÉTRICOS (Z-B)
            const styleMap = { 'z': 1, 'x': 2, 'c': 3, 'v': 4, 'b': 5 };
            if(styleMap[key]) {
                state.styleMode = styleMap[key];
                const names = ["", "MALLA", "PUNTOS", "HEX", "HOLO", "BINARY"];
                showNotify(`ESTILO: ${names[state.styleMode]}`);
                hudStyle.innerText = names[state.styleMode];
            }
            // M: RESET ESTILO
            if(key === 'm') {
                state.styleMode = 0;
                showNotify("ESTILO: NORMAL");
                hudStyle.innerText = "NORMAL";
            }

            // 4. Video Slots (G-L)
            if (['g','h','j','k','l'].includes(key)) {
                if (!videoSlots[key]) {
                    state.loadingSlot = key;
                    fileInput.click();
                } else {
                    if(state.activeSlot && videoSlots[state.activeSlot]) videoSlots[state.activeSlot].pause();
                    state.activeSlot = key;
                    const vid = videoSlots[key];
                    vid.play();
                    activeVideoTex.image = vid; 
                    activeVideoTex.needsUpdate = true;
                    uniforms.uTexVideo.value = activeVideoTex;
                    showNotify(`SLOT ${key.toUpperCase()}: PLAY`);
                    hudSlot.innerText = key.toUpperCase();
                }
            }

            // 5. Doble Exposición (Ahora en N)
            if(key === 'n') {
                state.mixRatio = (state.mixRatio > 0.1) ? 0.0 : 0.5;
                showNotify(state.mixRatio > 0 ? "CAM MIX: ON" : "CAM MIX: OFF");
                if(state.mixRatio > 0 && !webcamEl.srcObject) initWebcam();
            }
        });

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if(!file || !state.loadingSlot) return;
            const url = URL.createObjectURL(file);
            const vid = document.createElement('video');
            vid.src = url; vid.loop = true; vid.muted = true; vid.playsInline = true;
            videoSlots[state.loadingSlot] = vid;
            showNotify(`CARGADO EN ${state.loadingSlot.toUpperCase()}`);
            const key = state.loadingSlot;
            state.activeSlot = key;
            vid.play();
            activeVideoTex.image = vid;
            uniforms.uTexVideo.value = activeVideoTex;
            hudSlot.innerText = key.toUpperCase();
            state.loadingSlot = null;
            fileInput.value = ""; 
        };

        async function initWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                webcamEl.srcObject = stream;
                webcamEl.play();
                uniforms.uTexCam.value = webcamTex;
            } catch(e) { console.error("No cam"); }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            const lvls = audio.getLevels();

            uniforms.uTime.value = time;
            uniforms.uVol.value = lvls.vol;
            uniforms.uBass.value = lvls.bass;
            uniforms.uHigh.value = lvls.high;
            uniforms.uMix.value = state.mixRatio;
            uniforms.uMode.value = state.effectMode;
            uniforms.uStyle.value = state.styleMode; // Enviar estilo al shader
            uniforms.uTint.value = state.tint;
            uniforms.uTintMix.value = state.tintMix;

            bloom.strength = state.bloom + (lvls.vol * 1.5);
            
            if(lvls.bass > 0.5) {
                plane.rotation.z = (Math.random()-0.5)*0.05;
                plane.scale.setScalar(1.0 + lvls.bass*0.05);
            } else {
                plane.rotation.z *= 0.9;
                plane.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
            }

            if(activeVideoTex.image && activeVideoTex.image.readyState === activeVideoTex.image.HAVE_ENOUGH_DATA) 
                activeVideoTex.needsUpdate = true;
            if(webcamTex.image && webcamTex.image.readyState === webcamTex.image.HAVE_ENOUGH_DATA) 
                webcamTex.needsUpdate = true;

            composer.render();
        }

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        };

        document.getElementById('start-btn').onclick = async () => {
            if(await audio.init()) {
                document.getElementById('overlay').style.opacity = 0;
                setTimeout(()=>document.getElementById('overlay').style.display='none', 500);
                animate();
            }
        };

        const gui = new GUI({ title: 'Ajustes Finos' });
        gui.add(state, 'distortion', 0, 5).name('Fuerza Glitch');
        gui.add(state, 'micGain', 1, 10).name('Sensibilidad Mic');
        gui.add(state, 'bloom', 0, 3).name('Brillo Base');
    </script>
</head>
<body>
    <div id="overlay">
        <h1 style="color:#0ff; text-shadow:0 0 10px #0ff; margin-bottom: 40px;">ULTIMATE VJ STATION 2.0</h1>
        <button id="start-btn">INICIAR SISTEMA</button>
        
        <div class="keys-grid">
            <div>
                <span class="key">1-0</span> DEFORMACIÓN<br>
                Modifican la forma<br>
                (Kaleido, Twist, etc.)
            </div>
            <div>
                <span class="key">Z-B</span> ESTILOS GEO<br>
                Z: Malla (Wireframe)<br>
                X: Puntos (LED)<br>
                C: Hexágonos<br>
                V: Holograma<br>
                B: Binary Rain<br>
                <span class="key">M</span> Normal (Reset)
            </div>
            <div>
                <span class="key">G-L</span> CLIPS<br>
                <span class="key">N</span> CAM MIX (ON/OFF)<br>
                <span class="key">Q-Y</span> TINTES
            </div>
        </div>
    </div>

    <div id="hud">
        <div class="hud-line">DEFORMACIÓN: <span id="hud-mode" class="hud-value">1</span></div>
        <div class="hud-line">ESTILO: <span id="hud-style" class="hud-value">NORMAL</span></div>
        <div class="hud-line">COLOR: <span id="hud-color" class="hud-value" style="color:#fff">OFF</span></div>
        <div class="hud-line">SLOT: <span id="hud-slot" class="hud-value">NONE</span></div>
    </div>

    <div id="notification">NOTIFICACIÓN</div>
    <input type="file" id="file-input" accept="video/*">
</body>
</html>
