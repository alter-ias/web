<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Infinite VJ Loop</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', monospace; }
        
        #overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            transition: opacity 0.5s ease; text-align: center;
        }

        .keys-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            color: #888; margin-top: 30px; text-align: left; font-size: 14px;
        }
        .key { color: #0ff; font-weight: bold; border: 1px solid #0ff; padding: 2px 6px; border-radius: 4px;}
        
        button#start-btn {
            padding: 20px 60px; font-size: 24px; color: #0ff; background: transparent;
            border: 2px solid #0ff; border-radius: 5px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0,255,255,0.2); text-transform: uppercase; letter-spacing: 4px;
            margin-bottom: 20px; transition: all 0.2s;
        }
        button#start-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 60px rgba(0,255,255,1); }

        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; text-shadow: 0 0 5px #000; pointer-events: none;
        }
        .hud-line { margin-bottom: 5px; font-size: 12px; opacity: 0.8; }
        .hud-value { color: #0ff; font-weight: bold; }

        /* Barra de progreso del Fader */
        #fader-bar {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 10px; background: #333; border: 1px solid #555;
            border-radius: 5px; overflow: hidden; z-index: 10;
        }
        #fader-fill {
            width: 0%; height: 100%; background: linear-gradient(90deg, #00f, #0ff);
            transition: width 0.1s linear;
        }

        #file-input { display: none; }
        
        #notification {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 1px solid #0ff; color: #0ff;
            padding: 10px 30px; border-radius: 20px; font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 15;
        }
    </style>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- ESTADO GLOBAL ---
        const state = {
            effectMode: 1, 
            styleMode: 0,
            mixRatio: 0.0, // Cam Mix
            distortion: 2.0,
            micGain: 5.0,
            bloom: 1.5,
            tint: new THREE.Color(1, 1, 1),
            tintMix: 0.0, 
            loadingSlot: null,
            // LOGICA DE MEZCLA
            crossfade: 0.0, // 0.0 (Video A) -> 1.0 (Video B)
            slotCurrent: null, // Video Actual (Visible)
            slotNext: null     // Video Siguiente (En espera)
        };

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() { this.ctx = null; this.analyser = null; this.data = null; this.freq = null; this.ready = false; }
            async init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, autoGainControl: false } });
                    this.analyser = this.ctx.createAnalyser(); this.analyser.fftSize = 512;
                    this.ctx.createMediaStreamSource(stream).connect(this.analyser);
                    this.data = new Uint8Array(this.analyser.frequencyBinCount);
                    this.freq = new Uint8Array(this.analyser.frequencyBinCount);
                    this.ready = true; return true;
                } catch(e) { console.error(e); return false; }
            }
            getLevels() {
                if(!this.ready) return { vol: 0, bass: 0, high: 0 };
                this.analyser.getByteTimeDomainData(this.data);
                this.analyser.getByteFrequencyData(this.freq);
                let sum=0; for(let i=0;i<this.data.length;i++){ const v=(this.data[i]-128)/128; sum+=v*v; }
                const vol = Math.sqrt(sum/this.data.length) * state.micGain;
                const bass = this.freq[5] / 255.0;
                const high = this.freq[200] / 255.0;
                return { vol, bass, high };
            }
        }
        const audio = new AudioEngine();

        // --- SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 9;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- TEXTURES ---
        // Lista expandida de slots (A-L)
        const videoSlots = { 
            'a': null, 's': null, 'd': null, 'f': null,
            'g': null, 'h': null, 'j': null, 'k': null, 'l': null 
        };

        // Texturas "A" y "B" para el crossfader
        const texA = new THREE.VideoTexture(document.createElement('video'));
        const texB = new THREE.VideoTexture(document.createElement('video'));
        
        // Webcam
        const webcamEl = document.createElement('video');
        webcamEl.muted = true; webcamEl.playsInline = true;
        const webcamTex = new THREE.VideoTexture(webcamEl);

        function createNoise() {
            const c=document.createElement('canvas'); c.width=64; c.height=64;
            const x=c.getContext('2d'); x.fillStyle='#111'; x.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const noiseTex = createNoise();
        
        // Inicializar texturas con ruido
        texA.image = noiseTex.image;
        texB.image = noiseTex.image;

        // --- SHADER ---
        const uniforms = {
            uTexA: { value: noiseTex }, // Video Actual
            uTexB: { value: noiseTex }, // Video Siguiente
            uCrossfade: { value: 0.0 }, // Mezcla
            uTexCam: { value: noiseTex },
            uMix: { value: 0.0 },
            uTime: { value: 0.0 },
            uBass: { value: 0.0 },
            uHigh: { value: 0.0 },
            uVol: { value: 0.0 },
            uMode: { value: 1 },
            uStyle: { value: 0 },
            uTint: { value: new THREE.Color(1,1,1) },
            uTintMix: { value: 0.0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        const fragmentShader = `
            uniform sampler2D uTexA;
            uniform sampler2D uTexB;
            uniform float uCrossfade;
            uniform sampler2D uTexCam;
            uniform float uMix;
            uniform float uTime;
            uniform float uBass;
            uniform float uHigh;
            uniform float uVol;
            uniform int uMode;
            uniform int uStyle;
            uniform vec3 uTint;
            uniform float uTintMix;
            varying vec2 vUv;

            // Utils
            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            
            vec3 rgbSplit(sampler2D tex, vec2 uv, float amount) {
                float r = texture2D(tex, uv - vec2(amount, 0.0)).r;
                float g = texture2D(tex, uv).g;
                float b = texture2D(tex, uv + vec2(amount, 0.0)).b;
                return vec3(r,g,b);
            }

            void main() {
                vec2 uv = vUv;
                
                // --- 1. DEFORMACIONES ---
                if(uMode == 3) uv.x = abs(uv.x - 0.5) + 0.5;
                if(uMode == 4) {
                    vec2 centered = uv - 0.5;
                    float r = length(centered);
                    float a = atan(centered.y, centered.x);
                    float sides = 6.0;
                    a = mod(a, 3.14159 * 2.0 / sides);
                    a = abs(a - 3.14159 / sides);
                    uv = 0.5 + r * vec2(cos(a), sin(a));
                }
                if(uMode == 5) {
                    float dist = length(uv - 0.5);
                    float angle = atan(uv.y-0.5, uv.x-0.5) + (uBass*5.0) * (1.0-dist);
                    uv = 0.5 + dist * vec2(cos(angle), sin(angle));
                }
                if(uMode == 9) {
                    uv.x += sin(uv.y * 10.0 + uTime) * 0.05 * uVol;
                    uv.y += cos(uv.x * 10.0 + uTime) * 0.05 * uVol;
                }

                // --- 2. SAMPLING & CROSSFADE ---
                vec3 colorA, colorB;

                // Aplicar efectos de lectura (RGB Split) a ambos canales
                if(uMode == 2) {
                    colorA = rgbSplit(uTexA, uv, uBass * 0.05);
                    colorB = rgbSplit(uTexB, uv, uBass * 0.05);
                } else {
                    colorA = texture2D(uTexA, uv).rgb;
                    colorB = texture2D(uTexB, uv).rgb;
                }

                // MEZCLA DE VIDEOS (Crossfade)
                vec3 colorVid = mix(colorA, colorB, uCrossfade);

                // Mezcla con Webcam
                vec3 colorCam = texture2D(uTexCam, uv).rgb;
                if(uMode == 2) colorCam = rgbSplit(uTexCam, uv, uBass * 0.05);
                
                vec3 color = mix(colorVid, colorCam, uMix);

                // --- 3. EFECTOS DE COLOR ---
                if(uMode == 7 && uBass > 0.6) color = 1.0 - color;
                if(uMode == 8) {
                    // Edge simple en base al color mezclado
                    vec3 c1 = mix(texture2D(uTexA, uv+0.002).rgb, texture2D(uTexB, uv+0.002).rgb, uCrossfade);
                    vec3 edge = abs(color - c1); 
                    color = length(edge) * vec3(0.0, 1.0, 1.0) * 4.0; 
                }
                if(uMode == 10) {
                    vec2 block = floor(uv * 10.0);
                    if(rand(block + floor(uTime * 10.0)) < uBass * 0.5) color = vec3(1.0);
                }
                if(uMode == 1) {
                    float scan = sin(uv.y * 800.0 + uTime * 5.0) * 0.5 + 0.5;
                    color *= (0.8 + 0.2 * scan);
                }

                // --- 4. ESTILOS GEOMÉTRICOS ---
                float lum = dot(color, vec3(0.33));
                if (uStyle == 1) { // Malla
                    vec2 g = fract(uv * 40.0 + uTime * 0.5);
                    color = color * (step(0.9, g.x) + step(0.9, g.y)) * 2.0;
                }
                if (uStyle == 2) { // Puntos
                    float d = distance(fract(uv * 80.0), vec2(0.5));
                    color = color * step(d, lum * 0.5) * 1.5;
                }
                if (uStyle == 3) { // Hex
                     // Simplificado para brevedad
                     color = color * (sin(uv.x*50.0)*sin(uv.y*50.0) > 0.0 ? 1.5 : 0.2);
                }
                if (uStyle == 4) { // Holo
                    float bar = step(0.5, sin(uv.y * 200.0 + uTime * 10.0));
                    color = mix(color, vec3(0.0, 1.0, 0.8) * lum, 0.8) * bar;
                }
                if (uStyle == 5) { // Binary
                    vec2 blk = floor(uv * vec2(40.0, 20.0));
                    float rain = step(0.5, rand(blk + floor(uTime)));
                    color = vec3(0.0, 1.0, 0.2) * rain * lum * 2.0;
                }

                color = mix(color, color * uTint, uTintMix);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        const vertexShader = `
            uniform float uVol;
            uniform float uBass;
            uniform float uTime;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                vec3 pos = position;
                float noise = sin(pos.x * 2.0 + uTime) * cos(pos.y * 1.5 + uTime);
                pos.z += noise * uVol * 3.0;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms, vertexShader, fragmentShader, side: THREE.DoubleSide
        });

        const geometry = new THREE.PlaneGeometry(16, 9, 100, 100);
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloom);

        // --- INPUTS ---
        const fileInput = document.getElementById('file-input');
        const hudMode = document.getElementById('hud-mode');
        const hudStyle = document.getElementById('hud-style');
        const hudSlot = document.getElementById('hud-slot');
        const hudNext = document.getElementById('hud-next'); // Nuevo HUD
        const hudColor = document.getElementById('hud-color');
        const faderFill = document.getElementById('fader-fill');

        const colors = { 'q': [1,0,0], 'w': [0,1,0], 'e': [0,0,1], 'r': [0,1,1], 't': [1,0,1], 'y': [1,1,0] };
        const styleMap = { 'z': 1, 'x': 2, 'c': 3, 'v': 4, 'b': 5 };

        function showNotify(msg) {
            const n = document.getElementById('notification');
            n.innerText = msg; n.style.opacity = 1;
            setTimeout(() => n.style.opacity = 0, 2000);
        }

        // --- GESTIÓN DE SCROLL (CROSSFADER) ---
        window.addEventListener('wheel', (e) => {
            // Si no hay video siguiente seleccionado, el scroll no hace nada
            if (!state.slotNext || !videoSlots[state.slotNext]) return;

            const delta = e.deltaY * 0.001; // Sensibilidad
            state.crossfade += delta; 
            
            // Clamp 0-1
            state.crossfade = Math.max(0.0, Math.min(1.0, state.crossfade));
            
            // Actualizar UI Fader
            faderFill.style.width = (state.crossfade * 100) + '%';

            // Logica de TRANSICIÓN COMPLETA
            if (state.crossfade >= 1.0) {
                // El siguiente pasa a ser el actual
                state.slotCurrent = state.slotNext;
                state.slotNext = null;
                state.crossfade = 0.0;
                
                // Actualizar Texturas
                texA.image = videoSlots[state.slotCurrent];
                texA.needsUpdate = true;
                uniforms.uTexA.value = texA;
                
                // Limpiar textura B (o dejarla igual, da igual porque fade es 0)
                texB.image = noiseTex.image;
                uniforms.uTexB.value = texB;

                // Reset UI
                faderFill.style.width = '0%';
                hudSlot.innerText = state.slotCurrent.toUpperCase();
                hudNext.innerText = "NONE";
                showNotify("TRANSICIÓN COMPLETADA");
            }
        });

        // --- TECLADO ---
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // Efectos 1-0
            if(!isNaN(parseInt(key))) {
                state.effectMode = (parseInt(key) === 0) ? 10 : parseInt(key);
                hudMode.innerText = state.effectMode;
                showNotify(`EFECTO: ${state.effectMode}`);
            }

            // Colores Q-Y
            if(colors[key]) {
                state.tint.setRGB(...colors[key]);
                state.tintMix = 1.0;
                hudColor.innerText = key.toUpperCase(); hudColor.style.color = "#0ff";
            }
            if(key === 'u') { state.tintMix = 0.0; hudColor.innerText = "OFF"; hudColor.style.color = "#fff"; }

            // Estilos Z-B
            if(styleMap[key]) {
                state.styleMode = styleMap[key];
                const names = ["", "MALLA", "PUNTOS", "HEX", "HOLO", "BINARY"];
                hudStyle.innerText = names[state.styleMode];
                showNotify(`ESTILO: ${names[state.styleMode]}`);
            }
            if(key === 'm') { state.styleMode = 0; hudStyle.innerText = "NORMAL"; showNotify("ESTILO: NORMAL"); }

            // Cam Mix N
            if(key === 'n') {
                state.mixRatio = (state.mixRatio > 0.1) ? 0.0 : 0.5;
                if(state.mixRatio > 0 && !webcamEl.srcObject) initWebcam();
                showNotify(state.mixRatio > 0 ? "CAM MIX: ON" : "CAM MIX: OFF");
            }

            // --- VIDEO SLOTS (A-L) ---
            const allSlots = ['a','s','d','f','g','h','j','k','l'];
            if (allSlots.includes(key)) {
                
                if (!videoSlots[key]) {
                    // Slot Vacío -> Cargar Video
                    state.loadingSlot = key;
                    fileInput.click();
                } else {
                    // Slot Lleno -> Poner en COLA (Next)
                    // No pausamos nada, todo sigue en loop
                    state.slotNext = key;
                    
                    // Asignar al canal B del shader
                    texB.image = videoSlots[key];
                    texB.needsUpdate = true;
                    uniforms.uTexB.value = texB;

                    hudNext.innerText = key.toUpperCase();
                    showNotify(`SIGUIENTE: ${key.toUpperCase()} (USA SCROLL)`);
                }
            }
        });

        // Carga de archivo
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if(!file || !state.loadingSlot) return;
            const url = URL.createObjectURL(file);
            const vid = document.createElement('video');
            vid.src = url; vid.loop = true; vid.muted = true; vid.playsInline = true;
            
            // Auto-play inmediato (reproducción constante)
            vid.play(); 
            videoSlots[state.loadingSlot] = vid;

            // Si es el primer video que cargamos, lo ponemos directo al canal A
            if (!state.slotCurrent) {
                state.slotCurrent = state.loadingSlot;
                texA.image = vid;
                uniforms.uTexA.value = texA;
                hudSlot.innerText = state.loadingSlot.toUpperCase();
                showNotify(`CARGADO EN ${state.loadingSlot.toUpperCase()}`);
            } else {
                showNotify(`CARGADO EN ${state.loadingSlot.toUpperCase()} (LISTO)`);
            }
            
            state.loadingSlot = null;
            fileInput.value = ""; 
        };

        async function initWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                webcamEl.srcObject = stream;
                webcamEl.play();
                uniforms.uTexCam.value = webcamTex;
            } catch(e) { console.error("No cam"); }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            const lvls = audio.getLevels();

            uniforms.uTime.value = time;
            uniforms.uVol.value = lvls.vol;
            uniforms.uBass.value = lvls.bass;
            uniforms.uHigh.value = lvls.high;
            uniforms.uMix.value = state.mixRatio;
            uniforms.uMode.value = state.effectMode;
            uniforms.uStyle.value = state.styleMode;
            uniforms.uTint.value = state.tint;
            uniforms.uTintMix.value = state.tintMix;
            uniforms.uCrossfade.value = state.crossfade; // Enviar valor del fader

            bloom.strength = state.bloom + (lvls.vol * 1.5);
            
            if(lvls.bass > 0.5) {
                plane.rotation.z = (Math.random()-0.5)*0.05;
                plane.scale.setScalar(1.0 + lvls.bass*0.05);
            } else {
                plane.rotation.z *= 0.9;
                plane.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
            }

            // Actualizar texturas dinámicas
            if(texA.image && texA.image.tagName === 'VIDEO' && texA.image.readyState >= 2) texA.needsUpdate = true;
            if(texB.image && texB.image.tagName === 'VIDEO' && texB.image.readyState >= 2) texB.needsUpdate = true;
            if(webcamTex.image && webcamTex.image.readyState >= 2) webcamTex.needsUpdate = true;

            composer.render();
        }

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        };

        document.getElementById('start-btn').onclick = async () => {
            if(await audio.init()) {
                document.getElementById('overlay').style.opacity = 0;
                setTimeout(()=>document.getElementById('overlay').style.display='none', 500);
                animate();
            }
        };

        const gui = new GUI({ title: 'Ajustes' });
        gui.add(state, 'distortion', 0, 5).name('Fuerza Glitch');
        gui.add(state, 'micGain', 1, 10).name('Sensibilidad');
        gui.add(state, 'bloom', 0, 3).name('Brillo');
    </script>
</head>
<body>
    <div id="overlay">
        <h1 style="color:#0ff; text-shadow:0 0 10px #0ff; margin-bottom: 40px;">INFINITE LOOP VJ</h1>
        <button id="start-btn">INICIAR SISTEMA</button>
        
        <div class="keys-grid">
            <div>
                <span class="key">1-0</span> DEFORMACIÓN<br>
                <span class="key">Z-B</span> ESTILOS GEO<br>
                <span class="key">M</span> RESET ESTILO
            </div>
            <div>
                <span class="key">A-L</span> 9 VIDEO SLOTS<br>
                (Clic carga, Key selecciona)<br>
                <span class="key">SCROLL</span> CROSSFADE<br>
            </div>
            <div>
                <span class="key">N</span> CAM MIX<br>
                <span class="key">Q-Y</span> TINTES
            </div>
        </div>
    </div>

    <div id="hud">
        <div class="hud-line">DEFORM: <span id="hud-mode" class="hud-value">1</span></div>
        <div class="hud-line">ESTILO: <span id="hud-style" class="hud-value">NORMAL</span></div>
        <div class="hud-line">ACTUAL: <span id="hud-slot" class="hud-value">NONE</span></div>
        <div class="hud-line" style="margin-top:10px; color:#aaa">SIGUIENTE (COLA): <span id="hud-next" class="hud-value" style="color:#fff">NONE</span></div>
        <div class="hud-line">COLOR: <span id="hud-color" class="hud-value" style="color:#fff">OFF</span></div>
    </div>
    
    <div id="fader-bar"><div id="fader-fill"></div></div>

    <div id="notification">NOTIFICACIÓN</div>
    <input type="file" id="file-input" accept="video/*">
</body>
</html>
