<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Vertex Reaction System</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', monospace; }
        
        #overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            transition: opacity 0.5s ease; text-align: center;
        }

        .keys-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            color: #888; margin-top: 30px; text-align: left; font-size: 14px;
        }
        .key { color: #0ff; font-weight: bold; border: 1px solid #0ff; padding: 2px 6px; border-radius: 4px;}
        
        button#start-btn {
            padding: 20px 60px; font-size: 24px; color: #0ff; background: transparent;
            border: 2px solid #0ff; border-radius: 5px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0,255,255,0.2); text-transform: uppercase; letter-spacing: 4px;
            margin-bottom: 20px; transition: all 0.2s;
        }
        button#start-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 60px rgba(0,255,255,1); }

        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; text-shadow: 0 0 5px #000; pointer-events: none;
        }
        .hud-line { margin-bottom: 5px; font-size: 12px; opacity: 0.8; }
        .hud-value { color: #0ff; font-weight: bold; }

        #fader-bar {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 10px; background: #333; border: 1px solid #555;
            border-radius: 5px; overflow: hidden; z-index: 10;
        }
        #fader-fill {
            width: 0%; height: 100%; background: linear-gradient(90deg, #00f, #0ff);
            transition: width 0.1s linear;
        }

        #file-input { display: none; }
        
        #notification {
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); border: 1px solid #0ff; color: #0ff;
            padding: 10px 30px; border-radius: 20px; font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 15;
        }
    </style>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- ESTADO GLOBAL ---
        const state = {
            effectMode: 1, 
            styleMode: 0,
            distortionType: 0, // 0:Flor, 1:Onda, 2:Picos, 3:Bombeo
            mixRatio: 0.0, 
            distortion: 2.0,
            micGain: 5.0,
            bloom: 1.5,
            tint: new THREE.Color(1, 1, 1),
            tintMix: 0.0, 
            loadingSlot: null,
            crossfade: 0.0,
            slotCurrent: null,
            slotNext: null
        };

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() { this.ctx = null; this.analyser = null; this.data = null; this.freq = null; this.ready = false; }
            async init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, autoGainControl: false } });
                    this.analyser = this.ctx.createAnalyser(); this.analyser.fftSize = 512;
                    this.ctx.createMediaStreamSource(stream).connect(this.analyser);
                    this.data = new Uint8Array(this.analyser.frequencyBinCount);
                    this.freq = new Uint8Array(this.analyser.frequencyBinCount);
                    this.ready = true; return true;
                } catch(e) { console.error(e); return false; }
            }
            getLevels() {
                if(!this.ready) return { vol: 0, bass: 0, high: 0 };
                this.analyser.getByteTimeDomainData(this.data);
                this.analyser.getByteFrequencyData(this.freq);
                let sum=0; for(let i=0;i<this.data.length;i++){ const v=(this.data[i]-128)/128; sum+=v*v; }
                const vol = Math.sqrt(sum/this.data.length) * state.micGain;
                const bass = this.freq[5] / 255.0;
                const high = this.freq[200] / 255.0;
                return { vol, bass, high };
            }
        }
        const audio = new AudioEngine();

        // --- SCENE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 9;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- TEXTURES ---
        const videoSlots = { 
            'a': null, 's': null, 'd': null, 'f': null,
            'g': null, 'h': null, 'j': null, 'k': null, 'l': null 
        };

        const texA = new THREE.VideoTexture(document.createElement('video'));
        const texB = new THREE.VideoTexture(document.createElement('video'));
        const webcamEl = document.createElement('video');
        webcamEl.muted = true; webcamEl.playsInline = true;
        const webcamTex = new THREE.VideoTexture(webcamEl);

        function createNoise() {
            const c=document.createElement('canvas'); c.width=64; c.height=64;
            const x=c.getContext('2d'); x.fillStyle='#111'; x.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }
        const noiseTex = createNoise();
        texA.image = noiseTex.image;
        texB.image = noiseTex.image;

        // --- SHADER UNIFORMS ---
        const uniforms = {
            uTexA: { value: noiseTex },
            uTexB: { value: noiseTex },
            uCrossfade: { value: 0.0 },
            uTexCam: { value: noiseTex },
            uMix: { value: 0.0 },
            uTime: { value: 0.0 },
            uBass: { value: 0.0 },
            uHigh: { value: 0.0 },
            uVol: { value: 0.0 },
            uMode: { value: 1 },
            uStyle: { value: 0 },
            uDistType: { value: 0 }, // NUEVO: Tipo de deformación
            uTint: { value: new THREE.Color(1,1,1) },
            uTintMix: { value: 0.0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        // --- FRAGMENT SHADER (Visuales 2D) ---
        const fragmentShader = `
            uniform sampler2D uTexA;
            uniform sampler2D uTexB;
            uniform float uCrossfade;
            uniform sampler2D uTexCam;
            uniform float uMix;
            uniform float uTime;
            uniform float uBass;
            uniform float uHigh;
            uniform float uVol;
            uniform int uMode;
            uniform int uStyle;
            uniform vec3 uTint;
            uniform float uTintMix;
            varying vec2 vUv;

            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            vec3 rgbSplit(sampler2D tex, vec2 uv, float amount) {
                float r = texture2D(tex, uv - vec2(amount, 0.0)).r;
                float g = texture2D(tex, uv).g;
                float b = texture2D(tex, uv + vec2(amount, 0.0)).b;
                return vec3(r,g,b);
            }

            void main() {
                vec2 uv = vUv;
                
                // Efectos 2D
                if(uMode == 3) uv.x = abs(uv.x - 0.5) + 0.5;
                if(uMode == 4) {
                    vec2 c = uv - 0.5; float r = length(c); float a = atan(c.y, c.x);
                    float s = 6.0; a = mod(a, 6.283/s); a = abs(a - 3.141/s);
                    uv = 0.5 + r * vec2(cos(a), sin(a));
                }
                if(uMode == 5) {
                    float d = length(uv - 0.5);
                    float a = atan(uv.y-0.5, uv.x-0.5) + (uBass*5.0) * (1.0-d);
                    uv = 0.5 + d * vec2(cos(a), sin(a));
                }
                if(uMode == 9) {
                    uv.x += sin(uv.y * 10.0 + uTime) * 0.05 * uVol;
                    uv.y += cos(uv.x * 10.0 + uTime) * 0.05 * uVol;
                }

                // Sampling
                vec3 cA = (uMode==2) ? rgbSplit(uTexA, uv, uBass*0.05) : texture2D(uTexA, uv).rgb;
                vec3 cB = (uMode==2) ? rgbSplit(uTexB, uv, uBass*0.05) : texture2D(uTexB, uv).rgb;
                vec3 col = mix(cA, cB, uCrossfade);

                vec3 cCam = texture2D(uTexCam, uv).rgb;
                if(uMode==2) cCam = rgbSplit(uTexCam, uv, uBass*0.05);
                col = mix(col, cCam, uMix);

                // Post FX
                if(uMode == 7 && uBass > 0.6) col = 1.0 - col;
                if(uMode == 8) {
                    vec3 c1 = mix(texture2D(uTexA, uv+0.002).rgb, texture2D(uTexB, uv+0.002).rgb, uCrossfade);
                    col = length(abs(col - c1)) * vec3(0.0, 1.0, 1.0) * 4.0; 
                }
                if(uMode == 10 && rand(floor(uv*10.0)+floor(uTime*10.0)) < uBass*0.5) col = vec3(1.0);
                if(uMode == 1) col *= (0.8 + 0.2 * (sin(uv.y*800.0+uTime*5.0)*0.5+0.5));

                // Estilos
                float lum = dot(col, vec3(0.33));
                if (uStyle == 1) col = col * (step(0.9, fract(uv.x*40.0+uTime*0.5)) + step(0.9, fract(uv.y*40.0))) * 2.0;
                if (uStyle == 2) col = col * step(distance(fract(uv*80.0), vec2(0.5)), lum*0.5) * 1.5;
                if (uStyle == 3) col = col * (sin(uv.x*50.0)*sin(uv.y*50.0) > 0.0 ? 1.5 : 0.2);
                if (uStyle == 4) col = mix(col, vec3(0.0, 1.0, 0.8)*lum, 0.8) * step(0.5, sin(uv.y*200.0+uTime*10.0));
                if (uStyle == 5) col = vec3(0.0, 1.0, 0.2) * step(0.5, rand(floor(uv*vec2(40.,20.)) + floor(uTime))) * lum * 2.0;

                col = mix(col, col * uTint, uTintMix);
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // --- VERTEX SHADER (Deformación 3D) ---
        const vertexShader = `
            uniform float uVol;
            uniform float uBass;
            uniform float uTime;
            uniform int uDistType; // 0=Flor, 1=Onda, 2=Picos, 3=Pump
            varying vec2 vUv;

            void main() {
                vUv = uv;
                vec3 pos = position;
                float displacement = 0.0;

                // 0: FLOR (Default)
                if (uDistType == 0) {
                    displacement = sin(pos.x * 2.0 + uTime) * cos(pos.y * 1.5 + uTime);
                }
                
                // 1: ONDA EXPANSIVA (Impact) - Tecla I
                else if (uDistType == 1) {
                    float dist = length(uv - 0.5);
                    displacement = sin(dist * 20.0 - uTime * 5.0);
                }

                // 2: PICOS DIGITALES (Oscillate) - Tecla O
                else if (uDistType == 2) {
                    displacement = sin(pos.y * 30.0 + uTime * 2.0) * sin(pos.x * 30.0);
                    // Hacerlo más puntiagudo
                    if (displacement > 0.5) displacement = 1.0;
                    else if (displacement < -0.5) displacement = -1.0;
                    else displacement = 0.0;
                }

                // 3: BOMBEO (Pump) - Tecla P
                else if (uDistType == 3) {
                    float dist = length(uv - 0.5);
                    // Una curva suave que levanta el centro
                    displacement = smoothstep(0.6, 0.0, dist); 
                }

                // Aplicar fuerza del audio
                pos.z += displacement * uVol * 4.0;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms, vertexShader, fragmentShader, side: THREE.DoubleSide
        });

        const geometry = new THREE.PlaneGeometry(16, 9, 120, 120); // Más polígonos para mejor deformación
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloom);

        // --- INPUTS ---
        const fileInput = document.getElementById('file-input');
        const hudMode = document.getElementById('hud-mode');
        const hudStyle = document.getElementById('hud-style');
        const hudDist = document.getElementById('hud-dist'); // Nuevo HUD
        const hudSlot = document.getElementById('hud-slot');
        const hudNext = document.getElementById('hud-next');
        const hudColor = document.getElementById('hud-color');
        const faderFill = document.getElementById('fader-fill');

        const colors = { 'q': [1,0,0], 'w': [0,1,0], 'e': [0,0,1], 'r': [0,1,1], 't': [1,0,1], 'y': [1,1,0] };
        const styleMap = { 'z': 1, 'x': 2, 'c': 3, 'v': 4, 'b': 5 };
        
        // Mapa de Deformaciones
        const distMap = { 'i': 1, 'o': 2, 'p': 3 };

        function showNotify(msg) {
            const n = document.getElementById('notification');
            n.innerText = msg; n.style.opacity = 1;
            setTimeout(() => n.style.opacity = 0, 2000);
        }

        // --- GESTIÓN DE SCROLL (CROSSFADER) ---
        window.addEventListener('wheel', (e) => {
            if (!state.slotNext || !videoSlots[state.slotNext]) return;
            const delta = e.deltaY * 0.001;
            state.crossfade = Math.max(0.0, Math.min(1.0, state.crossfade + delta));
            faderFill.style.width = (state.crossfade * 100) + '%';

            if (state.crossfade >= 1.0) {
                state.slotCurrent = state.slotNext;
                state.slotNext = null;
                state.crossfade = 0.0;
                texA.image = videoSlots[state.slotCurrent];
                texA.needsUpdate = true;
                uniforms.uTexA.value = texA;
                texB.image = noiseTex.image;
                uniforms.uTexB.value = texB;
                faderFill.style.width = '0%';
                hudSlot.innerText = state.slotCurrent.toUpperCase();
                hudNext.innerText = "NONE";
                showNotify("TRANSICIÓN COMPLETADA");
            }
        });

        // --- TECLADO ---
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            // Efectos 1-0
            if(!isNaN(parseInt(key))) {
                state.effectMode = (parseInt(key) === 0) ? 10 : parseInt(key);
                hudMode.innerText = state.effectMode;
                showNotify(`EFECTO 2D: ${state.effectMode}`);
            }

            // Colores Q-Y
            if(colors[key]) {
                state.tint.setRGB(...colors[key]);
                state.tintMix = 1.0;
                hudColor.innerText = key.toUpperCase(); hudColor.style.color = "#0ff";
            }
            if(key === 'u') { state.tintMix = 0.0; hudColor.innerText = "OFF"; hudColor.style.color = "#fff"; }

            // Estilos Z-B
            if(styleMap[key]) {
                state.styleMode = styleMap[key];
                const names = ["", "MALLA", "PUNTOS", "HEX", "HOLO", "BINARY"];
                hudStyle.innerText = names[state.styleMode];
                showNotify(`ESTILO: ${names[state.styleMode]}`);
            }

            // --- NUEVO: DEFORMACIONES (I, O, P) ---
            if(distMap[key]) {
                state.distortionType = distMap[key];
                const dNames = ["FLOR", "ONDA", "PICOS", "PUMP"];
                hudDist.innerText = dNames[state.distortionType];
                showNotify(`DEFORMACIÓN: ${dNames[state.distortionType]}`);
            }

            // M: RESET GENERAL (Estilo + Deformación)
            if(key === 'm') { 
                state.styleMode = 0; 
                state.distortionType = 0; // Vuelve a Flor
                hudStyle.innerText = "NORMAL"; 
                hudDist.innerText = "FLOR";
                showNotify("RESET: NORMAL + FLOR"); 
            }

            // Cam Mix N
            if(key === 'n') {
                state.mixRatio = (state.mixRatio > 0.1) ? 0.0 : 0.5;
                if(state.mixRatio > 0 && !webcamEl.srcObject) initWebcam();
                showNotify(state.mixRatio > 0 ? "CAM MIX: ON" : "CAM MIX: OFF");
            }

            // Video Slots (A-L)
            const allSlots = ['a','s','d','f','g','h','j','k','l'];
            if (allSlots.includes(key)) {
                if (!videoSlots[key]) {
                    state.loadingSlot = key;
                    fileInput.click();
                } else {
                    state.slotNext = key;
                    texB.image = videoSlots[key];
                    texB.needsUpdate = true;
                    uniforms.uTexB.value = texB;
                    hudNext.innerText = key.toUpperCase();
                    showNotify(`SIGUIENTE: ${key.toUpperCase()}`);
                }
            }
        });

        // Carga de archivo
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if(!file || !state.loadingSlot) return;
            const url = URL.createObjectURL(file);
            const vid = document.createElement('video');
            vid.src = url; vid.loop = true; vid.muted = true; vid.playsInline = true;
            vid.play(); 
            videoSlots[state.loadingSlot] = vid;

            if (!state.slotCurrent) {
                state.slotCurrent = state.loadingSlot;
                texA.image = vid;
                uniforms.uTexA.value = texA;
                hudSlot.innerText = state.loadingSlot.toUpperCase();
                showNotify(`CARGADO EN ${state.loadingSlot.toUpperCase()}`);
            } else {
                showNotify(`CARGADO EN ${state.loadingSlot.toUpperCase()}`);
            }
            state.loadingSlot = null;
            fileInput.value = ""; 
        };

        async function initWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
                webcamEl.srcObject = stream;
                webcamEl.play();
                uniforms.uTexCam.value = webcamTex;
            } catch(e) { console.error("No cam"); }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            const lvls = audio.getLevels();

            uniforms.uTime.value = time;
            uniforms.uVol.value = lvls.vol;
            uniforms.uBass.value = lvls.bass;
            uniforms.uHigh.value = lvls.high;
            uniforms.uMix.value = state.mixRatio;
            uniforms.uMode.value = state.effectMode;
            uniforms.uStyle.value = state.styleMode;
            uniforms.uDistType.value = state.distortionType; // Enviar tipo de deformación
            uniforms.uTint.value = state.tint;
            uniforms.uTintMix.value = state.tintMix;
            uniforms.uCrossfade.value = state.crossfade;

            bloom.strength = state.bloom + (lvls.vol * 1.5);
            
            // Movimiento físico extra (rotación sutil)
            if(lvls.bass > 0.5) {
                plane.rotation.z = (Math.random()-0.5)*0.02;
            } else {
                plane.rotation.z *= 0.9;
            }

            if(texA.image && texA.image.tagName === 'VIDEO' && texA.image.readyState >= 2) texA.needsUpdate = true;
            if(texB.image && texB.image.tagName === 'VIDEO' && texB.image.readyState >= 2) texB.needsUpdate = true;
            if(webcamTex.image && webcamTex.image.readyState >= 2) webcamTex.needsUpdate = true;

            composer.render();
        }

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        };

        document.getElementById('start-btn').onclick = async () => {
            if(await audio.init()) {
                document.getElementById('overlay').style.opacity = 0;
                setTimeout(()=>document.getElementById('overlay').style.display='none', 500);
                animate();
            }
        };

        const gui = new GUI({ title: 'Ajustes' });
        gui.add(state, 'distortion', 0, 5).name('Fuerza Glitch');
        gui.add(state, 'micGain', 1, 10).name('Sensibilidad');
        gui.add(state, 'bloom', 0, 3).name('Brillo');
    </script>
</head>
<body>
    <div id="overlay">
        <h1 style="color:#0ff; text-shadow:0 0 10px #0ff; margin-bottom: 40px;">VERTEX REACTION SYSTEM</h1>
        <button id="start-btn">INICIAR SISTEMA</button>
        
        <div class="keys-grid">
            <div>
                <span class="key">1-0</span> FX 2D<br>
                <span class="key">Z-B</span> ESTILOS<br>
                <span class="key">I</span> ONDA<br>
                <span class="key">O</span> PICOS<br>
                <span class="key">P</span> PUMP<br>
                <span class="key">M</span> RESET ALL
            </div>
            <div>
                <span class="key">A-L</span> 9 SLOTS<br>
                (Selecciona y usa<br>
                la rueda del mouse)<br>
            </div>
            <div>
                <span class="key">N</span> CAM MIX<br>
                <span class="key">Q-Y</span> TINTES
            </div>
        </div>
    </div>

    <div id="hud">
        <div class="hud-line">DEFORM: <span id="hud-dist" class="hud-value">FLOR</span></div>
        <div class="hud-line">ESTILO: <span id="hud-style" class="hud-value">NORMAL</span></div>
        <div class="hud-line">FX 2D: <span id="hud-mode" class="hud-value">1</span></div>
        <div class="hud-line" style="margin-top:10px">SLOT: <span id="hud-slot" class="hud-value">NONE</span></div>
        <div class="hud-line">NEXT: <span id="hud-next" class="hud-value" style="color:#888">NONE</span></div>
    </div>
    
    <div id="fader-bar"><div id="fader-fill"></div></div>

    <div id="notification">NOTIFICACIÓN</div>
    <input type="file" id="file-input" accept="video/*">
</body>
</html>
