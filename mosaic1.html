<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo-Tokyo: Enlace Espacio-Temporal</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 3px; }
        p { font-size: 0.8rem; opacity: 0.7; }
        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>NEURAL CITY 3.0</h1>
        <p>NAVEGANDO FLUJO DE DATOS // MOUSE PARA EXPLORAR</p>
    </div>
    <div id="loader" class="loading">INICIANDO SISTEMAS...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN BÁSICA ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.0025); 

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 20, 100);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- ILUMINACIÓN ---
        const ambientLight = new THREE.AmbientLight(0x404040, 15); 
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xff00ff, 2);
        sunLight.position.set(-1, 0.5, -1);
        scene.add(sunLight);

        // --- CIUDAD PROCEDURAL ---
        const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        boxGeometry.translate(0, 0.5, 0); 

        const buildingMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.8,
            emissive: 0x000000
        });

        const count = 800; 
        const mesh = new THREE.InstancedMesh(boxGeometry, buildingMaterial, count);
        scene.add(mesh);

        const dummy = new THREE.Object3D();
        
        for (let i = 0; i < count; i++) {
            resetBuilding(dummy, i, true);
        }

        function resetBuilding(dummy, index, initial = false) {
            let x = (Math.random() - 0.5) * 600;
            if (Math.abs(x) < 20) x += (x > 0 ? 20 : -20);
            let z = initial ? (Math.random() - 0.5) * 2000 - 500 : -1500;
            const scaleY = Math.random() * 80 + 10;
            const scaleXZ = Math.random() * 15 + 5;

            dummy.position.set(x, 0, z);
            dummy.scale.set(scaleXZ, scaleY, scaleXZ);
            dummy.updateMatrix();
            mesh.setMatrixAt(index, dummy.matrix);
        }

        // --- SUELO ---
        const gridHelper = new THREE.GridHelper(2000, 100, 0xff00ff, 0x0044ff);
        gridHelper.position.y = 0.1;
        scene.add(gridHelper);
        
        const planeGeo = new THREE.PlaneGeometry(2000, 2000);
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x000000, roughness: 0.05, metalness: 0.9 
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);

        // --- CIELO / RED ---
        const particlesCount = 1500;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i = 0; i < particlesCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 800; 
            if ((i+2) % 3 === 0) posArray[i] = Math.random() * 200 + 50; 
        }

        const particlesGeo = new THREE.BufferGeometry();
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particlesMat = new THREE.PointsMaterial({
            size: 2,
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particlesMesh = new THREE.Points(particlesGeo, particlesMat);
        scene.add(particlesMesh);

        // --- LÍNEAS LÁSER ---
        const laserCount = 20;
        const laserGeo = new THREE.BufferGeometry();
        const laserPos = new Float32Array(laserCount * 6); 
        laserGeo.setAttribute('position', new THREE.BufferAttribute(laserPos, 3));
        const laserMat = new THREE.LineBasicMaterial({ color: 0xff00aa });
        const lasers = new THREE.LineSegments(laserGeo, laserMat);
        scene.add(lasers);

        // --- POST-PROCESADO (CORREGIDO) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; 
        bloomPass.radius = 0.5;

        // AQUÍ ESTABA EL ERROR: Eliminamos "THREE." del constructor
        const composer = new EffectComposer(renderer); 
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- INTERACCIÓN ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        let speedOffset = 0;

        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - windowHalfX) * 0.5;
            mouseY = (event.clientY - windowHalfY) * 0.5;
        });

        document.addEventListener('scroll', () => {
            speedOffset += 0.5;
        });

        // --- ANIMACIÓN ---
        const clock = new THREE.Clock();
        document.getElementById('loader').style.opacity = 0;

        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            targetX = mouseX * 0.2;
            targetY = mouseY * 0.2;
            
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (-targetY + 50 - camera.position.y) * 0.05; 
            camera.lookAt(0, 20, -100); 

            gridHelper.position.z = (time * 50) % 100;
            
            for (let i = 0; i < count; i++) {
                mesh.getMatrixAt(i, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                
                dummy.position.z += 2 + (speedOffset > 0 ? speedOffset : 0);
                
                if (dummy.position.z > 200) {
                    resetBuilding(dummy, i, false);
                    dummy.position.z = -1500; 
                }
                
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.instanceMatrix.needsUpdate = true;
            if(speedOffset > 0) speedOffset -= 0.05;

            particlesMesh.rotation.y = time * 0.05;
            particlesMesh.position.z = (time * 20) % 200;

            const positions = lasers.geometry.attributes.position.array;
            for(let k=0; k < laserCount; k++) {
                positions[k*6 + 3] += (Math.sin(time + k) * 2); 
                positions[k*6 + 4] = 100 + Math.sin(time * 2 + k) * 20; 
                positions[k*6 + 5] = -200;

                if (k % 2 === 0) {
                     positions[k*6 + 3] = (mouseX * 2) + Math.cos(time * 5 + k)*50;
                }
            }
            lasers.geometry.attributes.position.needsUpdate = true;

            // IMPORTANTE: Usar composer.render() en lugar de renderer.render()
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
