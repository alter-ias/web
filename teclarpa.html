<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Instrumento de Texto Orbital</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85);
            color: #00ff88;
            z-index: 10;
            transition: opacity 0.5s;
            cursor: pointer;
            text-align: center;
            padding: 20px;
        }
        h1 { margin-bottom: 10px; text-transform: uppercase; letter-spacing: 5px; text-shadow: 0 0 10px #00ff88; }
        p { font-size: 1.2rem; color: #fff; max-width: 600px; line-height: 1.5; }
        .hidden { opacity: 0; pointer-events: none; }
        #hud {
            position: absolute;
            bottom: 20px; left: 20px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="overlay">
        <h1>Sinte-Mecánico Orbital</h1>
        <p>Haz clic para iniciar el sistema de audio.</p>
        <p style="font-size: 0.9rem; margin-top: 20px;">
            <br>
            [A-Z]: Melodía Sintetizada<br>
            [0-9]: Percusión y FX<br>
            Escribe palabras para crear música.
        </p>
    </div>

    <div id="hud">Escribe para tocar...</div>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. CONFIGURACIÓN BÁSICA ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 2. ILUMINACIÓN ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // Luz suave
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // Luces dinámicas que reaccionan
        const stageLight = new THREE.PointLight(0x00ff88, 0, 50);
        stageLight.position.set(0, 0, 5);
        scene.add(stageLight);

        // --- 3. CREACIÓN DEL INSTRUMENTO (MODELO 3D) ---
        const keysGroup = new THREE.Group();
        scene.add(keysGroup);

        const keyMap = {}; // Diccionario para guardar referencias a los objetos 3D
        
        // Layout del teclado
        const keyboardLayout = [
            "1234567890",
            "QWERTYUIOP",
            "ASDFGHJKL",
            "ZXCVBNM"
        ];

        const boxGeometry = new THREE.BoxGeometry(0.8, 0.8, 2);
        const baseMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333, 
            roughness: 0.4,
            metalness: 0.8
        });

        // Crear las teclas en una formación curva
        keyboardLayout.forEach((row, rowIndex) => {
            const rowWidth = row.length;
            const radius = 10; // Radio del arco
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                // Material único para cada tecla para poder cambiar su color individualmente
                const material = baseMaterial.clone();
                const mesh = new THREE.Mesh(boxGeometry, material);

                // Cálculos para la posición curva
                const angle = (i - rowWidth / 2) * 0.25; // Distribución angular
                const yPos = (1.5 - rowIndex) * 1.2;     // Altura de la fila
                
                mesh.position.x = Math.sin(angle) * radius;
                mesh.position.z = Math.cos(angle) * radius - radius; // Empujarlo hacia atrás
                mesh.position.y = yPos;

                mesh.lookAt(0, yPos, 15); // Que miren hacia la cámara/usuario

                // Guardamos datos originales para animaciones
                mesh.userData = {
                    originalZ: mesh.position.z,
                    originalColor: 0x333333,
                    activeColor: rowIndex === 0 ? 0xff0055 : (rowIndex === 1 ? 0x00ccff : 0x00ff88), // Colores por fila
                    char: char.toLowerCase()
                };

                keysGroup.add(mesh);
                keyMap[char.toLowerCase()] = mesh;
            }
        });

        // Partículas de fondo
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i < starsCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 100;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMaterial = new THREE.PointsMaterial({size: 0.05, color: 0xffffff});
        const starsMesh = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starsMesh);


        // --- 4. MOTOR DE AUDIO (Web Audio API) ---
        let audioCtx;
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Sintetizador para Letras (Ondas armónicas)
        function playSynthNote(char) {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // Mapeo simple de caracteres a frecuencias (Escala Pentatónica Menor extendida)
            // Usamos códigos ASCII para generar frecuencias base
            const code = char.charCodeAt(0);
            // Fórmula pentatónica improvisada para que suene bien casi siempre
            const baseFreq = 110 * Math.pow(1.05946, (code % 25)); 

            osc.type = ['sine', 'triangle', 'sawtooth'][Math.floor(Math.random()*3)]; // Tipo de onda aleatoria
            osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);

            filter.type = "lowpass";
            filter.frequency.setValueAtTime(1000, audioCtx.currentTime);

            // Envolvente (ADSR simulado)
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05); // Attack
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5); // Release largo

            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 1.5);
        }

        // Sintetizador para Números (Percusión/Ruido)
        function playDrum(num) {
            if (!audioCtx) return;
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            if (num % 2 === 0) {
                // Simulación de Bombo (Kick)
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                gainNode.gain.setValueAtTime(1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gainNode);
            } else {
                // Simulación de Hi-hat/Ruido (simplificado con onda cuadrada alta)
                osc.type = 'square';
                osc.frequency.setValueAtTime(800 + (Math.random() * 500), audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                
                // Filtro paso alto
                const filter = audioCtx.createBiquadFilter();
                filter.type = "highpass";
                filter.frequency.value = 1000;
                osc.connect(filter);
                filter.connect(gainNode);
            }

            gainNode.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }


        // --- 5. INTERACCIÓN Y LÓGICA ---
        
        // Animación de tecla presionada
        function triggerKeyVisual(mesh) {
            // Resetear posición
            mesh.scale.set(1, 1, 1);
            
            // Animación "golpe" visual
            mesh.scale.set(1.1, 1.1, 1.5); // Se hace más larga
            mesh.material.color.setHex(mesh.userData.activeColor);
            mesh.material.emissive.setHex(mesh.userData.activeColor);
            mesh.material.emissiveIntensity = 2;

            // Flash de luz global
            stageLight.color.setHex(mesh.userData.activeColor);
            stageLight.intensity = 2;

            // Timer para regresar al estado normal
            setTimeout(() => {
                mesh.scale.set(1, 1, 1);
                mesh.material.color.setHex(mesh.userData.originalColor);
                mesh.material.emissive.setHex(0x000000);
                mesh.material.emissiveIntensity = 0;
            }, 150);
        }

        document.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            
            if (keyMap[key]) {
                const mesh = keyMap[key];
                
                // Lógica Visual
                triggerKeyVisual(mesh);

                // Lógica de Audio
                if (!isNaN(key)) {
                    // Es número
                    playDrum(parseInt(key));
                } else {
                    // Es letra
                    playSynthNote(key);
                }
            }
        });

        // Manejo del overlay de inicio
        const overlay = document.getElementById('overlay');
        overlay.addEventListener('click', () => {
            initAudio();
            overlay.classList.add('hidden');
        });

        // --- 6. BUCLE DE RENDERIZADO ---
        
        // Variables para animación suave de retorno de la luz
        function animate() {
            requestAnimationFrame(animate);

            // Rotación sutil de todo el instrumento
            keysGroup.rotation.y = Math.sin(Date.now() * 0.0005) * 0.1;
            keysGroup.rotation.z = Math.cos(Date.now() * 0.0005) * 0.05;

            // Movimiento de estrellas
            starsMesh.rotation.y += 0.0005;

            // Decaimiento de la luz de escenario
            if (stageLight.intensity > 0) {
                stageLight.intensity -= 0.1;
            }

            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
