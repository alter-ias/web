<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYLINDER SYNTH - GitHub Edition</title>
    <style>
        /* ESTILO VISUAL: OSCURO E INDUSTRIAL */
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s;
        }
        
        h1 { color: #ff9900; text-shadow: 0 0 20px #ff3300; font-size: 3rem; margin: 0; text-align: center; letter-spacing: 5px; }
        p { color: #ccc; font-size: 1rem; margin-bottom: 30px; }
        
        button {
            padding: 20px 50px; border: 2px solid #ff9900; background: #220000;
            color: #ff9900; font-size: 1.2rem; cursor: pointer; text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 60, 0, 0.5); border-radius: 4px;
        }
        button:hover { background: #ff9900; color: #000; box-shadow: 0 0 40px #ff9900; }

        #hud {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            pointer-events: none; background: rgba(0,0,0,0.7); padding: 15px; border: 1px solid #004433;
            font-size: 0.9rem;
        }
        .track { opacity: 0.4; margin-bottom: 5px; transition: 0.2s; }
        .active { opacity: 1; font-weight: bold; color: #ff0055; text-shadow: 0 0 8px #ff0055; border-left: 3px solid #ff0055; padding-left: 5px; }

        #scope {
            position: absolute; bottom: 20px; right: 20px;
            width: 300px; height: 100px; border: 1px solid #333;
            background: #001100; opacity: 0.9;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="overlay">
        <h1>MECHANICAL SYNTH</h1>
        <p>1-4: PISTA | Q-P: NOTAS | ESPACIO: BORRAR</p>
        <button id="startBtn">INICIAR SISTEMA</button>
    </div>

    <div id="hud">
        <div id="t0" class="track active">>> [1] SUB-BASS</div>
        <div id="t1" class="track">>> [2] ATMOSFERA</div>
        <div id="t2" class="track">>> [3] ACID LEAD</div>
        <div id="t3" class="track">>> [4] RUIDO BLANCO</div>
        <div style="margin-top: 10px; color: #aaa;">Estado: EN LÍNEA (GitHub)</div>
    </div>

    <canvas id="scope"></canvas>

    <script>
        // ==========================================
        // CONFIGURACIÓN
        // ==========================================
        const CONFIG = {
            steps: 32,      // Resolución del rodillo
            tracks: 4,      // Número de pistas
            bpm: 120,       // Velocidad
            radius: 6       // Tamaño del cilindro
        };

        // Estado del sistema
        let activeTrack = 0;
        let isPlaying = false;
        let currentStep = 0;
        
        // Memoria del secuenciador (Matriz segura)
        const sequenceData = [];
        for(let i=0; i<CONFIG.tracks; i++) {
            sequenceData.push(new Array(CONFIG.steps).fill(null));
        }

        // ==========================================
        // 1. MOTOR DE AUDIO (WEB AUDIO API)
        // ==========================================
        const AudioEngine = {
            ctx: null,
            analyser: null,
            masterGain: null,

            init: function() {
                // Compatibilidad de navegadores
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                
                // Master Fader
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;

                // Analizador visual
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 256;

                // Efecto Delay (Eco)
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.25; 
                const feedback = this.ctx.createGain();
                feedback.gain.value = 0.3;

                // Conexiones
                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Ruta del efecto
                this.masterGain.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                feedback.connect(this.ctx.destination);
                
                // Asegurar que el audio arranque
                if(this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            play: function(track, noteIdx) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // --- DISEÑO DE SONIDO POR PISTA ---
                
                // Pista 1: Bajos
                if(track === 0) { 
                    osc.type = 'sawtooth';
                    osc.frequency.value = 55 + (noteIdx * 11);
                    // Filtro Lowpass para suavizar
                    const f = this.ctx.createBiquadFilter();
                    f.type = 'lowpass';
                    f.frequency.setValueAtTime(600, t);
                    f.frequency.linearRampToValueAtTime(100, t+0.3);
                    
                    osc.connect(f);
                    f.connect(gain);
                    
                    gain.gain.setValueAtTime(0.8, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                } 
                // Pista 2: Atmósfera
                else if(track === 1) { 
                    osc.type = 'sine';
                    osc.frequency.value = 220 + (noteIdx * 55);
                    
                    osc.connect(gain);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.3, t+0.1);
                    gain.gain.linearRampToValueAtTime(0, t+1.5);
                }
                // Pista 3: Acid / Lead
                else if(track === 2) { 
                    osc.type = 'square';
                    osc.frequency.value = 110 + (noteIdx * 110);
                    
                    const f = this.ctx.createBiquadFilter();
                    f.type = 'lowpass';
                    f.Q.value = 10; // Resonancia
                    f.frequency.setValueAtTime(200, t);
                    f.frequency.linearRampToValueAtTime(2000, t+0.1); // Wah effect
                    
                    osc.connect(f);
                    f.connect(gain);
                    
                    gain.gain.setValueAtTime(0.2, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t+0.3);
                } 
                // Pista 4: Ruido / Percusión
                else { 
                    osc.type = 'triangle'; // Usamos oscilador simple para evitar errores de buffer
                    osc.frequency.value = 100 + Math.random()*500;
                    
                    osc.connect(gain);
                    gain.gain.setValueAtTime(0.5, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t+0.05);
                }

                if(track !== 0 && track !== 2) osc.connect(gain); // Si no usó filtro
                
                gain.connect(this.masterGain);
                
                osc.start();
                osc.stop(t+2.0);
            }
        };

        // ==========================================
        // 2. MOTOR GRÁFICO (THREE.JS)
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 10, 40);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 22);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- CILINDRO PRINCIPAL ---
        const drumGroup = new THREE.Group();
        // Cilindro
        const drumGeo = new THREE.CylinderGeometry(CONFIG.radius, CONFIG.radius, 12, 64);
        drumGeo.rotateZ(Math.PI/2); // Acostarlo
        const drumMat = new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.6, metalness: 0.8 });
        const drum = new THREE.Mesh(drumGeo, drumMat);
        drumGroup.add(drum);

        // Anillos divisores (Visual)
        for(let i=0; i<CONFIG.tracks; i++) {
            const rGeo = new THREE.TorusGeometry(CONFIG.radius+0.05, 0.05, 16, 100);
            const rMesh = new THREE.Mesh(rGeo, new THREE.MeshBasicMaterial({color: 0x444444}));
            rMesh.rotateY(Math.PI/2);
            rMesh.position.x = ((i / 3) * 6) - 3; // Distribuir
            drumGroup.add(rMesh);
        }
        scene.add(drumGroup);

        // --- BRAZOS LECTORES ---
        const arms = [];
        const indicators = [];
        
        for(let i=0; i<CONFIG.tracks; i++) {
            const armGroup = new THREE.Group();
            const xPos = ((i / 3) * 6) - 3;
            armGroup.position.set(xPos, CONFIG.radius + 1.5, 0);
            
            // Estructura del brazo
            const box = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), new THREE.MeshStandardMaterial({color: 0x333333}));
            
            // Luz indicadora
            const bulbGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const bulbMat = new THREE.MeshBasicMaterial({color: 0x330000});
            const bulb = new THREE.Mesh(bulbGeo, bulbMat);
            bulb.position.set(0, 1, 0.5);
            
            armGroup.add(box);
            armGroup.add(bulb);
            
            indicators.push(bulb);
            arms.push(armGroup);
            scene.add(armGroup);
        }

        // --- LUCES ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);
        
        const spot = new THREE.SpotLight(0xffaa00, 1.5);
        spot.position.set(15, 20, 10);
        spot.castShadow = true;
        scene.add(spot);

        const blueLight = new THREE.PointLight(0x00ccff, 1, 20);
        blueLight.position.set(-10, 5, 5);
        scene.add(blueLight);

        // ==========================================
        // 3. LÓGICA DEL SISTEMA (CORE)
        // ==========================================
        
        // Función para crear "Púas" (Notas visuales)
        function createPin(track, step) {
            // Eliminar si ya existe
            if(sequenceData[track][step] && sequenceData[track][step].mesh) {
                drumGroup.remove(sequenceData[track][step].mesh);
            }

            const geo = new THREE.BoxGeometry(0.3, 0.6, 0.3);
            const colors = [0xff0044, 0x00ffcc, 0xffff00, 0xffffff]; // Colores por pista
            const mat = new THREE.MeshBasicMaterial({ color: colors[track] });
            const mesh = new THREE.Mesh(geo, mat);

            // Calcular posición en el círculo
            const angle = (step / CONFIG.steps) * Math.PI * 2;
            const r = CONFIG.radius; // En la superficie del cilindro
            const x = ((track / 3) * 6) - 3;

            mesh.position.set(x, Math.sin(angle)*r, Math.cos(angle)*r);
            mesh.lookAt(x, 0, 0); // Apuntar hacia afuera
            
            drumGroup.add(mesh);
            return mesh;
        }

        // Bucle de Tiempo
        let lastTime = 0;
        const stepDuration = (60 / CONFIG.bpm) / 4; // Semicorchea

        function loop(time) {
            requestAnimationFrame(loop);
            
            // Delta time para movimiento suave
            const dt = (time - lastTime) / 1000;
            lastTime = time;

            if(isPlaying) {
                // Rotar el cilindro visualmente
                const fullRotation = CONFIG.steps * stepDuration;
                drumGroup.rotation.x += (Math.PI * 2 * dt) / fullRotation;

                // --- MATEMÁTICA SEGURA (Evita el error rojo) ---
                let rot = drumGroup.rotation.x % (Math.PI * 2);
                if(rot < 0) rot += Math.PI * 2;
                
                // Calcular en qué paso estamos (0 al 31)
                let step = Math.floor((rot / (Math.PI * 2)) * CONFIG.steps);
                
                // Asegurar que el índice esté dentro del rango
                if(step >= CONFIG.steps) step = 0;
                if(step < 0) step = CONFIG.steps - 1;

                if(step !== currentStep) {
                    currentStep = step;
                    triggerStep(currentStep);
                }
            }

            renderer.render(scene, camera);
            drawScope();
        }

        function triggerStep(step) {
            for(let t=0; t<CONFIG.tracks; t++) {
                // Reset visual
                indicators[t].material.color.setHex(0x330000);
                indicators[t].scale.set(1,1,1);

                const data = sequenceData[t][step];
                
                // Si hay nota...
                if(data && data.note !== undefined) {
                    // SONIDO
                    AudioEngine.play(t, data.note);
                    
                    // LUZ
                    indicators[t].material.color.setHex(0xff0000);
                    indicators[t].scale.set(1.5, 1.5, 1.5);
                    
                    // MOVIMIENTO MECÁNICO (Golpe del brazo)
                    const arm = arms[t];
                    arm.position.y -= 0.3;
                    setTimeout(() => { arm.position.y += 0.3 }, 80);
                }
            }
        }

        // ==========================================
        // 4. INTERACCIÓN (TECLADO Y MOUSE)
        // ==========================================

        // Botón de inicio
        document.getElementById('startBtn').addEventListener('click', () => {
            AudioEngine.init(); // Arrancar audio
            isPlaying = true;
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);
            loop(0);
        });

        // Teclado
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            
            // Cambiar Pista (1, 2, 3, 4)
            if(['1','2','3','4'].includes(k)) {
                activeTrack = parseInt(k) - 1;
                // Actualizar interfaz
                document.querySelectorAll('.track').forEach((el, i) => {
                    if(i === activeTrack) el.classList.add('active');
                    else el.classList.remove('active');
                });
            }

            // Tocar/Grabar Notas (Q -> P)
            const notes = "qwertyuiop";
            const idx = notes.indexOf(k);
            if(idx > -1) {
                // Guardar
                const mesh = createPin(activeTrack, currentStep);
                sequenceData[activeTrack][currentStep] = { note: idx, mesh: mesh };
                // Feedback auditivo inmediato
                AudioEngine.play(activeTrack, idx);
            }

            // Borrar Pista (Espacio)
            if(e.code === 'Space') {
                for(let s=0; s<CONFIG.steps; s++) {
                    if(sequenceData[activeTrack][s]) {
                        drumGroup.remove(sequenceData[activeTrack][s].mesh);
                        sequenceData[activeTrack][s] = null;
                    }
                }
            }
        });

        // Osciloscopio Canvas
        const cvs = document.getElementById('scope');
        const cCtx = cvs.getContext('2d');
        
        function drawScope() {
            if(!AudioEngine.analyser) return;
            const w = cvs.width;
            const h = cvs.height;
            const buffer = new Uint8Array(AudioEngine.analyser.frequencyBinCount);
            AudioEngine.analyser.getByteTimeDomainData(buffer);

            // Fondo semi-transparente para efecto rastro
            cCtx.fillStyle = 'rgba(0, 20, 0, 0.2)';
            cCtx.fillRect(0,0,w,h);
            
            cCtx.lineWidth = 2;
            cCtx.strokeStyle = '#00ff00';
            cCtx.beginPath();

            const slice = w / buffer.length;
            let x = 0;
            for(let i=0; i<buffer.length; i++) {
                const v = buffer[i] / 128.0;
                const y = v * h / 2;
                if(i===0) cCtx.moveTo(x,y);
                else cCtx.lineTo(x,y);
                x += slice;
            }
            cCtx.stroke();
        }

        // Ajustar ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
