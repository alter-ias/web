<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>CYLINDER-SYNTH: Mechanical Sequencer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s;
        }
        
        h1 { color: #ff9900; text-shadow: 0 0 20px #ff3300; font-size: 3rem; letter-spacing: 10px; margin: 0; }
        p { color: #aaa; margin-top: 10px; }
        
        button {
            margin-top: 30px; padding: 15px 40px; border: 2px solid #ff9900; background: transparent;
            color: #ff9900; font-size: 1.2rem; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(255, 153, 0, 0.2); transition: 0.3s;
        }
        button:hover { background: #ff9900; color: #000; box-shadow: 0 0 30px #ff9900; }

        #hud {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            pointer-events: none; text-shadow: 0 0 5px #00ffcc;
        }
        .track-indicator { margin-bottom: 5px; opacity: 0.5; transition: 0.2s; }
        .active-track { opacity: 1; font-weight: bold; color: #ff0055; text-shadow: 0 0 10px #ff0055; }

        #scope {
            position: absolute; bottom: 20px; right: 20px;
            width: 300px; height: 100px; border: 1px solid #333;
            background: #001100; opacity: 0.8;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="overlay">
        <h1>MECANISMO DE SECUENCIA</h1>
        <p>[ SISTEMA DE RODILLO PROGRAMABLE V.4.0 ]</p>
        <p>1-4: Cambiar Pista | Q-P: Insertar Púas (Notas) | ESPACIO: Limpiar</p>
        <button id="startBtn">INICIAR ROTACIÓN</button>
    </div>

    <div id="hud">
        <div id="t1" class="track-indicator active-track">>> TRACK 1: SUB-BASS (MECÁNICO)</div>
        <div id="t2" class="track-indicator">>> TRACK 2: ATMOS-COILS</div>
        <div id="t3" class="track-indicator">>> TRACK 3: ACID LEAD</div>
        <div id="t4" class="track-indicator">>> TRACK 4: NOISE PERCUSSION</div>
        <br>
        <div id="bpm">RPM: 30.0 (120 BPM)</div>
    </div>

    <canvas id="scope"></canvas>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // CONFIGURACIÓN GLOBAL
        // ==========================================
        const CONFIG = {
            steps: 32, // Pasos en el cilindro (resolución)
            tracks: 4,
            bpm: 120,
            cylinderRadius: 6,
            cylinderWidth: 10
        };

        // Estado del secuenciador
        let currentStep = 0;
        let activeTrack = 0; // 0 a 3
        let isPlaying = false;
        
        // Matriz de datos: [Track][Step] = null o {freq, mesh}
        const sequenceData = Array(CONFIG.tracks).fill().map(() => Array(CONFIG.steps).fill(null));

        // ==========================================
        // 1. MOTOR DE AUDIO (SYNTH)
        // ==========================================
        const AudioEngine = {
            ctx: null,
            masterGain: null,
            analyser: null,
            reverb: null,

            init: function() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                
                // Analizador para el osciloscopio visual
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;

                // Efecto Delay/Reverb simple
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.3; // Syncopated feel
                const feedback = this.ctx.createGain();
                feedback.gain.value = 0.4;
                const filter = this.ctx.createBiquadFilter();
                filter.frequency.value = 1000;

                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Ruta de efectos
                this.masterGain.connect(delay);
                delay.connect(filter);
                filter.connect(feedback);
                feedback.connect(delay);
                feedback.connect(this.ctx.destination);
            },

            // Sintetizador polifónico simple según el track
            playNote: function(trackIndex, noteIndex) {
                if(!this.ctx) return;
                const now = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const mod = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();

                // Definición de escalas y timbres por pista
                if(trackIndex === 0) { // BASS
                    osc.type = 'sawtooth';
                    osc.frequency.value = 55 + (noteIndex * 11); // Escala grave
                    gain.gain.setValueAtTime(0.8, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    
                    // Filtro para bajos
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, now);
                    filter.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                    osc.connect(filter); filter.connect(gain);
                } 
                else if (trackIndex === 1) { // ATMOS
                    osc.type = 'sine';
                    osc.frequency.value = 220 + (noteIndex * 55); 
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.3, now + 0.1);
                    gain.gain.linearRampToValueAtTime(0, now + 1.5);
                    osc.connect(gain);
                }
                else if (trackIndex === 2) { // ACID LEAD
                    osc.type = 'square';
                    const freqs = [440, 523, 587, 659, 783];
                    osc.frequency.value = freqs[noteIndex % freqs.length] * (noteIndex > 4 ? 2 : 1);
                    
                    // Filtro resonante (Acid style)
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.Q.value = 15;
                    filter.frequency.setValueAtTime(400, now);
                    filter.frequency.linearRampToValueAtTime(3000, now + 0.1);
                    filter.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                    
                    osc.connect(filter); filter.connect(gain);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                }
                else { // NOISE PERC
                    const bufferSize = this.ctx.sampleRate * 0.1;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = noteIndex % 2 === 0 ? 'lowpass' : 'highpass';
                    filter.frequency.value = noteIndex * 500 + 200;
                    
                    noise.connect(filter); filter.connect(gain);
                    noise.start();
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    
                    gain.connect(this.masterGain);
                    return; // Salida temprana para el ruido
                }

                gain.connect(this.masterGain);
                osc.start();
                osc.stop(now + 2);
            }
        };

        // ==========================================
        // 2. ESCENA 3D (VISUALIZADOR MECÁNICO)
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 18);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- MATERIALES ---
        const matCylinder = new THREE.MeshStandardMaterial({ 
            color: 0x111111, roughness: 0.4, metalness: 0.8,
            map: null // Podríamos añadir textura de "suciedad" aquí
        });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xccaa00, roughness: 0.2, metalness: 1.0 });
        const matGlowing = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
        const matReader = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });

        // --- EL CILINDRO MAESTRO (Imágenes 1 y 3) ---
        const drumGroup = new THREE.Group();
        const drumGeo = new THREE.CylinderGeometry(CONFIG.cylinderRadius, CONFIG.cylinderRadius, CONFIG.cylinderWidth, 64);
        // Rotar geometría para que gire sobre eje X horizontal
        drumGeo.rotateZ(Math.PI / 2); 
        const drumMesh = new THREE.Mesh(drumGeo, matCylinder);
        drumGroup.add(drumMesh);

        // Líneas divisorias de pistas
        for(let i=0; i<CONFIG.tracks; i++) {
            const ringGeo = new THREE.TorusGeometry(CONFIG.cylinderRadius + 0.05, 0.05, 16, 100);
            const ring = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({color: 0x333333}));
            ring.rotateY(Math.PI / 2);
            // Posicionar anillos equitativamente a lo largo del cilindro
            const zPos = ((i / (CONFIG.tracks - 1)) * 6) - 3; 
            ring.position.x = zPos;
            drumGroup.add(ring);
        }

        scene.add(drumGroup);

        // --- BRAZOS LECTORES (Inspiración mecánica) ---
        const armsGroup = new THREE.Group();
        const armGeo = new THREE.BoxGeometry(0.5, 4, 0.5);
        
        const indicators = []; // Para iluminar cuando suene

        for(let i=0; i<CONFIG.tracks; i++) {
            const arm = new THREE.Mesh(armGeo, matReader);
            const xPos = ((i / (CONFIG.tracks - 1)) * 6) - 3; 
            arm.position.set(xPos, CONFIG.cylinderRadius + 2, 0);
            
            // Punta lectora
            const tip = new THREE.Mesh(new THREE.ConeGeometry(0.2, 1, 16), matGold);
            tip.position.y = -2.5;
            tip.rotation.x = Math.PI;
            arm.add(tip);

            // Luz indicadora en el brazo
            const lightGeo = new THREE.SphereGeometry(0.3);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0x220000 });
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.set(0, 1, 0.5);
            arm.add(light);
            indicators.push(lightMat);

            armsGroup.add(arm);
        }
        scene.add(armsGroup);

        // --- ILUMINACIÓN ---
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0xffaa00, 50);
        spotLight.position.set(10, 15, 5);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        const blueLight = new THREE.PointLight(0x00ccff, 2, 20);
        blueLight.position.set(-5, -5, 5);
        scene.add(blueLight);

        // ==========================================
        // 3. LÓGICA DEL SECUENCIADOR
        // ==========================================
        
        // Función para añadir una "Púa" visual al cilindro
        function addPinToDrum(trackIdx, stepIdx, noteVal) {
            const pinGeo = new THREE.BoxGeometry(0.4, 0.8, 0.4);
            const color = [0xff0055, 0x00ffcc, 0xffff00, 0xffffff][trackIdx];
            const pinMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const pin = new THREE.Mesh(pinGeo, pinMat);

            // Calcular posición en el cilindro
            const angle = (stepIdx / CONFIG.steps) * Math.PI * 2;
            const radius = CONFIG.cylinderRadius;
            const xPos = ((trackIdx / (CONFIG.tracks - 1)) * 6) - 3;
            
            // Posicionamiento polar a cartesiano
            pin.position.set(xPos, Math.sin(angle) * radius, Math.cos(angle) * radius);
            pin.lookAt(xPos, 0, 0); // Que apunte hacia afuera
            
            drumGroup.add(pin);
            
            return pin;
        }

        // Bucle principal de tiempo
        let lastTime = 0;
        let accumulator = 0;
        const stepTime = (60 / CONFIG.bpm) / 4; // 16th notes

        function sequencerLoop(time) {
            if(!isPlaying) return;

            const delta = time - lastTime;
            lastTime = time;
            accumulator += delta;

            // Rotación visual suave continua
            // 1 vuelta completa = CONFIG.steps * stepTime
            const fullRotationTime = CONFIG.steps * stepTime; 
            const rotationPerFrame = (delta / fullRotationTime) * Math.PI * 2;
            drumGroup.rotation.x += rotationPerFrame;

            // Lógica discreta de pasos (Trigger audio)
            // Calculamos qué paso está bajo el "brazo lector" (ángulo 0 o PI/2 según setup)
            // En ThreeJS, posición 0,0,radius es angulo 0.
            
            // Ajustar rotación para calcular índice
            let rotation = drumGroup.rotation.x % (Math.PI * 2);
            if(rotation < 0) rotation += Math.PI * 2;
            
            // Invertir para mapear al array (porque gira hacia "atras" visualmente)
            const virtualStepIndex = Math.floor( (rotation / (Math.PI*2)) * CONFIG.steps );

            if(virtualStepIndex !== currentStep) {
                currentStep = virtualStepIndex;
                triggerStep(currentStep);
            }
        }

        function triggerStep(stepIndex) {
            // Revisar las 4 pistas
            for(let t=0; t<CONFIG.tracks; t++) {
                const data = sequenceData[t][stepIndex];
                
                // Apagar luz indicadora
                indicators[t].color.setHex(0x220000);

                if(data !== null) {
                    // REPRODUCIR SONIDO
                    AudioEngine.playNote(t, data.noteVal);
                    
                    // Efecto visual en el brazo lector
                    indicators[t].color.setHex(0xff0000); // Rojo brillante cuando lee
                    
                    // Pequeño "salto" visual del brazo
                    const arm = armsGroup.children[t];
                    arm.position.y += 0.2;
                    setTimeout(() => { arm.position.y -= 0.2 }, 100);
                }
            }
        }

        // ==========================================
        // 4. INTERACCIÓN Y CANVAS SCOPE
        // ==========================================
        
        // Dibujar osciloscopio (como en el video)
        const canvas = document.getElementById('scope');
        const canvasCtx = canvas.getContext('2d');
        
        function drawScope() {
            requestAnimationFrame(drawScope);
            if(!AudioEngine.analyser) return;

            const bufferLength = AudioEngine.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            AudioEngine.analyser.getByteTimeDomainData(dataArray);

            canvasCtx.fillStyle = 'rgba(0, 20, 0, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#00ff00';
            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for(let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;
                if(i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                x += sliceWidth;
            }
            canvasCtx.stroke();
        }

        // Inputs de teclado
        document.addEventListener('keydown', (e) => {
            if(!isPlaying) return;
            
            const key = e.key.toLowerCase();
            
            // Selector de Pista
            if(['1','2','3','4'].includes(key)) {
                activeTrack = parseInt(key) - 1;
                document.querySelectorAll('.track-indicator').forEach((el, i) => {
                    el.classList.toggle('active-track', i === activeTrack);
                });
                return;
            }
            
            // Inserción de notas (Q-P)
            const noteKeys = "qwertyuiop";
            const noteIndex = noteKeys.indexOf(key);
            
            if(noteIndex !== -1) {
                // GRABACIÓN EN VIVO (QUANTIZED)
                // Calculamos el step actual aproximado + un pequeño offset para latencia humana
                // Grabamos en el paso actual para que suene INMEDIATAMENTE la próxima vuelta
                
                if(sequenceData[activeTrack][currentStep] === null) {
                    // Guardar datos
                    sequenceData[activeTrack][currentStep] = { noteVal: noteIndex };
                    // Crear representación visual
                    const mesh = addPinToDrum(activeTrack, currentStep, noteIndex);
                    sequenceData[activeTrack][currentStep].mesh = mesh;
                    
                    // Feedback instantáneo de audio
                    AudioEngine.playNote(activeTrack, noteIndex);
                } else {
                    // BORRAR si ya existe (Toggle)
                    const existing = sequenceData[activeTrack][currentStep];
                    drumGroup.remove(existing.mesh);
                    sequenceData[activeTrack][currentStep] = null;
                }
            }

            if(e.code === 'Space') {
                // Limpiar pista actual
                for(let i=0; i<CONFIG.steps; i++) {
                    if(sequenceData[activeTrack][i]) {
                        drumGroup.remove(sequenceData[activeTrack][i].mesh);
                        sequenceData[activeTrack][i] = null;
                    }
                }
            }
        });

        // Loop principal de animación
        function animate(time) {
            requestAnimationFrame(animate);
            sequencerLoop(time / 1000);
            renderer.render(scene, camera);
        }

        // Arranque
        document.getElementById('startBtn').addEventListener('click', () => {
            AudioEngine.init();
            isPlaying = true;
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);
            lastTime = performance.now() / 1000;
            animate();
            drawScope();
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
