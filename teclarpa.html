<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sintetizador Espectral 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* UI Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(0,0,0,0.95), rgba(10,20,30,0.95));
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #00ffcc; z-index: 100; transition: opacity 0.5s ease;
        }
        
        h1 { font-size: 3rem; margin: 0; text-transform: uppercase; letter-spacing: 10px; text-shadow: 0 0 20px #00ffcc; }
        h3 { font-weight: 300; opacity: 0.8; margin-bottom: 30px; }
        
        .controls-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; text-align: left; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 10px; border: 1px solid #00ffcc; }
        .controls-grid div { margin: 5px 0; }
        .key { color: #fff; font-weight: bold; background: #00ffcc; color: #000; padding: 2px 6px; border-radius: 4px; margin-right: 10px; }
        
        .start-btn {
            margin-top: 40px; padding: 15px 40px; font-size: 1.2rem;
            background: transparent; color: #00ffcc; border: 2px solid #00ffcc;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: all 0.3s;
        }
        .start-btn:hover { background: #00ffcc; color: #000; box-shadow: 0 0 30px #00ffcc; }
        
        #hud {
            position: absolute; bottom: 20px; left: 20px; color: #00ffcc;
            font-family: monospace; pointer-events: none; opacity: 0.7;
        }
        
        .hidden { opacity: 0; pointer-events: none; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="overlay">
        <h1>Spectral Synth</h1>
        <h3>Instrumento Polifónico Web</h3>
        
        <div class="controls-grid">
            <div><span class="key">A...Ñ</span> Teclas Blancas (Notas)</div>
            <div><span class="key">W,E,T...</span> Teclas Negras (Sostenidos)</div>
            <div><span class="key">Z...M</span> Octava Grave (Bajos)</div>
            <div><span class="key">Espacio</span> Sustain / Hold</div>
            <div><span class="key">1 - 3</span> Cambiar Onda (Saw/Sqr/Tri)</div>
            <div><span class="key">5 - 9</span> Filtro LowPass (Brillo)</div>
            <div><span class="key">Mouse X</span> Panning (Estéreo)</div>
            <div><span class="key">Mouse Y</span> Modulación</div>
        </div>

        <button class="start-btn" id="startBtn">INICIAR SISTEMA</button>
    </div>

    <div id="hud">SYSTEM READY...</div>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. MOTOR DE AUDIO (PROFESIONAL)
        // ==========================================
        const AudioEngine = {
            ctx: null,
            masterGain: null,
            filter: null,
            delay: null,
            waveType: 'sawtooth',
            activeOscillators: {}, // Rastreo de notas activas
            
            init: function() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Master Limiter (para no saturar)
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                
                // Filtro Global (Lowpass) - Controlado por números
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 5000; // Abierto por defecto
                this.filter.Q.value = 1;

                // Efecto Delay (Eco)
                this.delay = this.ctx.createDelay();
                this.delay.delayTime.value = 0.3; // 300ms
                const delayFeedback = this.ctx.createGain();
                delayFeedback.gain.value = 0.4; // 40% feedback

                // Ruteo de efectos: Filter -> Master -> (Delay Loop)
                this.filter.connect(this.masterGain);
                this.filter.connect(this.delay);
                this.delay.connect(delayFeedback);
                delayFeedback.connect(this.delay);
                this.delay.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            },

            setWave: function(type) {
                this.waveType = type;
                return type;
            },

            setFilter: function(val) {
                // Mapear valor 0-1 a frecuencia 100Hz - 10000Hz
                const freq = 100 + (val * 10000);
                if(this.ctx) this.filter.frequency.rampToValueAtTime(freq, this.ctx.currentTime + 0.1);
            },

            triggerAttack: function(freq, keyId) {
                if (!this.ctx) return;
                if (this.ctx.state === 'suspended') this.ctx.resume();

                // Evitar superposición fea si se presiona repetido
                if (this.activeOscillators[keyId]) {
                    this.triggerRelease(keyId);
                }

                const osc = this.ctx.createOscillator();
                const gainEnv = this.ctx.createGain();
                
                osc.type = this.waveType;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                
                // Detune random para sonido analógico gordo
                osc.detune.value = (Math.random() * 10) - 5; 

                // Envolvente (ADSR simulado)
                const now = this.ctx.currentTime;
                gainEnv.gain.setValueAtTime(0, now);
                gainEnv.gain.linearRampToValueAtTime(0.5, now + 0.05); // Attack rápido
                gainEnv.gain.exponentialRampToValueAtTime(0.3, now + 0.5); // Decay

                osc.connect(gainEnv);
                gainEnv.connect(this.filter);

                osc.start();

                this.activeOscillators[keyId] = { osc, gainEnv };
            },

            triggerRelease: function(keyId) {
                if (!this.ctx || !this.activeOscillators[keyId]) return;

                const { osc, gainEnv } = this.activeOscillators[keyId];
                const now = this.ctx.currentTime;

                // Release suave
                gainEnv.gain.cancelScheduledValues(now);
                gainEnv.gain.setValueAtTime(gainEnv.gain.value, now);
                gainEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.5); // 0.5s release

                osc.stop(now + 0.51);
                delete this.activeOscillators[keyId];
            }
        };

        // ==========================================
        // 2. MAPEO MUSICAL (TECLADO LATAM)
        // ==========================================
        
        // Frecuencias exactas para notas musicales
        const NOTE_FREQS = {
            'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56, 'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00, 'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13, 'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00, 'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25, 'E5': 659.25, 'F5': 698.46
        };

        // Mapa de Teclas -> Notas (Estilo Chromatic Piano)
        const KEY_MAP = {
            // Fila Inferior (Graves/Bajos)
            'z': { note: 'C3', color: 0xffffff },
            's': { note: 'C#3', color: 0x222222, isBlack: true }, // Mapeo cruzado para simular piano real
            'x': { note: 'D3', color: 0xffffff },
            'd': { note: 'D#3', color: 0x222222, isBlack: true },
            'c': { note: 'E3', color: 0xffffff },
            'v': { note: 'F3', color: 0xffffff },
            'g': { note: 'F#3', color: 0x222222, isBlack: true },
            'b': { note: 'G3', color: 0xffffff },
            'h': { note: 'G#3', color: 0x222222, isBlack: true },
            'n': { note: 'A3', color: 0xffffff },
            'j': { note: 'A#3', color: 0x222222, isBlack: true },
            'm': { note: 'B3', color: 0xffffff },
            
            // Fila Superior (Melodía Principal)
            'q': { note: 'C4', color: 0xffffff },
            '2': { note: 'C#4', color: 0x111111, isBlack: true }, // A veces se usa números, pero usaremos el layout "Piano" abajo
            
            // REHACIENDO MAPEO PARA QUE SEA "QWERTY PIANO" ESTÁNDAR (Más intuitivo)
            // Blancas
            'a': { note: 'C4', color: 0x00ffcc }, 
            's': { note: 'D4', color: 0x00ffcc },
            'd': { note: 'E4', color: 0x00ffcc },
            'f': { note: 'F4', color: 0x00ffcc },
            'g': { note: 'G4', color: 0x00ffcc },
            'h': { note: 'A4', color: 0x00ffcc },
            'j': { note: 'B4', color: 0x00ffcc },
            'k': { note: 'C5', color: 0x00ffcc },
            'l': { note: 'D5', color: 0x00ffcc },
            'ñ': { note: 'E5', color: 0x00ffcc },
            
            // Negras (Sostenidos) - Justo arriba
            'w': { note: 'C#4', color: 0xff0055, isBlack: true },
            'e': { note: 'D#4', color: 0xff0055, isBlack: true },
            't': { note: 'F#4', color: 0xff0055, isBlack: true },
            'y': { note: 'G#4', color: 0xff0055, isBlack: true },
            'u': { note: 'A#4', color: 0xff0055, isBlack: true },
            'o': { note: 'C#5', color: 0xff0055, isBlack: true },
            'p': { note: 'D#5', color: 0xff0055, isBlack: true },
            
            // Fila Z (Bajos Octava 3)
            'z': { note: 'C3', color: 0x0088ff },
            'x': { note: 'D3', color: 0x0088ff },
            'c': { note: 'E3', color: 0x0088ff },
            'v': { note: 'F3', color: 0x0088ff },
            'b': { note: 'G3', color: 0x0088ff },
            'n': { note: 'A3', color: 0x0088ff },
            'm': { note: 'B3', color: 0x0088ff }
        };

        // ==========================================
        // 3. ESCENA 3D (VISUALIZACIÓN)
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.03);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, -5, 12);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Grupo principal del instrumento
        const instrumentGroup = new THREE.Group();
        scene.add(instrumentGroup);

        // Mapa de objetos 3D para animarlos
        const keyMeshes = {};

        // Geometrías reusables
        const geoHex = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 6); // Teclas hexagonales
        const geoBox = new THREE.BoxGeometry(0.8, 0.5, 2); // Teclas rectangulares

        // Crear teclado visual
        Object.keys(KEY_MAP).forEach((keyChar) => {
            const data = KEY_MAP[keyChar];
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                emissive: data.color,
                emissiveIntensity: 0.1,
                roughness: 0.2,
                metalness: 0.8
            });

            // Posicionamiento basado en un layout físico imaginario
            const mesh = new THREE.Mesh(data.isBlack ? geoHex : geoBox, mat);
            
            // Calcular posición X según orden en teclado
            let xPos = 0;
            let zPos = 0;
            const keyOrder = "zxcvbnm,.-asdfghjklñqwertyuiop";
            const index = keyOrder.indexOf(keyChar);
            
            // Organizar en 3 filas espaciales
            if ("zxcvbnm,.-".includes(keyChar)) { zPos = 4; xPos = (index) * 1.5 - 6; }
            else if ("asdfghjklñ".includes(keyChar)) { zPos = 0; xPos = (index - 10) * 1.5 - 6; }
            else if ("qwertyuiop".includes(keyChar)) { zPos = -4; xPos = (index - 21) * 1.5 - 6; }

            // Ajuste especial para teclas negras (arriba y entre medias)
            if (data.isBlack) {
                mesh.position.y = 0.5; // Más altas
                mesh.rotation.y = Math.PI / 6; // Rotar hexágono
            }

            mesh.position.x = xPos;
            mesh.position.z = zPos;
            
            mesh.userData = { ...data, baseY: mesh.position.y };
            
            // Añadir texto flotante (Simplificado con canvas sprite para no cargar fuentes pesadas)
            const label = createTextSprite(keyChar.toUpperCase() + "\n" + data.note);
            label.position.set(0, 1.5, 0);
            mesh.add(label);

            instrumentGroup.add(mesh);
            keyMeshes[keyChar] = mesh;
        });

        // Suelo Grid "Retro"
        const gridHelper = new THREE.GridHelper(100, 50, 0x00ffcc, 0x111111);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        // Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00ffcc, 2, 50);
        pointLight.position.set(0, 5, 5);
        scene.add(pointLight);

        // Función auxiliar para texto
        function createTextSprite(message) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 64;
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0,0,128,64);
            ctx.fillStyle = "#ffffff";
            ctx.font = "bold 24px Arial";
            ctx.textAlign = "center";
            ctx.fillText(message.split('\n')[0], 64, 24);
            ctx.fillStyle = "#00ffcc";
            ctx.font = "18px Arial";
            ctx.fillText(message.split('\n')[1], 64, 48);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(2, 1, 1);
            return sprite;
        }

        // ==========================================
        // 4. LÓGICA DE INTERACCIÓN
        // ==========================================
        
        // Manejo del estado visual y sonoro
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return; // Evitar disparo continuo
            
            const key = e.key.toLowerCase();
            
            // 1. Controles de Sistema (Números)
            if (key === '1') { AudioEngine.setWave('sine'); updateHud("WAVE: SINE"); }
            if (key === '2') { AudioEngine.setWave('square'); updateHud("WAVE: SQUARE"); }
            if (key === '3') { AudioEngine.setWave('sawtooth'); updateHud("WAVE: SAW"); }
            if (['5','6','7','8','9'].includes(key)) {
                const val = (parseInt(key) - 5) / 4; // 0.0 a 1.0
                AudioEngine.setFilter(val);
                updateHud(`FILTER CUTOFF: ${Math.floor(val*100)}%`);
            }

            // 2. Notas Musicales
            if (KEY_MAP[key] && keyMeshes[key]) {
                const data = KEY_MAP[key];
                const mesh = keyMeshes[key];

                // Audio
                AudioEngine.triggerAttack(NOTE_FREQS[data.note], key);

                // Visual
                mesh.position.y -= 0.3; // Hundir tecla
                mesh.material.emissive.setHex(0xffffff); // Flash blanco
                mesh.material.emissiveIntensity = 2;
                
                // Efecto de partículas o luz dinámica
                pointLight.position.x = mesh.position.x;
                pointLight.position.z = mesh.position.z;
                pointLight.intensity = 5;

                updateHud(`NOTE: ${data.note} (${key.toUpperCase()})`);
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            
            if (KEY_MAP[key] && keyMeshes[key]) {
                const mesh = keyMeshes[key];
                
                // Audio Release
                AudioEngine.triggerRelease(key);

                // Visual Reset
                mesh.position.y = mesh.userData.baseY;
                mesh.material.emissive.setHex(mesh.userData.color); // Volver a color original
                mesh.material.emissiveIntensity = 0.1;
                pointLight.intensity = 2;
            }
        });

        function updateHud(text) {
            const hud = document.getElementById('hud');
            hud.innerText = text;
            hud.style.opacity = 1;
            setTimeout(() => { hud.style.opacity = 0.7 }, 1000);
        }

        // ==========================================
        // 5. ANIMACIÓN Y ARRANQUE
        // ==========================================

        document.getElementById('startBtn').addEventListener('click', () => {
            AudioEngine.init();
            document.getElementById('overlay').classList.add('hidden');
        });

        // Mouse interaction for Pitch/Mod
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            
            // Rotar cámara sutilmente
            instrumentGroup.rotation.y = mouseX * 0.1;
            instrumentGroup.rotation.x = mouseY * 0.1;
        });

        function animate() {
            requestAnimationFrame(animate);

            // Animación de reposo (respiración)
            const time = Date.now() * 0.001;
            instrumentGroup.position.y = Math.sin(time) * 0.2;
            
            // Animación del grid
            gridHelper.position.z = (time * 2) % 10; 

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
