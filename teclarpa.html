<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>CYLINDER-SYNTH: Mechanical Sequencer v4.1 (FIXED)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s;
        }
        
        h1 { color: #ff9900; text-shadow: 0 0 20px #ff3300; font-size: 3rem; letter-spacing: 10px; margin: 0; }
        p { color: #aaa; margin-top: 10px; }
        
        button {
            margin-top: 30px; padding: 15px 40px; border: 2px solid #ff9900; background: transparent;
            color: #ff9900; font-size: 1.2rem; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(255, 153, 0, 0.2); transition: 0.3s;
        }
        button:hover { background: #ff9900; color: #000; box-shadow: 0 0 30px #ff9900; }

        #hud {
            position: absolute; top: 20px; left: 20px; color: #00ffcc;
            pointer-events: none; text-shadow: 0 0 5px #00ffcc;
            background: rgba(0,0,0,0.5); padding: 10px;
        }
        .track-indicator { margin-bottom: 5px; opacity: 0.5; transition: 0.2s; }
        .active-track { opacity: 1; font-weight: bold; color: #ff0055; text-shadow: 0 0 10px #ff0055; }

        #scope {
            position: absolute; bottom: 20px; right: 20px;
            width: 300px; height: 100px; border: 1px solid #333;
            background: #001100; opacity: 0.8;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="overlay">
        <h1>MECANISMO DE SECUENCIA</h1>
        <p>[ SISTEMA DE RODILLO PROGRAMABLE V.4.1 ]</p>
        <p>1-4: Cambiar Pista | Q-P: Insertar Púas (Notas) | ESPACIO: Limpiar</p>
        <button id="startBtn">INICIAR ROTACIÓN</button>
    </div>

    <div id="hud">
        <div id="t1" class="track-indicator active-track">>> TRACK 1: SUB-BASS (MECÁNICO)</div>
        <div id="t2" class="track-indicator">>> TRACK 2: ATMOS-COILS</div>
        <div id="t3" class="track-indicator">>> TRACK 3: ACID LEAD</div>
        <div id="t4" class="track-indicator">>> TRACK 4: NOISE PERCUSSION</div>
        <br>
        <div id="bpm">RPM: 30.0 (120 BPM)</div>
        <div style="font-size: 0.8rem; color: #aaa;">Status: OPERATIONAL</div>
    </div>

    <canvas id="scope"></canvas>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // CONFIGURACIÓN GLOBAL
        // ==========================================
        const CONFIG = {
            steps: 32, // Pasos en el cilindro (resolución)
            tracks: 4,
            bpm: 120,
            cylinderRadius: 6,
            cylinderWidth: 10
        };

        // Estado del secuenciador
        let currentStep = 0;
        let activeTrack = 0; // 0 a 3
        let isPlaying = false;
        
        // Matriz de datos: [Track][Step] = null o {noteVal, mesh}
        const sequenceData = Array(CONFIG.tracks).fill().map(() => Array(CONFIG.steps).fill(null));

        // ==========================================
        // 1. MOTOR DE AUDIO (SYNTH)
        // ==========================================
        const AudioEngine = {
            ctx: null,
            masterGain: null,
            analyser: null,

            init: function() {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4;
                
                // Analizador para el osciloscopio visual
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;

                // Efecto Delay/Reverb simple
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.25; // Sincronizado
                const feedback = this.ctx.createGain();
                feedback.gain.value = 0.3;
                const filter = this.ctx.createBiquadFilter();
                filter.frequency.value = 1500;

                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Ruta de efectos
                this.masterGain.connect(delay);
                delay.connect(filter);
                filter.connect(feedback);
                feedback.connect(delay);
                feedback.connect(this.ctx.destination);
                
                // Desbloqueo de audio para navegadores
                if(this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // Sintetizador polifónico simple según el track
            playNote: function(trackIndex, noteIndex) {
                if(!this.ctx) return;
                const now = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                // Definición de escalas y timbres por pista
                if(trackIndex === 0) { // BASS
                    osc.type = 'sawtooth';
                    osc.frequency.value = 55 + (noteIndex * 11); 
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.frequency.exponentialRampToValueAtTime(50, now + 0.4);
                    
                    gain.gain.setValueAtTime(0.8, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

                    osc.connect(filter); filter.connect(gain);
                } 
                else if (trackIndex === 1) { // ATMOS
                    osc.type = 'triangle';
                    osc.frequency.value = 220 + (noteIndex * 55); 
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
                    gain.gain.linearRampToValueAtTime(0, now + 1.5);
                    osc.connect(gain);
                }
                else if (trackIndex === 2) { // ACID LEAD
                    osc.type = 'square';
                    const freqs = [440, 523, 587, 659, 783, 880, 1046, 1174, 1318, 1567];
                    // Protección contra indices fuera de rango
                    const safeIndex = Math.abs(noteIndex) % freqs.length;
                    osc.frequency.value = freqs[safeIndex];
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.Q.value = 15;
                    filter.frequency.setValueAtTime(200, now);
                    filter.frequency.linearRampToValueAtTime(2500, now + 0.05);
                    filter.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                    
                    osc.connect(filter); filter.connect(gain);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                }
                else { // NOISE PERC
                    const bufferSize = this.ctx.sampleRate * 0.1;
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    
                    const noise = this.ctx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = noteIndex % 2 === 0 ? 'lowpass' : 'highpass';
                    filter.frequency.value = (noteIndex + 1) * 500;
                    
                    noise.connect(filter); filter.connect(gain);
                    noise.start();
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    
                    gain.connect(this.masterGain);
                    return; 
                }

                gain.connect(this.masterGain);
                osc.start();
                osc.stop(now + 2);
            }
        };

        // ==========================================
        // 2. ESCENA 3D (VISUALIZADOR MECÁNICO)
        // ==========================================
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.03);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 18);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- MATERIALES ---
        const matCylinder = new THREE.MeshStandardMaterial({ 
            color: 0x111111, roughness: 0.4, metalness: 0.8
        });
        const matGold = new THREE.MeshStandardMaterial({ color: 0xccaa00, roughness: 0.2, metalness: 1.0 });
        const matReader = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });

        // --- EL CILINDRO MAESTRO ---
        const drumGroup = new THREE.Group();
        const drumGeo = new THREE.CylinderGeometry(CONFIG.cylinderRadius, CONFIG.cylinderRadius, CONFIG.cylinderWidth, 64);
        drumGeo.rotateZ(Math.PI / 2); 
        const drumMesh = new THREE.Mesh(drumGeo, matCylinder);
        drumGroup.add(drumMesh);

        // Líneas divisorias
        for(let i=0; i<CONFIG.tracks; i++) {
            const ringGeo = new THREE.TorusGeometry(CONFIG.cylinderRadius + 0.05, 0.05, 16, 100);
            const ring = new THREE.Mesh(ringGeo, new THREE.MeshBasicMaterial({color: 0x333333}));
            ring.rotateY(Math.PI / 2);
            const zPos = ((i / (CONFIG.tracks - 1)) * 6) - 3; 
            ring.position.x = zPos;
            drumGroup.add(ring);
        }

        scene.add(drumGroup);

        // --- BRAZOS LECTORES ---
        const armsGroup = new THREE.Group();
        const armGeo = new THREE.BoxGeometry(0.5, 4, 0.5);
        const indicators = []; 

        for(let i=0; i<CONFIG.tracks; i++) {
            const arm = new THREE.Mesh(armGeo, matReader);
            const xPos = ((i / (CONFIG.tracks - 1)) * 6) - 3; 
            arm.position.set(xPos, CONFIG.cylinderRadius + 2, 0);
            
            const tip = new THREE.Mesh(new THREE.ConeGeometry(0.2, 1, 16), matGold);
            tip.position.y = -2.5;
            tip.rotation.x = Math.PI;
            arm.add(tip);

            const lightGeo = new THREE.SphereGeometry(0.3);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0x220000 });
            const light = new THREE.Mesh(lightGeo, lightMat);
            light.position.set(0, 1, 0.5);
            arm.add(light);
            indicators.push(lightMat);

            armsGroup.add(arm);
        }
        scene.add(armsGroup);

        // --- ILUMINACIÓN ---
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
        
        const spotLight = new THREE.SpotLight(0xffaa00, 50);
        spotLight.position.set(10, 15, 5);
        spotLight.castShadow = true;
        scene.add(spotLight);

        const blueLight = new THREE.PointLight(0x00ccff, 2, 20);
        blueLight.position.set(-5, -5, 5);
        scene.add(blueLight);

        // ==========================================
        // 3. LÓGICA DEL SECUENCIADOR (CORREGIDA)
        // ==========================================
        
        function addPinToDrum(trackIdx, stepIdx, noteVal) {
            const pinGeo = new THREE.BoxGeometry(0.4, 0.8, 0.4);
            const color = [0xff0055, 0x00ffcc, 0xffff00, 0xffffff][trackIdx];
            const pinMat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
            const pin = new THREE.Mesh(pinGeo, pinMat);

            const angle = (stepIdx / CONFIG.steps) * Math.PI * 2;
            const radius = CONFIG.cylinderRadius;
            const xPos = ((trackIdx / (CONFIG.tracks - 1)) * 6) - 3;
            
            pin.position.set(xPos, Math.sin(angle) * radius, Math.cos(angle) * radius);
            pin.lookAt(xPos, 0, 0); 
            
            drumGroup.add(pin);
            return pin;
        }

        let lastTime = 0;
        let accumulator = 0;
        const stepTime = (60 / CONFIG.bpm) / 4; 

        function sequencerLoop(time) {
            if(!isPlaying) return;

            const delta = time - lastTime;
            lastTime = time;

            // Rotación
            const fullRotationTime = CONFIG.steps * stepTime; 
            const rotationPerFrame = (delta / fullRotationTime) * Math.PI * 2;
            drumGroup.rotation.x += rotationPerFrame;

            // --- CORRECCIÓN CRÍTICA DE INDICES ---
            let rotation = drumGroup.rotation.x % (Math.PI * 2);
            if(rotation < 0) rotation += Math.PI * 2;
            
            // Calculamos el índice asegurando que nunca sea >= 32
            let virtualStepIndex = Math.floor( (rotation / (Math.PI*2)) * CONFIG.steps );
            
            // Blindaje contra desbordamiento
            if (virtualStepIndex >= CONFIG.steps) virtualStepIndex = 0;
            if (virtualStepIndex < 0) virtualStepIndex = CONFIG.steps - 1;

            if(virtualStepIndex !== currentStep) {
                currentStep = virtualStepIndex;
                triggerStep(currentStep);
            }
        }

        function triggerStep(stepIndex) {
            for(let t=0; t<CONFIG.tracks; t++) {
                
                // Validación extra de seguridad: ¿Existe el array del track?
                if (!sequenceData[t]) continue;

                const data = sequenceData[t][stepIndex];
                
                // Apagar luz (Reset)
                if (indicators[t]) indicators[t].color.setHex(0x220000);

                // --- CORRECCIÓN CRÍTICA: Validar existencia de datos ---
                // Solo procedemos si 'data' no es null Y no es undefined
                if(data && typeof data.noteVal !== 'undefined') {
                    
                    AudioEngine.playNote(t, data.noteVal);
                    
                    if (indicators[t]) indicators[t].color.setHex(0xff0000); 
                    
                    const arm = armsGroup.children[t];
                    if(arm) {
                        arm.position.y += 0.2;
                        setTimeout(() => { arm.position.y -= 0.2 }, 100);
                    }
                }
            }
        }

        // ==========================================
        // 4. INTERACCIÓN Y CANVAS
        // ==========================================
        
        const canvas = document.getElementById('scope');
        const canvasCtx = canvas.getContext('2d');
        
        function drawScope() {
            requestAnimationFrame(drawScope);
            if(!AudioEngine.analyser) return;

            const bufferLength = AudioEngine.analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            AudioEngine.analyser.getByteTimeDomainData(dataArray);

            canvasCtx.fillStyle = 'rgba(0, 20, 0, 0.2)';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#00ff00';
            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for(let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;
                if(i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                x += sliceWidth;
            }
            canvasCtx.stroke();
        }

        document.addEventListener('keydown', (e) => {
            if(!isPlaying) return;
            
            const key = e.key.toLowerCase();
            
            if(['1','2','3','4'].includes(key)) {
                activeTrack = parseInt(key) - 1;
                document.querySelectorAll('.track-indicator').forEach((el, i) => {
                    el.classList.toggle('active-track', i === activeTrack);
                });
                return;
            }
            
            const noteKeys = "qwertyuiop";
            const noteIndex = noteKeys.indexOf(key);
            
            if(noteIndex !== -1) {
                // Seguridad al escribir
                if (sequenceData[activeTrack] && currentStep >= 0 && currentStep < CONFIG.steps) {
                    if(sequenceData[activeTrack][currentStep] === null) {
                        sequenceData[activeTrack][currentStep] = { noteVal: noteIndex };
                        const mesh = addPinToDrum(activeTrack, currentStep, noteIndex);
                        sequenceData[activeTrack][currentStep].mesh = mesh;
                        AudioEngine.playNote(activeTrack, noteIndex);
                    } else {
                        const existing = sequenceData[activeTrack][currentStep];
                        if(existing && existing.mesh) drumGroup.remove(existing.mesh);
                        sequenceData[activeTrack][currentStep] = null;
                    }
                }
            }

            if(e.code === 'Space') {
                for(let i=0; i<CONFIG.steps; i++) {
                    if(sequenceData[activeTrack][i]) {
                        if(sequenceData[activeTrack][i].mesh) drumGroup.remove(sequenceData[activeTrack][i].mesh);
                        sequenceData[activeTrack][i] = null;
                    }
                }
            }
        });

        function animate(time) {
            requestAnimationFrame(animate);
            sequencerLoop(time / 1000);
            renderer.render(scene, camera);
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            AudioEngine.init();
            isPlaying = true;
            document.getElementById('overlay').style.opacity = 0;
            setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);
            lastTime = performance.now() / 1000;
            animate();
            drawScope();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
