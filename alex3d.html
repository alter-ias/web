<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>ALEX 3D</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&family=Montserrat:wght@500;800;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    
    <style>
        /* --- ESTÉTICA ALEX / VINTAGE MINIMALIST --- */
        :root {
            --bg-paper: #E8E4D9;     /* Fondo Crema */
            --ink-black: #101010;    /* Negro Tinta */
            --ultra-orange: #FF3300; /* Naranja Mecánica */
            --pure-white: #FFFFFF;
            --panel-bg: #111111;
            --ui-scale: 1.0;
        }

        body { 
            margin: 0; 
            overflow: hidden; 
            background: var(--ultra-orange); 
            font-family: 'Rajdhani', sans-serif; 
            color: var(--bg-paper); 
            height: 100vh; 
            width: 100vw;
            border: 15px solid var(--ultra-orange);
            box-sizing: border-box;
            position: relative;
        }

        /* --- PANTALLA DE INICIO (BOOT) --- */
        #boot { 
            position: fixed; 
            top: 0; left: 0; right: 0; bottom: 0;
            background: #E8E4D9; 
            color: #101010;
            z-index: 10000; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            border: 15px solid #FF3300; 
            box-sizing: border-box;
        }

        #main-wrapper {
            background: var(--bg-paper);
            width: 100%;
            height: 100%;
            display: flex; 
            flex-direction: column;
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        #viewport {
            flex-grow: 1; position: relative; overflow: hidden;
            display: flex; justify-content: center; align-items: center; gap: 20px;
            background: transparent; padding: 20px; box-sizing: border-box;
        }

        .monitor-container {
            width: 100%; height: 100%; max-width: 800px; position: relative;
            border: 3px solid var(--ink-black); 
            transition: 0.2s;
            display: flex; justify-content: center; align-items: center;
            background: #000; overflow: hidden; aspect-ratio: 16/9;
        }
        .monitor-container canvas { width: 100%; height: 100%; object-fit: contain; }
        
        .monitor-container.editing { 
            border: 5px solid var(--ultra-orange); 
            transform: scale(1.01);
            z-index: 10;
            box-shadow: 15px 15px 0px rgba(0,0,0,0.15); 
        }

        .monitor-label {
            position: absolute; top: 0; left: 0; 
            background: var(--ink-black); color: var(--bg-paper);
            padding: 5px 10px;
            font-family: 'Montserrat'; font-weight: 800; font-size: 20px; 
            letter-spacing: 1px; z-index: 2;
        }
        .monitor-container.editing .monitor-label { background: var(--ultra-orange); color: #000; }

        .deck-status-bar {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 5px 10px; box-sizing: border-box;
            background: var(--ink-black); font-size: 11px; font-family: monospace; z-index: 2;
        }
        .ds-active { color: var(--ultra-orange); font-weight: bold; }
        .ds-inactive { color: #666; }
        .fader-visual { color: #fff; font-weight: bold; letter-spacing: 3px;}

        /* UI CONTROL */
        #ui-wrapper { flex-shrink: 0; width: 100%; background: transparent; z-index: 10; display: flex; justify-content: center; align-items: flex-end; position: relative; }
        
        #dashboard {
            height: 380px; 
            background: var(--ink-black); 
            border-top: 5px solid var(--ultra-orange);
            transform-origin: top center; 
            width: 100%;
            display: grid; grid-template-columns: 180px 1fr 280px;
            padding: 25px 30px 10px 30px; box-sizing: border-box;
            gap: 15px; position: relative;
            transition: height 0.1s, transform 0.1s;
        }

        #scale-strip { position: absolute; top: 0; left: 0; width: 100%; height: 6px; background: #333; z-index: 50; }
        #scale-fill { height: 100%; width: 50%; background: var(--pure-white); pointer-events: none; }
        #scale-input { 
            position: absolute; top: -10px; left: 0; width: 100%; height: 30px; 
            opacity: 0; cursor: ew-resize; z-index: 100; margin: 0; 
        }

        .panel { display: flex; flex-direction: column; justify-content: space-between; height: 100%; }
        
        h3 { 
            font-family: 'Montserrat', sans-serif; font-size: 11px; letter-spacing: 2px; 
            color: var(--ultra-orange); margin: 0 0 8px 0; 
            border-bottom: 2px solid #333; padding-bottom: 3px; 
            text-transform: uppercase;
        }
        
        .shortcut-row { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 3px; color: #888; border-bottom: 1px dotted #333;}
        .key-badge { color: #fff; font-weight: 700; background: #333; padding: 0 3px; border-radius: 2px;}

        .mix-center { display: flex; flex-direction: column; height: 100%; justify-content: flex-start; gap: 8px; }
        .work-grid { display: flex; gap: 10px; margin-bottom: 0; }
        
        .work-btn {
            flex: 1; padding: 8px; background: #222; border: 1px solid #444; color: #888;
            font-family: 'Rajdhani'; font-weight: 700; font-size: 20px; cursor: pointer; text-align: center;
            transition: 0.1s; text-transform: uppercase; border-radius: 0;
        }
        .work-btn.selected { 
            background: var(--ultra-orange); color: #000; border: 1px solid var(--ultra-orange);
            box-shadow: none; 
        }

        #crossfader-track { width: 100%; height: 10px; background: #222; position: relative; border: 1px solid #444; margin-top: 0;}
        #crossfader-handle { 
            width: 40px; height: 18px; background: var(--pure-white); 
            position: absolute; top: -5px; left: 50%; transform: translateX(-50%); 
            border: 2px solid #000; border-radius: 10px; 
            transition: left 0.1s; 
        }

        #audio-scope {
            width: 100%; height: 80px; background: #000; border: 2px solid #333;
            border-radius: 100px;
            margin: 5px 0;
        }

        .eq-panel {
            display: flex; justify-content: space-between; gap: 5px; margin-top: 0;
            background: #000; padding: 8px; border: 1px solid #333;
            height: 100px;
        }
        .eq-band { display: flex; flex-direction: column; align-items: center; flex: 1; }
        .eq-slider-container {
            height: 100%; width: 12px; background: #222; border: 1px solid #444; position: relative; margin-bottom: 3px;
        }
        .eq-fill { position: absolute; bottom: 0; left: 0; width: 100%; pointer-events: none; }
        .eq-input { position: absolute; top: 0; left: -10px; width: 30px; height: 100%; -webkit-appearance: slider-vertical; opacity: 0; cursor: ns-resize; }
        .eq-label { font-size: 9px; color: #fff; text-align: center; font-weight: bold; line-height: 1; }

        #fill-eq-low { background: var(--pure-white); }
        #fill-eq-mid { background: #888; }
        #fill-eq-high { background: var(--ultra-orange); }

        .out-matrix { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 8px; }
        .out-btn { padding: 8px; background: #220000; border: 1px solid #440000; color: #ff5555; font-family: 'Montserrat'; font-weight: 700; font-size: 9px; cursor: pointer; }
        .out-btn.active-off { background: var(--pure-white); color: #000; border-color: #fff; }
        .out-btn.source { background: #001111; border-color: #003333; color: #448888; }
        .out-btn.source.active { background: var(--ultra-orange); color: #000; border-color: var(--ultra-orange); }

        .sliders-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: auto; width: 100%; box-sizing: border-box; }
        .param-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px; font-size: 10px; width: 100%; }
        .param-label { color: #888; width: 45px; flex-shrink: 0; font-weight: bold; }
        
        .param-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 2px; background: #444;
            outline: none; flex-grow: 1; min-width: 0; margin: 0;
        }
        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 12px; height: 12px; border-radius: 50%; 
            background: var(--pure-white); cursor: pointer; border: 2px solid #000; 
        }
        .param-slider:hover::-webkit-slider-thumb { background: var(--ultra-orange); }

        .util-btn { padding: 4px; background: transparent; border: 1px solid #444; color: #888; font-size: 9px; cursor: pointer; flex: 1; margin: 0 1px; font-weight: bold;}
        .util-btn:hover { border-color: var(--pure-white); color: var(--pure-white); background: #222; }
        .net-btn:hover { background: #fff; color: #000; }
        
        .mic-on { border-color: #FF3300; background: #FF3300; color: #000; }
        .mic-on:hover { background: #fff; color: #000; border-color: #fff; }
        
        .rec-active { background: #FF0000 !important; color: #fff !important; border-color: #FF0000 !important; animation: blink-rec 1s infinite; }
        @keyframes blink-rec { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

        .audio-console { margin-top: 5px; border: 1px solid #333; background: #000; padding: 5px; display: flex; flex-direction: column; gap: 5px; }
        .audio-decks-wrapper { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
        .deck-audio { border: 1px solid #222; padding: 4px; display: flex; flex-direction: column; gap: 3px; min-width: 0; }
        .deck-title { font-size: 9px; color: var(--ultra-orange); font-weight: bold; border-bottom: 1px solid #222; padding-bottom: 2px; margin-bottom: 1px; display:flex; justify-content: space-between; }
        .track-name { color: #fff; font-size: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 100%; display: block; }
        .audio-controls { display: flex; gap: 1px; }
        .audio-btn { flex: 1; background: #111; border: 1px solid #333; color: #666; font-size: 8px; cursor: pointer; padding: 3px 0; }
        .audio-btn:hover { background: #333; color: #fff; }
        .audio-btn.active { background: var(--pure-white); color: #000; border-color: #fff; }

        #midi-overlay, #net-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(232, 228, 217, 0.95); z-index: 200; justify-content: center; align-items: center; }
        #midi-panel, #net-panel { width: 90%; max-width: 1000px; height: 90%; background: #111; border: 4px solid var(--ultra-orange); padding: 20px; display: flex; flex-direction: column; color: #fff; box-shadow: 20px 20px 0 #000; }
        #net-panel { height: auto; width: 600px; }
        
        .midi-head { display: flex; justify-content: space-between; border-bottom: 2px solid #333; padding-bottom: 10px; margin-bottom: 10px; }
        #midi-list { flex-grow: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; align-content: start; }
        .midi-group-container { border: 1px solid #333; background: #000; padding: 5px; }
        .midi-group { color: var(--ultra-orange); border-bottom: 1px solid #333; margin-bottom: 5px; font-weight: bold; font-size: 12px; text-transform: uppercase; padding: 2px;}
        .midi-row { display: flex; justify-content: space-between; padding: 2px 5px; align-items: center; margin-bottom: 2px; }
        .midi-btn { background: #222; border: 1px solid #444; color: #fff; font-size: 9px; padding: 3px 6px; cursor: pointer; min-width: 50px; }
        .midi-btn.learning { background: var(--ultra-orange); color: #000; animation: blink 0.5s infinite; }
        @keyframes blink {0%{opacity:1}50%{opacity:0.5}}
        
        .net-stat { font-family: monospace; color: #888; margin-bottom: 10px; font-size: 12px; }
        .net-input { background: #000; border: 1px solid #444; color: #fff; padding: 10px; width: 70%; font-family: monospace; border-radius: 0;}
        .net-action { padding: 10px 20px; background: var(--ultra-orange); color: #000; border: 1px solid var(--ultra-orange); cursor: pointer; margin-left: 10px; font-weight: bold;}
        .net-action:hover { background: #fff; }
        .peer-list { margin-top: 10px; color: #666; font-size: 10px; }
    </style>
</head>
<body>

    <div id="boot">
        <div style="width: 100px; height: 100px; background: #000; border-radius: 50%; margin-bottom: 20px; position: relative;">
             <div style="position: absolute; top: 30%; left: 50%; transform: translateX(-50%); width: 40px; height: 40px; background: #FF3300; border-radius: 50%; border: 2px solid #fff;"></div>
             <div style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); width: 120px; height: 60px; background: #000; border-radius: 50px 50px 0 0;"></div>
             <div style="position: absolute; top: 40px; left: 50%; transform: translateX(-50%); width: 160px; height: 10px; background: #000;"></div>
        </div>
        <h1 style="font-size:90px; letter-spacing:-5px; color:#101010; margin: 0 0 10px 0; font-family: 'Montserrat'; font-weight: 900; line-height: 0.8;">ALEX</h1>
        <h2 style="font-size: 16px; font-family: 'Rajdhani'; letter-spacing: 5px; color: #555; text-transform: uppercase; font-weight: 700; margin-bottom: 40px;">System V.2.2 PURE-3D</h2>
        
        <button id="btn-start" style="padding:15px 50px; background:#101010; border:none; color:#E8E4D9; font-family:'Montserrat'; font-weight: 800; font-size:20px; letter-spacing: 1px; cursor:pointer; transition: 0.3s;">INICIAR SISTEMA</button>
        
        <div style="position: absolute; bottom: 30px; color: #888; font-family: 'Rajdhani'; font-size: 12px; letter-spacing: 1px;">
            <span style="color: #FF3300; font-weight: bold;">KOROVA</span> VISUAL SYNTH
        </div>
    </div>

    <canvas id="master-canvas" width="1280" height="720" style="display:none;"></canvas>

    <div id="main-wrapper">
        <div id="viewport">
            <div id="cont-1" class="monitor-container editing">
                <span class="monitor-label">MIX 1</span>
                <canvas id="canvas-1"></canvas>
                <div class="deck-status-bar">
                    <span id="st-1-a" class="ds-active">A: VACÍO</span>
                    <span class="fader-visual" id="fd-1">///</span>
                    <span id="st-1-b" class="ds-inactive">B: VACÍO</span>
                </div>
            </div>
            <div id="cont-2" class="monitor-container">
                <span class="monitor-label">MIX 2</span>
                <canvas id="canvas-2"></canvas>
                <div class="deck-status-bar">
                    <span id="st-2-a" class="ds-active">A: VACÍO</span>
                    <span class="fader-visual" id="fd-2">///</span>
                    <span id="st-2-b" class="ds-inactive">B: VACÍO</span>
                </div>
            </div>
        </div>

        <div id="ui-wrapper">
            <div id="dashboard">
                <div id="scale-strip"><div id="scale-fill"></div><input type="range" id="scale-input" min="0.5" max="1.0" step="0.01" value="1.0"></div>

                <div class="panel">
                    <h3>COMANDOS</h3>
                    <div class="shortcut-row"><span>Disparar / Cargar</span> <span class="key-badge">A-L</span></div>
                    <div class="shortcut-row"><span>FX 3D</span> <span class="key-badge">Q-P</span></div>
                    <div class="shortcut-row"><span>Webcam</span> <span class="key-badge">N</span></div>
                    <div class="shortcut-row"><span>Cambiar Mix</span> <span class="key-badge">{</span></div>
                    <div class="shortcut-row"><span>Salida / Win</span> <span class="key-badge">Ñ</span></div>
                    <div class="shortcut-row"><span>Reset</span> <span class="key-badge">M</span></div>
                </div>

                <div class="panel">
                    <div class="mix-center">
                        <div class="work-grid">
                            <button id="btn-mix-1" class="work-btn selected">MIX 1</button>
                            <button id="btn-mix-2" class="work-btn">MIX 2</button>
                        </div>
                        <div id="crossfader-track"><div id="crossfader-handle"></div></div>
                        
                        <canvas id="audio-scope"></canvas>
                        
                        <div class="eq-panel">
                            <div style="font-size:8px; color:#666; writing-mode: vertical-rl; transform: rotate(180deg); text-align:center;">RESPONSE</div>
                            <div class="eq-band">
                                <div class="eq-slider-container">
                                    <div class="eq-fill" id="fill-eq-low" style="height: 50%;"></div>
                                    <input type="range" class="eq-input" min="0" max="2" step="0.01" value="1.0" oninput="updateEq('low', this.value)">
                                </div>
                                <span class="eq-label" style="color:#fff">LO</span>
                            </div>
                            <div class="eq-band">
                                <div class="eq-slider-container">
                                    <div class="eq-fill" id="fill-eq-mid" style="height: 50%;"></div>
                                    <input type="range" class="eq-input" min="0" max="2" step="0.01" value="1.0" oninput="updateEq('mid', this.value)">
                                </div>
                                <span class="eq-label" style="color:#888">MD</span>
                            </div>
                            <div class="eq-band">
                                <div class="eq-slider-container">
                                    <div class="eq-fill" id="fill-eq-high" style="height: 50%;"></div>
                                    <input type="range" class="eq-input" min="0" max="2" step="0.01" value="1.0" oninput="updateEq('high', this.value)">
                                </div>
                                <span class="eq-label" style="color:var(--ultra-orange)">HI</span>
                            </div>
                        </div>
                        <div style="font-size:8px; color:#555; text-align:center; margin-top:3px; font-family:monospace; letter-spacing:1px;">
                            SCROLL: X-FADE <span style="color:#FF3300">|</span> CTRL: LO <span style="color:#FF3300">|</span> SHIFT: MID <span style="color:#FF3300">|</span> SPACE: HI
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="out-matrix">
                        <button id="out-off" class="out-btn active-off">BLACKOUT</button>
                        <button id="out-1" class="out-btn source">PROJ 1</button>
                        <button id="out-2" class="out-btn source">PROJ 2</button>
                    </div>
                    <div style="display:flex; margin-bottom:10px; gap:2px;">
                        <button class="util-btn" id="btn-rec" onclick="toggleRecording()">REC</button>
                        <button class="util-btn" id="btn-midi">MIDI</button>
                        <button class="util-btn" id="btn-proj">WIN</button>
                        <button class="util-btn mic-on" id="btn-mic" onclick="toggleMic()">MIC ON</button>
                        <button class="util-btn" onclick="exportPreset()">SAVE</button>
                        <button class="util-btn" onclick="document.getElementById('json-input').click()">LOAD</button>
                        <button class="util-btn net-btn" id="btn-net">PARTY</button>
                    </div>
                    
                    <div class="audio-console">
                        <div class="audio-decks-wrapper">
                            <div class="deck-audio">
                                <div class="deck-title"><span>TRACK 1</span> <span id="status-1" style="color:#666">STOP</span></div>
                                <div class="track-name" id="name-audio-1">NO TRACK</div>
                                <div class="audio-controls">
                                    <button class="audio-btn" onclick="document.getElementById('file-audio-1').click()">LD</button>
                                    <button class="audio-btn" id="play-1" onclick="tracks[0].play()">PL</button>
                                    <button class="audio-btn" onclick="tracks[0].pause()">PS</button>
                                    <button class="audio-btn" onclick="tracks[0].stop()">ST</button>
                                </div>
                                <input type="range" id="vol-1" class="param-slider" min="0" max="1" step="0.01" value="0.8" oninput="tracks[0].setBaseVolume(this.value)">
                            </div>
                            <div class="deck-audio">
                                <div class="deck-title"><span>TRACK 2</span> <span id="status-2" style="color:#666">STOP</span></div>
                                <div class="track-name" id="name-audio-2">NO TRACK</div>
                                <div class="audio-controls">
                                    <button class="audio-btn" onclick="document.getElementById('file-audio-2').click()">LD</button>
                                    <button class="audio-btn" id="play-2" onclick="tracks[1].play()">PL</button>
                                    <button class="audio-btn" onclick="tracks[1].pause()">PS</button>
                                    <button class="audio-btn" onclick="tracks[1].stop()">ST</button>
                                </div>
                                <input type="range" id="vol-2" class="param-slider" min="0" max="1" step="0.01" value="0.8" oninput="tracks[1].setBaseVolume(this.value)">
                            </div>
                        </div>
                        <div style="display:flex; align-items:center; gap:10px;">
                            <span style="font-size:9px; color:#888; font-weight:bold;">A-FADE</span>
                            <input type="range" id="audio-xfader" class="param-slider audio-xf-slider" min="0" max="1" step="0.01" value="0.5" oninput="updateAudioXF(this.value)">
                        </div>
                    </div>

                    <div class="sliders-grid" style="margin-top:15px;">
                        <div>
                            <div class="param-row"><span class="param-label">SPEED</span> <input type="range" id="sl-speed" min="0.1" max="5" step="0.1" value="1" class="param-slider" oninput="uiUpdate('speed', this.value)"></div>
                            <div class="param-row"><span class="param-label">GLITCH</span> <input type="range" id="sl-dist" min="0" max="5" step="0.1" value="0" class="param-slider" oninput="uiUpdate('glitch', this.value)"></div>
                            <div class="param-row"><span class="param-label">3D GEO</span> <input type="range" id="sl-geo" min="0" max="10" step="0.1" value="4" class="param-slider" oninput="uiUpdate('geo', this.value)"></div>
                        </div>
                        <div>
                            <div class="param-row"><span class="param-label">RGB</span> <input type="range" id="sl-rgb" min="0" max="1" step="0.01" value="0" class="param-slider" oninput="uiUpdate('color', this.value)"></div>
                            <div class="param-row"><span class="param-label" style="color:var(--ultra-orange)">SENS</span> <input type="range" id="sl-sens" min="1" max="50" step="0.1" value="10" class="param-slider" oninput="uiUpdate('sens', this.value)"></div>
                            </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="midi-overlay">
        <div id="midi-panel">
            <div class="midi-head"><h2 style="color:var(--ultra-orange); margin:0; font-size:18px;">MAPEO MIDI</h2><button class="util-btn" onclick="document.getElementById('midi-overlay').style.display='none'">CERRAR</button></div>
            <div id="midi-list"></div>
        </div>
    </div>
    <div id="net-overlay">
        <div id="net-panel">
            <div class="midi-head"><h2 style="color:#fff; margin:0; font-size:18px;">RED P2P (PARTY MODE)</h2><button class="util-btn" onclick="document.getElementById('net-overlay').style.display='none'">CERRAR</button></div>
            <div style="padding: 20px 0;">
                <div class="net-stat" id="my-id-display">CONECTANDO AL SERVIDOR...</div>
                <div style="border-top:1px solid #333; margin: 10px 0;"></div>
                <div style="display:flex;">
                    <input type="text" id="remote-id" class="net-input" placeholder="INGRESA ID REMOTO">
                    <button class="net-action" id="btn-connect-p2p">CONECTAR</button>
                </div>
                <div class="net-stat" id="connection-status" style="margin-top:20px; color:#fff;">ESTADO: OFFLINE</div>
                <div class="peer-list" id="peers-list">Usuarios conectados: 0</div>
            </div>
        </div>
    </div>
    
    <input type="file" id="file-input" accept="video/*" style="display:none">
    <input type="file" id="json-input" accept=".json" style="display:none">
    <input type="file" id="file-audio-1" accept="audio/*" style="display:none" onchange="tracks[0].loadFile(this.files[0])">
    <input type="file" id="file-audio-2" accept="audio/*" style="display:none" onchange="tracks[1].loadFile(this.files[0])">

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        window.notify = function(msg) {
            // Silenciado
        }
        
        // --- 1. MOTOR DE MEZCLA 3D PURO ---
        class MixerEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, preserveDrawingBuffer: true, alpha: true });
                this.renderer.setSize(1280, 720, false); 
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, 1280/720, 0.1, 1000); 
                this.camera.position.z = 9;

                this.deckA = this.createVideoTexture();
                this.deckB = this.createVideoTexture();
                this.webcam = this.createVideoTexture();

                this.state = {
                    nameA: "VACÍO", nameB: "VACÍO",
                    crossfade: 0.0, speed: 1.0, glitch: 0.0, geo: 4.0, rgb: 0.0,
                    mode: 1, // Ahora 'mode' se usa para el tipo de distorsión (Q-P -> 1-10)
                    tint: new THREE.Color(1,1,1), tintMix: 0.0, camMix: 0.0
                };

                this.uniforms = {
                    uTexA: { value: this.deckA.tex }, uTexB: { value: this.deckB.tex },
                    uCrossfade: { value: 0.0 }, uTexCam: { value: this.webcam.tex }, uMix: { value: 0.0 },
                    uTime: { value: 0 }, 
                    uBass: { value: 0 }, uMid: { value: 0 }, uHigh: { value: 0 },
                    uEqLow: { value: 1.0 }, uEqMid: { value: 1.0 }, uEqHigh: { value: 1.0 },
                    uDistType: { value: 1 }, // Control principal de efectos (Q-P)
                    uSpeed: { value: 1.0 }, uGeoStrength: { value: 4.0 },
                    uRGBShift: { value: 0.0 },
                    uTint: { value: new THREE.Color(1,1,1) }, uTintMix: { value: 0.0 }
                };

                // --- SHADERS UNIFICADOS (SOLO ESFERA 3D) ---
                const orbVert = `
                    uniform float uTime;
                    uniform float uBass; uniform float uMid; uniform float uHigh;
                    uniform float uEqLow; uniform float uEqMid; uniform float uEqHigh;
                    uniform float uSpeed; uniform float uGeoStrength;
                    uniform int uDistType; // 1-10 (Q-P)
                    varying vec2 vUv;
                    varying float vDisplacement;
                    varying vec3 vNormal;

                    // Simplex Noise
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) {
                        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i  = floor(v + dot(v, C.yyy) );
                        vec3 x0 = v - i + dot(i, C.xxx) ;
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min( g.xyz, l.zxy );
                        vec3 i2 = max( g.xyz, l.zxy );
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute( permute( permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                                + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                                + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                        float n_ = 0.142857142857;
                        vec3  ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_ );
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4( x.xy, y.xy );
                        vec4 b1 = vec4( x.zw, y.zw );
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
                    }

                    void main() {
                        vUv = uv;
                        vNormal = normal;
                        
                        float rBass = uBass * uEqLow;
                        float rHigh = uHigh * uEqHigh;
                        float rMid = uMid * uEqMid;
                        
                        float time = uTime * uSpeed;
                        float noise = 0.0;
                        float str = uGeoStrength * 0.5;

                        // --- MAPEO DE EFECTOS (Q-P) ---
                        if(uDistType == 1) { // Q: Pulso Suave
                            noise = sin(position.y * 2.0 + time) * 0.1 * rBass;
                        } else if(uDistType == 2) { // W: Twist
                            noise = snoise(position + time * 0.5) * 0.2 * rMid;
                        } else if(uDistType == 3) { // E: Picos Agudos
                            noise = abs(snoise(position * 3.0)) * 0.5 * rHigh;
                        } else if(uDistType == 4) { // R: Olas
                            noise = sin(length(position)*5.0 - time*2.0) * 0.1;
                        } else if(uDistType == 5) { // T: Glitch Geo
                            noise = (fract(sin(dot(uv, vec2(12.9,78.2)))*43758.5) > 0.5 ? 0.2 : 0.0) * rBass;
                        } else if(uDistType == 6) { // Y: Magma
                            noise = snoise(position * 2.0 + time);
                        } else if(uDistType == 7) { // U: High Freq
                            noise = snoise(position * 10.0 + time) * 0.5 * rHigh;
                        } else if(uDistType == 8) { // I: Blobs
                            noise = snoise(position * 0.5 + time * 0.2) * 1.5;
                        } else if(uDistType == 9) { // O: Chaos
                            noise = snoise(position * 5.0 + time * 2.0) * rBass;
                        } else if(uDistType == 10) { // P: Respiración
                            noise = abs(sin(time)) * 0.3 * rBass;
                        }

                        vDisplacement = noise;
                        vec3 newPosition = position + normal * (noise * str);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `;

                const orbFrag = `
                    uniform sampler2D uTexA; uniform sampler2D uTexB; uniform float uCrossfade;
                    uniform sampler2D uTexCam; uniform float uMix;
                    uniform vec3 uTint; uniform float uTintMix;
                    uniform float uRGBShift;
                    varying vec2 vUv;
                    varying float vDisplacement;
                    varying vec3 vNormal;

                    vec3 rgbSplit(sampler2D t, vec2 uv, float a) {
                        return vec3(texture2D(t, uv-vec2(a,0)).r, texture2D(t, uv).g, texture2D(t, uv+vec2(a,0)).b);
                    }

                    void main() {
                        // 1. MUESTREO DE VIDEO LIMPIO
                        // Usamos coordenadas UV estándar de la esfera para mapear el video
                        vec2 uv = vUv;
                        
                        // RGB Split simple en la textura
                        vec3 cA = rgbSplit(uTexA, uv, uRGBShift);
                        vec3 cB = rgbSplit(uTexB, uv, uRGBShift);
                        vec3 videoCol = mix(cA, cB, uCrossfade);
                        
                        // Webcam Mix
                        vec3 cam = rgbSplit(uTexCam, uv, uRGBShift);
                        videoCol = mix(videoCol, cam, uMix);
                        
                        // Tinte
                        videoCol = mix(videoCol, videoCol * uTint, uTintMix);

                        // 2. ILUMINACIÓN (SUTIL, NO BLANCA)
                        // Calculamos la luz basándonos en la normal para dar volumen 3D
                        float light = dot(vNormal, vec3(0.0, 1.0, 1.0)) * 0.5 + 0.5;
                        
                        // Fresnel suave para los bordes
                        float fresnel = pow(1.0 + dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0) * 0.3;

                        // Mezclamos el video con la iluminación, pero sin quemar
                        vec3 finalCol = videoCol * light;
                        
                        // Añadimos fresnel
                        finalCol += vec3(fresnel);

                        gl_FragColor = vec4(finalCol, 1.0);
                    }
                `;

                // Usamos SphereGeometry estable (128 segs)
                this.geometry = new THREE.SphereGeometry(2.5, 128, 128); 
                this.material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms, 
                    vertexShader: orbVert,
                    fragmentShader: orbFrag,
                    wireframe: false,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.scene.add(this.mesh);
            }

            createVideoTexture() {
                const v = document.createElement('video');
                v.muted = true; v.loop = true; v.playsInline = true;
                const c = document.createElement('canvas'); c.width=2; c.height=2; const x=c.getContext('2d'); x.fillStyle='#000'; x.fillRect(0,0,2,2);
                const t = new THREE.CanvasTexture(c);
                return { vid: v, tex: t };
            }

            loadClip(url) {
                const target = (this.state.crossfade < 0.5) ? 'B' : 'A';
                const deck = (target === 'A') ? this.deckA : this.deckB;
                deck.vid.src = url; deck.vid.play();
                deck.tex = new THREE.VideoTexture(deck.vid);
                if(target === 'A') { this.uniforms.uTexA.value = deck.tex; this.state.nameA = "CARGADO"; }
                else { this.uniforms.uTexB.value = deck.tex; this.state.nameB = "CARGADO"; }
            }

            render(t, audio, eq) {
                this.uniforms.uTime.value = t; 
                this.uniforms.uBass.value = audio.bass; this.uniforms.uMid.value = audio.mid; this.uniforms.uHigh.value = audio.high; 
                this.uniforms.uEqLow.value = eq.low; this.uniforms.uEqMid.value = eq.mid; this.uniforms.uEqHigh.value = eq.high;
                this.uniforms.uSpeed.value = this.state.speed; this.uniforms.uGeoStrength.value = this.state.geo;
                this.uniforms.uCrossfade.value = this.state.crossfade;
                this.uniforms.uDistType.value = this.state.mode; // 'mode' ahora controla el tipo de distorsión
                this.uniforms.uRGBShift.value = this.state.rgb; this.uniforms.uTint.value = this.state.tint;
                this.uniforms.uTintMix.value = this.state.tintMix; this.uniforms.uMix.value = this.state.camMix;
                
                // Rotación constante suave
                this.mesh.rotation.y += 0.005 * this.state.speed;
                this.mesh.rotation.z += 0.002;

                this.renderer.render(this.scene, this.camera);
            }
        }

        // --- 2. SISTEMA GLOBAL ---
        const mix1 = new MixerEngine('canvas-1');
        const mix2 = new MixerEngine('canvas-2');
        let activeMix = mix1; let activeId = 1;
        let outputMode = 'OFF';
        let projWin = null;
        let audio = { vol: 0, bass: 0, mid: 0, high: 0 }; 
        let eqSettings = { low: 1.0, mid: 1.0, high: 1.0 };
        let sensitivity = 10.0; 
        let isSpaceDown = false; 

        // --- MASTER CANVAS (PARA GRABACIÓN) ---
        const masterCanvas = document.getElementById('master-canvas');
        const masterCtx = masterCanvas.getContext('2d');

        // --- BANK SYSTEM POR MIX ---
        const videoBanks = { 1: {}, 2: {} }; 
        let pendingBankSlot = null;

        // --- 3. RED P2P ---
        let peer = null; let connections = []; let myPeerId = null;

        function broadcastData(type, payload, excludeConn = null) {
            connections.forEach(conn => {
                if (conn !== excludeConn && conn.open) conn.send({ type: type, payload: payload });
            });
        }
        function initNetwork() {
            peer = new Peer(); 
            peer.on('open', (id) => { myPeerId = id; document.getElementById('my-id-display').innerText = "ID: " + id; document.getElementById('connection-status').innerText = "ESPERANDO..."; });
            peer.on('connection', (c) => setupConnection(c));
            peer.on('error', (err) => { console.error(err); notify("ERROR RED"); });
        }
        function setupConnection(c) {
            connections.push(c); updatePeerCount(); notify("NUEVO PEER");
            c.on('data', (data) => handleRemoteData(data, c));
            c.on('close', () => { connections = connections.filter(conn => conn !== c); updatePeerCount(); });
            c.on('open', () => c.send({ type: 'preset_load', payload: { obj: getCurrentState() } }));
        }
        function updatePeerCount() {
            document.getElementById('connection-status').innerText = "ESTADO: ONLINE"; document.getElementById('connection-status').style.color = "#FF3300";
            document.getElementById('peers-list').innerText = `CONECTADOS: ${connections.length}`;
        }
        function getCurrentState() { 
            return { 
                mix1: { ...mix1.state, tint: {r:mix1.state.tint.r, g:mix1.state.tint.g, b:mix1.state.tint.b} },
                mix2: { ...mix2.state, tint: {r:mix2.state.tint.r, g:mix2.state.tint.g, b:mix2.state.tint.b} },
                global: { sensitivity: sensitivity, eq: eqSettings }, 
                timestamp: Date.now() 
            }; 
        }
        document.getElementById('btn-connect-p2p').onclick = () => { const remoteId = document.getElementById('remote-id').value; if(remoteId) { const c = peer.connect(remoteId); setupConnection(c); } };
        
        function handleRemoteData(data, sourceConn) {
            const p = data.payload;
            if(data.type === 'ui_param') updateParam(p.key, p.value, true); 
            else if (data.type === 'setActive') setActive(p.id, true);
            else if (data.type === 'crossfader') { activeMix.state.crossfade = p.val; updateFader(true); }
            else if (data.type === 'mode') { activeMix.state.mode = p.val; notify("REMOTO FX " + p.val); }
            else if (data.type === 'preset_load') applyPresetObj(p.obj, true);
            else if (data.type === 'audio_xf') { updateAudioXF(p.val, true); }
            else if (data.type === 'eq') { updateEq(p.band, p.val, true); }
        }

        // --- 4. UI LOGIC ---
        window.uiUpdate = function(key, value, isRemote = false) {
            const val = parseFloat(value);
            if(key === 'speed') activeMix.state.speed = val;
            if(key === 'glitch') activeMix.state.glitch = val;
            if(key === 'geo') activeMix.state.geo = val;
            if(key === 'sens') sensitivity = val; 
            if(key === 'color') {
                activeMix.state.rgb = val;
                if(val > 0) { activeMix.state.tint.setHSL(val, 1.0, 0.5); activeMix.state.tintMix = 1.0; }
                else { activeMix.state.tint.setRGB(1,1,1); activeMix.state.tintMix = 0.0; }
            }
            if(isRemote) {
                if(key==='speed') document.getElementById('sl-speed').value = val;
                if(key==='glitch') document.getElementById('sl-dist').value = val;
                if(key==='geo') document.getElementById('sl-geo').value = val;
                if(key==='sens') document.getElementById('sl-sens').value = val;
                if(key==='color') document.getElementById('sl-rgb').value = val;
            } else { broadcastData('ui_param', { key: key, value: val }); }
        };
        window.updateParam = window.uiUpdate; 

        window.updateEq = function(band, value, isRemote = false) {
            const val = parseFloat(value);
            eqSettings[band] = val;
            if(band === 'low') document.getElementById('fill-eq-low').style.height = (val/2)*100 + '%';
            if(band === 'mid') document.getElementById('fill-eq-mid').style.height = (val/2)*100 + '%';
            if(band === 'high') document.getElementById('fill-eq-high').style.height = (val/2)*100 + '%';
            if(isRemote) { const input = document.querySelector(`.eq-input[oninput*="'${band}'"]`); if(input) input.value = val; } 
            else { broadcastData('eq', { band: band, val: val }); }
        }

        function setActive(id, isRemote = false) {
            activeId = id; activeMix = (id===1) ? mix1 : mix2;
            document.getElementById('btn-mix-1').className = `work-btn ${id===1?'selected':''}`;
            document.getElementById('btn-mix-2').className = `work-btn ${id===2?'selected':''}`;
            document.getElementById('cont-1').className = `monitor-container ${id===1?'editing':''}`;
            document.getElementById('cont-2').className = `monitor-container ${id===2?'editing':''}`;
            document.getElementById('sl-speed').value = activeMix.state.speed;
            document.getElementById('sl-dist').value = activeMix.state.glitch;
            document.getElementById('sl-geo').value = activeMix.state.geo;
            document.getElementById('sl-rgb').value = activeMix.state.rgb; 
            document.getElementById('sl-sens').value = sensitivity;
            updateFader(true); 
            if(!isRemote) { notify(`EDIT: MIX ${id}`); broadcastData('setActive', { id: id }); }
        }
        function cycleWebcam(engine) {
            let m = engine.state.camMix; let next = (m === 0.0) ? 0.5 : (m === 0.5 ? 1.0 : 0.0); engine.state.camMix = next;
            if(next > 0 && !engine.webcam.vid.srcObject) {
                navigator.mediaDevices.getUserMedia({video:{width:1280, height:720}}).then(s => {
                    engine.webcam.vid.srcObject = s; engine.webcam.vid.onloadedmetadata = () => { engine.webcam.vid.play(); const newTex = new THREE.VideoTexture(engine.webcam.vid); engine.uniforms.uTexCam.value = newTex; engine.webcam.tex = newTex; };
                }).catch(e => { console.error(e); notify("ERROR CAMARA"); });
            }
            notify(`CAM: ${next === 0.0 ? "OFF" : (next === 0.5 ? "MIX" : "ONLY")}`);
        }
        function updateFader(isRemote = false) {
            document.getElementById('crossfader-handle').style.left = (activeMix.state.crossfade * 100) + '%';
            const pre = activeId;
            document.getElementById(`st-${pre}-a`).className = activeMix.state.crossfade < 0.5 ? 'ds-active' : 'ds-inactive';
            document.getElementById(`st-${pre}-b`).className = activeMix.state.crossfade > 0.5 ? 'ds-active' : 'ds-inactive';
            if(!isRemote) broadcastData('crossfader', { val: activeMix.state.crossfade });
        }
        
        window.exportPreset = function() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(getCurrentState()));
            const dlAnchorElem = document.createElement('a'); dlAnchorElem.setAttribute("href", dataStr); dlAnchorElem.setAttribute("download", "alex_patch_" + Date.now() + ".json"); dlAnchorElem.click(); notify("PRESET SAVED");
        }
        function applyPresetObj(obj, isRemote = false) {
             try {
                 Object.assign(mix1.state, obj.mix1); Object.assign(mix2.state, obj.mix2);
                 if(obj.mix1.tint) mix1.state.tint = new THREE.Color(obj.mix1.tint.r, obj.mix1.tint.g, obj.mix1.tint.b); else mix1.state.tint = new THREE.Color(1,1,1);
                 if(obj.mix2.tint) mix2.state.tint = new THREE.Color(obj.mix2.tint.r, obj.mix2.tint.g, obj.mix2.tint.b); else mix2.state.tint = new THREE.Color(1,1,1);
                 if(obj.global) {
                    if(obj.global.sensitivity) sensitivity = obj.global.sensitivity;
                    if(obj.global.eq) { eqSettings = obj.global.eq; updateEq('low', eqSettings.low, true); updateEq('mid', eqSettings.mid, true); updateEq('high', eqSettings.high, true); }
                 }
                 document.getElementById('sl-sens').value = sensitivity;
                 setActive(activeId, true); notify(isRemote ? "PRESET REMOTO" : "PRESET CARGADO"); 
                 if(!isRemote) broadcastData('preset_load', { obj: obj });
             } catch(e) { console.error("Error aplicando preset:", e); notify("ERROR PRESET"); }
        }
        function importPreset(file) { const reader = new FileReader(); reader.onload = (e) => { try { applyPresetObj(JSON.parse(e.target.result), false); } catch(e) { console.error(e); notify("ARCHIVO ROTO"); } }; reader.readAsText(file); }
        document.getElementById('json-input').onchange = (e) => importPreset(e.target.files[0]);

        // --- 5. AUDIO SYSTEM & VISUALIZER ---
        let audioCtx, analyser;
        let globalMicNode = null; let globalMicGain = null; let isMicOn = true;
        let audioCrossfadeVal = 0.5; let scopeCanvas, scopeCtx;
        let recDest; // Destino de audio para grabación

        class AudioTrack {
            constructor(id) {
                this.id = id; this.buffer = null; this.source = null; this.gainNode = null;
                this.startTime = 0; this.pausedAt = 0; this.isPlaying = false; this.fileName = "NO TRACK";
                this.baseVol = 0.8; this.fadeVol = 1.0;
            }
            loadFile(file) {
                if(!audioCtx) return;
                const reader = new FileReader(); notify(`CARGANDO ${this.id}...`);
                reader.onload = (e) => {
                    audioCtx.decodeAudioData(e.target.result, (buf) => {
                        this.buffer = buf; this.fileName = file.name; this.stop();
                        document.getElementById(`name-audio-${this.id}`).innerText = this.fileName.toUpperCase();
                        notify(`TRACK ${this.id} LISTO`);
                    }, () => notify("ERROR AUDIO"));
                }; reader.readAsArrayBuffer(file);
            }
            loadUrl(url) {
                if(!audioCtx) return;
                fetch(url).then(r=>r.arrayBuffer()).then(ab=>audioCtx.decodeAudioData(ab)).then(buf=>{
                    this.buffer=buf; this.fileName=url.split('/').pop().toUpperCase(); this.stop();
                    document.getElementById(`name-audio-${this.id}`).innerText=this.fileName; this.play(); notify(`AUTO: ${this.fileName}`);
                }).catch(e=>console.error("Audio Load Error",e));
            }
            play() {
                if(!this.buffer || this.isPlaying) return;
                this.source = audioCtx.createBufferSource(); this.source.buffer = this.buffer; this.source.loop = true;
                this.gainNode = audioCtx.createGain(); this.updateGain(); 
                this.source.connect(this.gainNode); this.gainNode.connect(analyser); this.gainNode.connect(audioCtx.destination); 
                this.source.start(0, this.pausedAt); this.startTime = audioCtx.currentTime - this.pausedAt;
                this.isPlaying = true; this.updateUI('PLAYING'); document.getElementById(`play-${this.id}`).classList.add('active');
            }
            pause() {
                if(!this.isPlaying) return;
                this.source.stop(); this.pausedAt = audioCtx.currentTime - this.startTime;
                this.isPlaying = false; this.updateUI('PAUSED'); document.getElementById(`play-${this.id}`).classList.remove('active');
            }
            stop() {
                if(this.source) { try{this.source.stop();}catch(e){} this.source = null; }
                this.pausedAt = 0; this.isPlaying = false; this.updateUI('STOP'); document.getElementById(`play-${this.id}`).classList.remove('active');
            }
            setBaseVolume(val) { this.baseVol = parseFloat(val); this.updateGain(); }
            setFadeVolume(val) { this.fadeVol = parseFloat(val); this.updateGain(); }
            updateGain() { if(this.gainNode) this.gainNode.gain.value = this.baseVol * this.fadeVol; }
            updateUI(status) {
                document.getElementById(`status-${this.id}`).innerText = status;
                document.getElementById(`status-${this.id}`).style.color = status==='PLAYING'?'#FF3300':'#666';
            }
        }
        const tracks = [new AudioTrack(1), new AudioTrack(2)]; window.tracks = tracks;

        window.updateAudioXF = function(val, isRemote = false) {
            audioCrossfadeVal = parseFloat(val);
            tracks[0].setFadeVolume(1.0 - audioCrossfadeVal); tracks[1].setFadeVolume(audioCrossfadeVal);
            if(isRemote) { document.getElementById('audio-xfader').value = audioCrossfadeVal; } else { broadcastData('audio_xf', { val: audioCrossfadeVal }); }
        }
        updateAudioXF(0.5);

        async function initAudio() {
            try {
                audioCtx = new (window.AudioContext||window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; 
                analyser.smoothingTimeConstant = 0.3; 
                
                // Configurar destino de grabación para capturar todo el audio
                recDest = audioCtx.createMediaStreamDestination();
                analyser.connect(recDest);

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
                    globalMicNode = audioCtx.createMediaStreamSource(stream);
                    globalMicGain = audioCtx.createGain(); globalMicGain.gain.value = 1.0; 
                    globalMicNode.connect(globalMicGain); globalMicGain.connect(analyser);
                } catch(err) { console.log("Sin Micrófono"); }

                scopeCanvas = document.getElementById('audio-scope'); scopeCtx = scopeCanvas.getContext('2d');
                const bufferLength = analyser.frequencyBinCount; const dataArray = new Uint8Array(bufferLength);
                let offset = 0;

                const loop = () => {
                    requestAnimationFrame(loop); analyser.getByteFrequencyData(dataArray); offset += 0.05;
                    let b = 0; let m = 0; let h = 0;
                    for(let i=0; i<10; i++) b += dataArray[i]; for(let i=10; i<80; i++) m += dataArray[i]; for(let i=80; i<200; i++) h += dataArray[i]; 
                    
                    let normBass = b/10/255;
                    let normMid = m/70/255;
                    let normHigh = h/120/255;

                    audio.bass = Math.pow(normBass, 3) * sensitivity * 3.0; 
                    audio.mid = Math.pow(normMid, 3) * sensitivity * 3.0; 
                    audio.high = Math.pow(normHigh, 3) * sensitivity * 3.0; 
                    
                    drawDotWaves(dataArray, bufferLength, offset);
                }; loop();
            } catch(e) { console.error(e); }
        }

        // --- VISUALIZADOR ESTILO ALEX ---
        function drawDotWaves(data, len, offset) {
            if(!scopeCtx) return;
            const w = scopeCanvas.width = scopeCanvas.clientWidth; const h = scopeCanvas.height = scopeCanvas.clientHeight;
            scopeCtx.fillStyle = '#000'; scopeCtx.fillRect(0,0,w,h);
            const centerY = h / 2; const sliceWidth = w / 100; 
            for(let layer = 0; layer < 3; layer++) {
                let color = ''; 
                if(layer === 0) color = '#FFFFFF'; // Blanco
                if(layer === 1) color = '#888888'; // Gris
                if(layer === 2) color = '#FF3300'; // Naranja
                
                for(let i = 0; i < 100; i++) {
                    const index = Math.floor((i / 100) * (len * 0.7)); const val = data[index] / 255.0;
                    const x = i * sliceWidth + (sliceWidth/2); const phase = offset + (layer * 2); 
                    const sineWave = Math.sin((i * 0.1) + phase) * 20; const amplitude = (val * 40) * (1 - (layer * 0.2)); 
                    const y = centerY + sineWave + (layer === 1 ? -amplitude : amplitude); const radius = (val * 3) + 1; 
                    scopeCtx.beginPath(); scopeCtx.arc(x, y, radius, 0, Math.PI * 2);
                    scopeCtx.fillStyle = color; scopeCtx.globalAlpha = 1.0; scopeCtx.fill();
                }
            }
            scopeCtx.globalAlpha = 1.0;
        }

        window.toggleMic = function() {
            if(!globalMicGain) return; isMicOn = !isMicOn;
            globalMicGain.gain.setTargetAtTime(isMicOn ? 1.0 : 0.0, audioCtx.currentTime, 0.1);
            const btn = document.getElementById('btn-mic');
            if(isMicOn) { btn.innerText = "MIC ON"; btn.classList.add('mic-on'); } else { btn.innerText = "MIC OFF"; btn.classList.remove('mic-on'); }
            notify(isMicOn ? "MIC ON" : "MIC OFF");
        }

        // --- SISTEMA DE GRABACIÓN MASTER ---
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        window.toggleRecording = function() {
            const btn = document.getElementById('btn-rec');
            if (isRecording) {
                mediaRecorder.stop();
                btn.classList.remove('rec-active');
                isRecording = false;
                notify("GRABACIÓN FINALIZADA");
            } else {
                if(!recDest) { notify("AUDIO NO INICIADO"); return; }
                
                // Grabamos el Master Canvas, no el mix individual
                const canvasStream = masterCanvas.captureStream(30); 
                const audioStream = recDest.stream;
                const combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...audioStream.getAudioTracks()]);
                
                // Intentar forzar MP4 (H.264) para compatibilidad, si no, WebM
                let options = { mimeType: 'video/webm' };
                if (MediaRecorder.isTypeSupported('video/mp4')) {
                    options = { mimeType: 'video/mp4' };
                } else if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) {
                    options = { mimeType: 'video/webm;codecs=h264' };
                }

                try {
                    mediaRecorder = new MediaRecorder(combinedStream, options);
                } catch (e) {
                    console.error("Error codec", e);
                    mediaRecorder = new MediaRecorder(combinedStream);
                }

                recordedChunks = [];
                mediaRecorder.ondataavailable = function(e) {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.onstop = function() {
                    const blob = new Blob(recordedChunks, { type: options.mimeType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    // Extensión correcta
                    const ext = options.mimeType.includes('mp4') ? 'mp4' : 'webm';
                    a.download = `alex_session_${Date.now()}.${ext}`;
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100);
                };

                mediaRecorder.start();
                btn.classList.add('rec-active');
                isRecording = true;
                notify("GRABANDO MASTER");
            }
        };

        // --- EVENTS, KEY HANDLING & GLOBAL CONTROL ---
        function animate() { 
            requestAnimationFrame(animate); 
            const t = performance.now()*0.001; 
            
            // Renderizar los dos motores
            mix1.render(t, audio, eqSettings); 
            mix2.render(t, audio, eqSettings); 
            
            // --- ACTUALIZAR MASTER CANVAS ---
            // Esto asegura que se grabe/proyecte la salida correcta
            if (outputMode === '1') {
                masterCtx.drawImage(mix1.canvas, 0, 0);
            } else if (outputMode === '2') {
                masterCtx.drawImage(mix2.canvas, 0, 0);
            } else {
                // Si el output está apagado, mandamos al Master lo que se está editando
                // para poder grabar ensayos sin proyectar
                masterCtx.drawImage(activeMix.canvas, 0, 0);
            }
        }

        document.getElementById('btn-start').onclick = async () => {
            await initAudio(); initNetwork();
            document.getElementById('boot').style.display='none';
            mix1.loadClip('assets/videos/alexvision.webm'); mix1.state.crossfade=1.0; mix1.loadClip('assets/videos/alex3.webm'); mix1.state.crossfade=0.0; 
            mix2.loadClip('assets/videos/alexvision.webm'); mix2.state.crossfade=1.0; mix2.loadClip('assets/videos/alex5.webm'); mix2.state.crossfade=0.0;
            tracks[0].loadUrl('assets/videos/alex9.mp3');
            animate();
        };

        document.getElementById('scale-input').oninput = (e) => { 
            const s = e.target.value;
            document.documentElement.style.setProperty('--ui-scale', s); 
            const baseHeight = 380; 
            const scaledHeight = baseHeight * s;
            document.getElementById('dashboard').style.height = scaledHeight + "px";
            document.getElementById('scale-fill').style.width = ((s - 0.5) / 0.5) * 100 + '%'; 
        };
        
        // --- GLOBAL INPUT HANDLER ---
        function handleWheel(e) {
            const delta = e.deltaY * -0.001; 

            if (e.ctrlKey) {
                // GRAVES (Low)
                e.preventDefault();
                const newVal = Math.max(0, Math.min(2, eqSettings.low + delta));
                const input = document.querySelector(`.eq-input[oninput*="'low'"]`);
                if(input) input.value = newVal;
                window.updateEq('low', newVal);
            } else if (e.shiftKey) {
                // MEDIOS (Mid)
                e.preventDefault();
                const newVal = Math.max(0, Math.min(2, eqSettings.mid + delta));
                const input = document.querySelector(`.eq-input[oninput*="'mid'"]`);
                if(input) input.value = newVal;
                window.updateEq('mid', newVal);
            } else if (isSpaceDown) { // SPACE TRACKING
                // ALTOS (High)
                e.preventDefault();
                const newVal = Math.max(0, Math.min(2, eqSettings.high + delta));
                const input = document.querySelector(`.eq-input[oninput*="'high'"]`);
                if(input) input.value = newVal;
                window.updateEq('high', newVal);
            } else if (!e.altKey) { // Avoid alt default
                // CROSSFADER
                activeMix.state.crossfade = Math.max(0, Math.min(1, activeMix.state.crossfade + e.deltaY * 0.001)); 
                updateFader(false);
            }
        }

        function handleKeyInput(e) {
            const k = e.key.toLowerCase();
            const bankKeys = ['a','s','d','f','g','h','j','k','l'];
            const deformKeys = {'q':1, 'w':2, 'e':3, 'r':4, 't':5, 'y':6, 'u':7, 'i':8, 'o':9, 'p':10};
            
            if(e.code === 'Space') {
                if(e.target.tagName !== 'INPUT') e.preventDefault(); 
                isSpaceDown = true;
            }

            // --- TOGGLE MIX (Tecla junto a Ñ) ---
            if(e.key === '{' || e.key === '´' || e.key === '+' || e.code === 'Quote' || e.code === 'BracketRight') {
                const nextId = activeId === 1 ? 2 : 1;
                setActive(nextId);
            }

            if(bankKeys.includes(k)) {
                // LÓGICA SIMPLIFICADA DE CARGA (Sin Shift)
                if(!videoBanks[activeId][k]) {
                    // Si está vacío, cargar
                    pendingBankSlot = k;
                    document.getElementById('file-input').click();
                } else {
                    // Si tiene clip, disparar
                    activeMix.loadClip(videoBanks[activeId][k]);
                    notify(`BANCO ${k.toUpperCase()} (MIX ${activeId})`);
                }
                return;
            }

            // AHORA TODAS LAS TECLAS DE EFECTO (Q-P) SON MODOS 3D
            if(deformKeys[k]) {
                const mode = deformKeys[k];
                activeMix.state.mode = mode; // Actualiza el modo de deformación
                notify(`FX 3D: ${mode}`);
                broadcastData('mode', {val: mode});
            }

            if(k==='m') { activeMix.state.mode=1; activeMix.state.rgb=0; activeMix.state.tintMix=0; document.getElementById('sl-rgb').value=0; window.uiUpdate('color', 0); notify("RESET"); }
            if(k==='n') { cycleWebcam(activeMix); }
            if(k==='ñ') { if(outputMode === 'OFF') setOutput('1'); else if(outputMode === '1') setOutput('2'); else setOutput('OFF'); }
        }
        
        window.addEventListener('keyup', (e) => {
            if(e.code === 'Space') isSpaceDown = false;
        });

        window.addEventListener('wheel', handleWheel, { passive: false });
        window.addEventListener('keydown', handleKeyInput);

        document.getElementById('file-input').onchange = (e) => { 
            if(!e.target.files[0]) return; 
            const url = URL.createObjectURL(e.target.files[0]);
            if(pendingBankSlot) {
                videoBanks[activeId][pendingBankSlot] = url;
                notify(`BANCO ${pendingBankSlot.toUpperCase()} MIX ${activeId} GUARDADO`);
                pendingBankSlot = null;
            }
            activeMix.loadClip(url);
            e.target.value = ''; 
        };

        document.getElementById('btn-mix-1').onclick = () => setActive(1);
        document.getElementById('btn-mix-2').onclick = () => setActive(2);
        document.getElementById('btn-net').onclick = () => document.getElementById('net-overlay').style.display = 'flex';
        document.getElementById('btn-midi').onclick = () => { renderMidi(); document.getElementById('midi-overlay').style.display='flex'; };
        document.getElementById('out-off').onclick = () => setOutput('OFF');
        document.getElementById('out-1').onclick = () => setOutput('1');
        document.getElementById('out-2').onclick = () => setOutput('2');
        
        function setOutput(mode) {
             outputMode = mode;
             document.getElementById('out-off').className = `out-btn ${mode==='OFF'?'active-off':''}`;
             document.getElementById('out-1').className = `out-btn source ${mode==='1'?'active':''}`;
             document.getElementById('out-2').className = `out-btn source ${mode==='2'?'active':''}`;
             
             if(projWin && !projWin.closed) { 
                 const v = projWin.document.getElementById('v'); 
                 if(mode === 'OFF') v.style.opacity = 0; 
                 // AHORA PROYECTAMOS EL MASTER CANVAS, NO EL MIX DIRECTO
                 else { v.style.opacity = 1; v.srcObject = masterCanvas.captureStream(60); } 
             }
            notify(`SALIDA: ${mode}`);
        }
        
        document.getElementById('btn-proj').onclick = () => { 
            projWin = window.open("", "PROJ", "width=800,height=600"); 
            if(projWin){ 
                projWin.document.write(`<body style="margin:0;background:#000;overflow:hidden"><video id="v" autoplay style="width:100vw;height:100vh;object-fit:cover;opacity:0"></video></body>`); 
                projWin.focus(); 
                projWin.addEventListener('keydown', handleKeyInput);
                projWin.addEventListener('wheel', handleWheel, { passive: false });
                
                if(outputMode !== 'OFF') setOutput(outputMode); 
            } 
        };

        // --- MAPEO MIDI ---
        const midiMapDef = {
            'work_a':{l:'Mix 1', f:()=>setActive(1)}, 'work_b':{l:'Mix 2', f:()=>setActive(2)},
            'crossfader':{l:'X-Fader', f:(v)=>{activeMix.state.crossfade=v; updateFader();}},
            'reset':{l:'Reset FX', f:()=>{activeMix.state.mode=1; activeMix.state.rgb=0; activeMix.state.tintMix=0; document.getElementById('sl-rgb').value=0;}},
            'load_clip':{l:'Load Vid', f:()=>document.getElementById('file-input').click()},
            'out_cycle':{l:'Out (Ñ)', f:(v)=>{ if(v>0.5){ if(outputMode==='OFF') setOutput('1'); else if(outputMode==='1') setOutput('2'); else setOutput('OFF'); }}},
            'speed':{l:'Knob Speed', f:(v)=>window.uiUpdate('speed', v*5)}, 'glitch':{l:'Knob Glitch', f:(v)=>window.uiUpdate('glitch', v*5)}, 
            'geo':{l:'Knob Geo', f:(v)=>window.uiUpdate('geo', v*10)}, 'color':{l:'Knob Color', f:(v)=>window.uiUpdate('color', v)}, 
            'sens':{l:'Knob Sens', f:(v)=>window.uiUpdate('sens', v*50)}, 
            'eq_low':{l:'EQ Low', f:(v)=>window.updateEq('low', v*2)}, 'eq_mid':{l:'EQ Mid', f:(v)=>window.updateEq('mid', v*2)}, 'eq_high':{l:'EQ Hi', f:(v)=>window.updateEq('high', v*2)},
            'mic_toggle':{l:'Mic On/Off', f:(v)=>{ if(v>0.5) window.toggleMic(); }},
            'play_1':{l:'D1 Play', f:(v)=>{ if(v>0.5) tracks[0].play(); }}, 'stop_1':{l:'D1 Stop', f:(v)=>{ if(v>0.5) tracks[0].stop(); }}, 'vol_1':{l:'D1 Vol', f:(v)=>{ tracks[0].setBaseVolume(v); document.getElementById('vol-1').value=v; }},
            'play_2':{l:'D2 Play', f:(v)=>{ if(v>0.5) tracks[1].play(); }}, 'stop_2':{l:'D2 Stop', f:(v)=>{ if(v>0.5) tracks[1].stop(); }}, 'vol_2':{l:'D2 Vol', f:(v)=>{ tracks[1].setBaseVolume(v); document.getElementById('vol-2').value=v; }},
            'audio_xf':{l:'Audio XF', f:(v)=>updateAudioXF(v)}
        };
        // Simplificado: Solo mapeamos FX 1-10 (que ahora son Q-P en lógica)
        for(let i=1;i<=10;i++) midiMapDef[`fx_${i}`] = {l:`FX 3D ${i}`, f:()=>activeMix.state.mode=i};

        let midiBinding = null; const midiConfig = {}; 
        
        function renderMidi() { 
            const list = document.getElementById('midi-list'); list.innerHTML=''; 
            const groups = { 'AUDIO': ['mic_toggle','audio_xf','play_1','stop_1','vol_1','play_2','stop_2','vol_2'], 'EQ': ['eq_low','eq_mid','eq_high'], 'GENERAL': ['work_a','work_b','crossfader','reset','load_clip','out_cycle'], 'KNOBS': ['speed','glitch','geo','color','sens'], 'FX 3D': Array.from({length:10},(_,i)=>`fx_${i+1}`) };
            for(const [grpName, keys] of Object.entries(groups)) { 
                const cont = document.createElement('div'); cont.className='midi-group-container';
                const h=document.createElement('div'); h.className='midi-group'; h.innerText=grpName; cont.appendChild(h);
                keys.forEach(k => { 
                    if(midiMapDef[k]) {
                        const row=document.createElement('div'); row.className='midi-row'; 
                        row.innerHTML=`<span style="font-size:9px;color:#888;">${midiMapDef[k].l}</span><button class="midi-btn ${midiBinding===k?'learning':''}">${midiConfig[k]?(midiConfig[k].t+':'+midiConfig[k].v):'MAP'}</button>`; 
                        row.querySelector('button').onclick=()=>{midiBinding=k; renderMidi();}; cont.appendChild(row); 
                    }
                }); list.appendChild(cont);
            } 
        }

        // --- INICIALIZACIÓN MIDI SEGURA ---
        if(navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(m => {
                for(let i of m.inputs.values()) {
                    i.onmidimessage = (msg) => {
                        const [c, n, v] = msg.data;
                        const type = (c>=176 && c<=191)?'cc':(c>=144 && c<=159)?'note':null;
                        if(!type || (type==='note' && v===0)) return;
                        
                        if(midiBinding) {
                            midiConfig[midiBinding] = { t:type, v:n };
                            notify("MAPPED");
                            midiBinding = null;
                            renderMidi();
                            return;
                        }
                        
                        for(const [key, map] of Object.entries(midiConfig)) {
                            if(map.t === type && map.v === n) {
                                midiMapDef[key].f(v/127.0);
                            }
                        }
                    };
                }
            }).catch(err => {
                console.log("MIDI no disponible o permiso denegado:", err);
            });
        }
    </script>
</body>
</html>
