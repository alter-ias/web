<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>IRIS | Modular Infinite Control</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Inter', sans-serif;
        }

        #overlay {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        .header {
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 4px;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            display: flex;
            justify-content: space-between;
        }

        .footer {
            color: #666;
            font-size: 12px;
            letter-spacing: 2px;
            text-align: center;
        }

        .controls {
            pointer-events: auto;
            color: #888;
            text-align: right;
            font-size: 11px;
            line-height: 1.8;
        }

        .key {
            border: 1px solid #444;
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
            background: #222;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <div class="header">
            <span>IRIS // Modular System</span>
            <span>Mk.II Concept</span>
        </div>
        <div class="controls">
            SCROLL : ZOOM<br>
            <span class="key">CTRL</span> + SCROLL : EXPLODE MODULES<br>
            DRAG : ORBIT VIEW
        </div>
        <div class="footer">ALTERLAB GENERATIVE HARDWARE</div>
    </div>

    <!-- Import Map for convenience -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.skypack.dev/three@0.136.0",
                "three/addons/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIG ---
        const CONFIG = {
            gridSize: 3, // 3x3 grid
            moduleSize: 2.0,
            gap: 0.1,
            colors: {
                bg: 0x050505,
                chassis: 0x1a1a1a,
                accent: 0x00E5FF,
                highlight: 0xffffff,
                ledOff: 0x222222
            }
        };

        // --- STATE ---
        const state = {
            explode: 0.0,
            targetExplode: 0.0
        };

        // --- SCENE SETUP ---
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.colors.bg);
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.02);

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(8, 12, 12);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 30;

        // --- LIGHTING ---
        RectAreaLightUniformsLib.init();

        const ambient = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambient);

        const spot1 = new THREE.SpotLight(0xffffff, 8);
        spot1.position.set(10, 20, 10);
        spot1.angle = Math.PI / 6;
        spot1.penumbra = 1;
        spot1.castShadow = true;
        scene.add(spot1);

        const spot2 = new THREE.SpotLight(0x00acc1, 5); // Cyan rim light
        spot2.position.set(-10, 5, -10);
        spot2.lookAt(0, 0, 0);
        scene.add(spot2);

        const rectLight = new THREE.RectAreaLight(0xffffff, 2, 20, 20);
        rectLight.position.set(0, 10, 0);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Resolution, strength, radius, threshold
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85);
        composer.addPass(bloomPass);

        // --- MATERIALS ---
        const materials = {
            chassis: new THREE.MeshStandardMaterial({
                color: CONFIG.colors.chassis,
                roughness: 0.3,
                metalness: 0.8
            }),
            panel: new THREE.MeshPhysicalMaterial({
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.1,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            }),
            connector: new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.9
            }),
            led: new THREE.MeshStandardMaterial({
                color: CONFIG.colors.accent,
                emissive: CONFIG.colors.accent,
                emissiveIntensity: 3.0,
                toneMapped: false
            }),
            glowText: new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.8
            })
        };

        // --- MODULE SYSTEM ---
        const modules = [];

        class Module {
            constructor(x, z, type) {
                this.homePos = new THREE.Vector3(x * (CONFIG.moduleSize + CONFIG.gap), 0, z * (CONFIG.moduleSize + CONFIG.gap));
                this.group = new THREE.Group();
                this.group.position.copy(this.homePos);
                this.parts = []; // Array of { mesh, homeLocalPos, explodeSpeed }

                this.createChassis();
                this.createConnectors();

                if (type === 'fader') this.createFader();
                else if (type === 'knob') this.createKnobs();
                else if (type === 'pad') this.createPads();
                else if (type === 'touch') this.createTouch();
                else if (type === 'roller') this.createRoller();
                else this.createBlank(); // Default

                scene.add(this.group);
                modules.push(this);
            }

            createChassis() {
                const geo = new RoundedBoxGeometry(CONFIG.moduleSize, 0.5, CONFIG.moduleSize, 4, 0.05);
                const mesh = new THREE.Mesh(geo, materials.chassis);
                mesh.position.y = 0.25;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.group.add(mesh);
                // Top Panel
                const panelGeo = new RoundedBoxGeometry(CONFIG.moduleSize - 0.2, 0.05, CONFIG.moduleSize - 0.2, 2, 0.02);
                const panel = new THREE.Mesh(panelGeo, materials.panel);
                panel.position.y = 0.51;
                panel.receiveShadow = true;
                this.group.add(panel);
            }

            createConnectors() {
                // Visualize magnetic connectors on sides
                const geo = new THREE.CylinderGeometry(0.05, 0.05, 0.55, 8);
                geo.rotateZ(Math.PI / 2);

                const sides = [
                    { x: CONFIG.moduleSize / 2, z: 0, rot: 0 },
                    { x: -CONFIG.moduleSize / 2, z: 0, rot: 0 },
                    { x: 0, z: CONFIG.moduleSize / 2, rot: Math.PI / 2 },
                    { x: 0, z: -CONFIG.moduleSize / 2, rot: Math.PI / 2 }
                ];

                sides.forEach(s => {
                    const m = new THREE.Mesh(geo, materials.connector);
                    m.position.set(s.x, 0.25, s.z);
                    m.rotation.y = s.rot;
                    this.group.add(m);
                });
            }

            addToParts(mesh, speed = 1.0) {
                this.group.add(mesh);
                this.parts.push({
                    mesh: mesh,
                    home: mesh.position.clone(),
                    speed: speed
                });
            }

            createFader() {
                const trackGeo = new THREE.BoxGeometry(0.1, 0.02, 1.4);
                const track = new THREE.Mesh(trackGeo, new THREE.MeshStandardMaterial({ color: 0x000 }));
                track.position.set(0, 0.54, 0);
                this.group.add(track);

                const capGeo = new RoundedBoxGeometry(0.3, 0.4, 0.15, 4, 0.02);
                const cap = new THREE.Mesh(capGeo, materials.chassis);
                cap.castShadow = true;
                cap.position.set(0, 0.7, 0);

                // Glow line on cap
                const lineGeo = new THREE.BoxGeometry(0.32, 0.05, 0.02);
                const line = new THREE.Mesh(lineGeo, materials.led);
                line.position.set(0, 0.8, 0);
                cap.add(line);

                this.addToParts(cap, 2.0);
            }

            createKnobs() {
                // 4 Knobs
                for (let i = 0; i < 4; i++) {
                    const x = (i % 2 === 0) ? -0.5 : 0.5;
                    const z = (i < 2) ? -0.5 : 0.5;

                    const kGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.3, 32);
                    const kMesh = new THREE.Mesh(kGeo, materials.chassis);
                    kMesh.castShadow = true;
                    kMesh.position.set(x, 0.65, z);

                    // Ring Indicator
                    const ringGeo = new THREE.TorusGeometry(0.3, 0.02, 4, 32);
                    ringGeo.rotateX(Math.PI / 2);
                    const ring = new THREE.Mesh(ringGeo, materials.led);
                    ring.position.set(x, 0.54, z); // Base
                    this.group.add(ring);

                    this.addToParts(kMesh, 1.5 + Math.random());
                }
            }

            createPads() {
                // 4x4 Grid
                const padGeo = new RoundedBoxGeometry(0.3, 0.1, 0.3, 2, 0.02);
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const x = -0.6 + c * 0.4;
                        const z = -0.6 + r * 0.4;

                        // Randomly light up some pads
                        const active = Math.random() > 0.8;
                        const mat = active ? materials.led : materials.connector;

                        const pad = new THREE.Mesh(padGeo, mat);
                        pad.position.set(x, 0.55, z);
                        pad.castShadow = true;

                        this.addToParts(pad, 1.0 + (r + c) * 0.1);
                    }
                }
            }

            createTouch() {
                const surfaceGeo = new THREE.PlaneGeometry(1.6, 1.6);
                surfaceGeo.rotateX(-Math.PI / 2);
                const surface = new THREE.Mesh(surfaceGeo, new THREE.MeshPhysicalMaterial({
                    color: 0x000000, roughness: 0.1, metalness: 0.5, transparent: true, opacity: 0.9
                }));
                surface.position.set(0, 0.54, 0);
                this.group.add(surface);

                const cursorGeo = new THREE.RingGeometry(0.1, 0.12, 32);
                cursorGeo.rotateX(-Math.PI / 2);
                const cursor = new THREE.Mesh(cursorGeo, materials.led);
                cursor.position.set(0.2, 0.55, -0.3);
                this.addToParts(cursor, 0.5);
            }

            createRoller() {
                // Cylindrical Roller
                const rollerGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 64);
                rollerGeo.rotateZ(Math.PI / 2);
                const roller = new THREE.Mesh(rollerGeo, materials.chassis);
                roller.position.set(0, 0.5, 0);
                roller.castShadow = true;

                // Glowing stripe on roller
                const stripeGeo = new THREE.TorusGeometry(0.81, 0.02, 4, 64);
                const stripe = new THREE.Mesh(stripeGeo, materials.led);
                stripe.rotation.y = Math.PI / 2;
                roller.add(stripe);

                // Cutout in chassis for it?
                // Visual hack: just place it on top for now, maybe add a cradle
                const cradleGeo = new THREE.BoxGeometry(1.8, 0.2, 0.8);
                const cradle = new THREE.Mesh(cradleGeo, materials.panel);
                cradle.position.set(0, 0.5, 0);
                this.group.add(cradle);

                this.addToParts(roller, 1.5);
            }
            createBlank() {
                // Logo
            }

            update(explodeVal) {
                // 1. Move entire module away from center
                const centerDist = this.homePos.clone().normalize();
                this.group.position.x = this.homePos.x + (centerDist.x * explodeVal * 2.0);
                this.group.position.z = this.homePos.z + (centerDist.z * explodeVal * 2.0);

                // 2. Explode parts upwards
                this.parts.forEach(p => {
                    p.mesh.position.y = p.home.y + (explodeVal * p.speed);
                });
            }
        }

        // --- GENERATE GRID ---
        const layout = [
            ['knob', 'fader', 'knob'],
            ['pad', 'touch', 'pad'],
            ['roller', 'fader', 'roller']
        ];

        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                const type = layout[r][c];
                new Module(c - 1, r - 1, type);
            }
        }

        // --- ANIMATION LOOP ---

        // Input handling
        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                controls.enableZoom = false;
                state.targetExplode += e.deltaY * 0.001;
                state.targetExplode = Math.max(0, Math.min(2.0, state.targetExplode));
            } else {
                controls.enableZoom = true;
            }
        }, { passive: false });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'Control') controls.enableZoom = true;
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Smooth interpolation
            state.explode += (state.targetExplode - state.explode) * 0.1;

            modules.forEach(m => m.update(state.explode));

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>
