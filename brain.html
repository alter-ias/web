<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cerebro Interactivo + Red Neuronal</title>
    <style>
        :root { --primary: #00f3ff; --secondary: #ff0055; --bg: #050510; --glass: rgba(20, 20, 35, 0.8); }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, sans-serif; background-color: var(--bg); color: white; }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        
        #ui-layer { position: absolute; width: 100%; height: 100%; z-index: 2; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        header { padding: 20px; background: linear-gradient(to bottom, black, transparent); pointer-events: auto; }
        h1 { margin: 0; font-weight: 300; text-transform: uppercase; font-size: 1.5rem; color: var(--primary); text-shadow: 0 0 10px var(--primary); }
        .subtitle { font-size: 0.9rem; color: #aaa; }
        
        .info-panel { 
            position: absolute; right: 20px; top: 15%; width: 320px; 
            background: var(--glass); backdrop-filter: blur(10px); 
            border-left: 3px solid var(--primary); padding: 25px; 
            border-radius: 10px; pointer-events: auto; 
            transition: all 0.4s ease;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .info-card { display: none; animation: slideIn 0.5s ease; }
        .info-card.active { display: block; }
        
        h3 { color: var(--primary); margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px; }
        p { font-size: 0.95rem; line-height: 1.6; color: #eee; }
        .stat-highlight { color: var(--secondary); font-weight: bold; }

        .nav-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; pointer-events: auto;
            background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 30px;
        }

        .nav-btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 8px 15px; border-radius: 20px; cursor: pointer;
            transition: all 0.3s; font-size: 0.8rem; text-transform: uppercase;
        }

        .nav-btn:hover, .nav-btn.active {
            background: var(--primary); border-color: var(--primary);
            color: black; font-weight: bold; box-shadow: 0 0 15px var(--primary);
        }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--primary); font-size: 1.5rem; z-index: 10; font-weight: 300; }

        @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.147.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loading">Cargando Modelo...</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>Neuro-Tech Explorer</h1>
            <p class="subtitle">Análisis de Red Neuronal Activa</p>
        </header>

        <div class="info-panel">
            <div id="content-0" class="info-card active">
                <h3>Actividad Global</h3>
                <p>Las <span style="color:#00f3ff">neuronas externas</span> representan la actividad sináptica. El cerebro consume el 20% de la energía del cuerpo manteniendo estos canales eléctricos activos.</p>
            </div>
            <div id="content-1" class="info-card">
                <h3>Procesamiento Visual</h3>
                <p>Al enfocar la visión, la actividad eléctrica se dispara en el lóbulo occipital (parte trasera). La red neuronal aquí es densa para procesar píxeles a alta velocidad.</p>
            </div>
            <div id="content-2" class="info-card">
                <h3>Control Motor</h3>
                <p>La coordinación requiere disparos neuronales precisos en el cerebelo. Observa cómo la luz naranja indica los impulsos de movimiento y equilibrio.</p>
            </div>
            <div id="content-3" class="info-card">
                <h3>Juicio y Razón</h3>
                <p>El lóbulo frontal (azul). Aquí las conexiones son más lentas pero más complejas, integrando información de todo el cerebro para tomar decisiones.</p>
            </div>
        </div>

        <div class="nav-bar">
            <button class="nav-btn active" onclick="focusSection(0)">Global</button>
            <button class="nav-btn" onclick="focusSection(1)">Visión</button>
            <button class="nav-btn" onclick="focusSection(2)">Motor</button>
            <button class="nav-btn" onclick="focusSection(3)">Frontal</button>
        </div>
    </div>

    <script>
        // --- CONFIGURACIÓN DE ESCENA ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // Corrección de color para Three.js r147+
        renderer.outputEncoding = THREE.sRGBEncoding; 
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 40;

        // --- LUCES ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(5, 10, 7);
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0x00f3ff, 0.5);
        fillLight.position.set(-5, 0, -5);
        scene.add(fillLight);

        // Luz "Linterna" interactiva
        const spotLight = new THREE.PointLight(0x00f3ff, 3, 25);
        spotLight.position.set(0, 5, 0);
        scene.add(spotLight);


        // --- EFECTOS VISUALES: NEURONAS ---
        function getNeuronTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.6, 'rgba(255,255,255,0.1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        let neuronSystem, neuronLines;
        
        function createNeuralNetwork() {
            // Aumentamos el radio para asegurar que rodee al modelo
            const radius = 8.5; 
            const particleCount = 350;
            const positions = [];
            
            for (let i = 0; i < particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = radius + (Math.random() - 0.5) * 1.5; 
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const pMat = new THREE.PointsMaterial({
                color: 0x00f3ff, size: 0.5, map: getNeuronTexture(),
                transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            neuronSystem = new THREE.Points(geometry, pMat);
            scene.add(neuronSystem);

            // Líneas
            const lineGeo = new THREE.BufferGeometry();
            const linePos = [];
            for (let i = 0; i < positions.length; i+=3) {
                const v1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                for (let j = i+3; j < positions.length; j+=3) {
                    const v2 = new THREE.Vector3(positions[j], positions[j+1], positions[j+2]);
                    if (v1.distanceTo(v2) < 3.0) {
                        linePos.push(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z);
                    }
                }
            }
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
            neuronLines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({
                color: 0x00f3ff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending
            }));
            scene.add(neuronLines);
        }

        createNeuralNetwork();

        // --- CARGA DEL MODELO (CORREGIDO) ---
        let brainModel = null;
        
        // Configuración para Draco Moderno con Three r147
        const loader = new THREE.GLTFLoader();
        const dracoLoader = new THREE.DRACOLoader();
        
        // Usamos el decoder de Google que es robusto
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        dracoLoader.setDecoderConfig({ type: 'js' });
        loader.setDRACOLoader(dracoLoader);

        loader.load('models/gltf/brains.glb', 
            (gltf) => {
                brainModel = gltf.scene;
                
                // AJUSTES DE TAMAÑO Y POSICIÓN
                // Si no lo ves, prueba a cambiar estos valores
                brainModel.scale.set(6, 6, 6); 
                brainModel.position.set(0, -1, 0); 
                
                // Asegurar que los materiales respondan a la luz
                brainModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                scene.add(brainModel);
                document.getElementById('loading').style.display = 'none';
                console.log("¡Cerebro cargado correctamente!");

                // Animación de entrada
                new TWEEN.Tween(brainModel.rotation).to({ y: Math.PI * 2 }, 2500).easing(TWEEN.Easing.Cubic.Out).start();
            }, 
            (xhr) => { console.log((xhr.loaded / xhr.total * 100) + '% cargado'); },
            (error) => { 
                console.error('Error:', error); 
                document.getElementById('loading').innerHTML = 'Error al cargar.<br>Verifica la carpeta models/gltf/';
            }
        );

        // --- INTERACTIVIDAD ---
        function focusSection(index) {
            // UI Update
            document.querySelectorAll('.info-card').forEach(c => c.classList.remove('active'));
            document.getElementById(`content-${index}`).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.nav-btn')[index].classList.add('active');

            let colorHex = '#ffffff';
            let camPos = { x: 0, y: 0, z: 18 };
            let lightPos = { x: 5, y: 10, z: 5 };

            switch(index) {
                case 0: // Global (Cian)
                    colorHex = '#00f3ff';
                    break;
                case 1: // Visión (Magenta/Rojo) - Vista Trasera
                    colorHex = '#ff0055';
                    camPos = { x: 10, y: 2, z: -10 }; 
                    lightPos = { x: 0, y: 0, z: -10 };
                    break;
                case 2: // Motor (Naranja) - Vista Superior/Trasera
                    colorHex = '#ffaa00';
                    camPos = { x: 0, y: 12, z: 8 };
                    lightPos = { x: 0, y: 8, z: 0 };
                    break;
                case 3: // Frontal (Azul eléctrico) - Vista Frontal
                    colorHex = '#4444ff';
                    camPos = { x: -8, y: 3, z: 12 };
                    lightPos = { x: 0, y: 3, z: 10 };
                    break;
            }

            // Animar todo junto (Luces, Neuronas, Cámara)
            const targetColor = new THREE.Color(colorHex);

            if (neuronSystem && neuronLines) {
                new TWEEN.Tween(neuronSystem.material.color).to({r: targetColor.r, g: targetColor.g, b: targetColor.b}, 800).start();
                new TWEEN.Tween(neuronLines.material.color).to({r: targetColor.r, g: targetColor.g, b: targetColor.b}, 800).start();
            }

            new TWEEN.Tween(spotLight.color).to({r: targetColor.r, g: targetColor.g, b: targetColor.b}, 800).start();
            new TWEEN.Tween(spotLight.position).to(lightPos, 1500).easing(TWEEN.Easing.Cubic.Out).start();
            new TWEEN.Tween(camera.position).to(camPos, 2000).easing(TWEEN.Easing.Cubic.InOut).start();
        }

        // --- LOOP PRINCIPAL ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // Animación suave de flotación
            if (brainModel) {
                brainModel.position.y = -1 + Math.sin(time * 0.001) * 0.1;
            }

            if (neuronSystem) {
                neuronSystem.rotation.y = time * 0.0001;
                neuronSystem.rotation.z = Math.sin(time * 0.0002) * 0.05;
                neuronLines.rotation.y = time * 0.0001;
                neuronLines.rotation.z = Math.sin(time * 0.0002) * 0.05;
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
