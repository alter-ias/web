<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cerebro Interactivo + Red Neuronal</title>
    <style>
        :root { --primary: #00f3ff; --secondary: #ff0055; --bg: #050510; --glass: rgba(20, 20, 35, 0.8); }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, sans-serif; background-color: var(--bg); color: white; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        #ui-layer { position: absolute; width: 100%; height: 100%; z-index: 2; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* UI Styles (Iguales al anterior) */
        header { padding: 20px; background: linear-gradient(to bottom, black, transparent); pointer-events: auto; }
        h1 { margin: 0; font-weight: 300; text-transform: uppercase; font-size: 1.5rem; color: var(--primary); text-shadow: 0 0 10px var(--primary); }
        .subtitle { font-size: 0.9rem; color: #aaa; }
        
        .info-panel { position: absolute; right: 20px; top: 15%; width: 320px; background: var(--glass); backdrop-filter: blur(10px); border-left: 3px solid var(--primary); padding: 25px; border-radius: 10px; pointer-events: auto; transition: all 0.4s ease; }
        .info-card { display: none; animation: slideIn 0.5s ease; }
        .info-card.active { display: block; }
        h3 { color: var(--primary); margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 10px; }
        
        .nav-bar { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; pointer-events: auto; background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 30px; }
        .nav-btn { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 15px; border-radius: 20px; cursor: pointer; transition: all 0.3s; font-size: 0.8rem; text-transform: uppercase; }
        .nav-btn:hover, .nav-btn.active { background: var(--primary); border-color: var(--primary); color: black; font-weight: bold; box-shadow: 0 0 15px var(--primary); }

        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--primary); font-size: 1.5rem; z-index: 10; }
        @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loading">Cargando Modelo...</div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>Neuro-Tech Explorer</h1>
            <p class="subtitle">Análisis de Red Neuronal Activa</p>
        </header>

        <div class="info-panel">
            <div id="content-0" class="info-card active">
                <h3>Actividad Global</h3>
                <p>Las <span style="color:#00f3ff">neuronas externas</span> representan la actividad sináptica. El cerebro consume el 20% de la energía del cuerpo manteniendo estos canales eléctricos activos.</p>
            </div>
            <div id="content-1" class="info-card">
                <h3>Procesamiento Visual</h3>
                <p>Al enfocar la visión, la actividad eléctrica se dispara en el lóbulo occipital. La red neuronal aquí es densa para procesar píxeles a alta velocidad.</p>
            </div>
            <div id="content-2" class="info-card">
                <h3>Control Motor</h3>
                <p>La coordinación requiere disparos neuronales precisos en el cerebelo. Observa cómo la red cambia para simular impulsos de movimiento.</p>
            </div>
            <div id="content-3" class="info-card">
                <h3>Juicio y Razón</h3>
                <p>El lóbulo frontal. Aquí las conexiones son más lentas pero más complejas, integrando información de todo el cerebro para tomar decisiones.</p>
            </div>
        </div>

        <div class="nav-bar">
            <button class="nav-btn active" onclick="focusSection(0)">Global</button>
            <button class="nav-btn" onclick="focusSection(1)">Visión</button>
            <button class="nav-btn" onclick="focusSection(2)">Motor</button>
            <button class="nav-btn" onclick="focusSection(3)">Frontal</button>
        </div>
    </div>

    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.025); // Niebla un poco más densa

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5;
        controls.maxDistance = 40;

        // --- LUCES ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(5, 5, 5);
        scene.add(mainLight);

        // Luz dinámica (Spotlight)
        const spotLight = new THREE.PointLight(0x00f3ff, 2, 20);
        spotLight.position.set(0, 5, 0);
        scene.add(spotLight);

        // --- 1. FUNCIÓN PARA CREAR TEXTURA DE NEURONA (Sin archivos externos) ---
        function getNeuronTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            // Crear gradiente radial (brillo)
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- 2. CREACIÓN DE LA RED NEURONAL ---
        let neuronSystem, neuronLines;
        
        function createNeuralNetwork() {
            const particleCount = 400; // Número de neuronas flotantes
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            // Generar nube esférica alrededor del cerebro
            const radius = 7.5; // *IMPORTANTE*: Ajusta esto si la red queda muy lejos o dentro del cerebro
            
            for (let i = 0; i < particleCount; i++) {
                // Matemáticas para distribuir puntos en una esfera
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                // Un poco de variación en el radio para dar volumen
                const r = radius + (Math.random() - 0.5) * 2; 

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                positions.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            // Material para los puntos (somas neuronales)
            const pMaterial = new THREE.PointsMaterial({
                color: 0x00f3ff,
                size: 0.4,
                map: getNeuronTexture(),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            neuronSystem = new THREE.Points(geometry, pMaterial);
            scene.add(neuronSystem);

            // Crear líneas (conexiones sinápticas) entre puntos cercanos
            const lineMaterial = new THREE.LineBasicMaterial({
                color: 0x00f3ff,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending
            });

            const lineGeometry = new THREE.BufferGeometry();
            const linePos = [];
            
            // Algoritmo simple de conexión: conecta si están cerca
            for (let i = 0; i < positions.length; i+=3) {
                const v1 = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
                // Comparamos con los siguientes puntos (limitado para rendimiento)
                for (let j = i+3; j < positions.length; j+=3) {
                    const v2 = new THREE.Vector3(positions[j], positions[j+1], positions[j+2]);
                    if (v1.distanceTo(v2) < 2.5) { // Distancia de conexión
                        linePos.push(v1.x, v1.y, v1.z);
                        linePos.push(v2.x, v2.y, v2.z);
                    }
                }
            }
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePos, 3));
            neuronLines = new THREE.LineSegments(lineGeometry, lineMaterial);
            scene.add(neuronLines);
        }

        // Llamamos a la función para crear la red
        createNeuralNetwork();


        // --- CARGAR MODELO (Tu cerebro GLB) ---
        let brainModel = null;
        const loader = new THREE.GLTFLoader();
        const dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        loader.setDRACOLoader(dracoLoader);

        loader.load('models/gltf/brains.glb', (gltf) => {
            brainModel = gltf.scene;
            brainModel.scale.set(6, 6, 6); 
            brainModel.position.set(0, -2, 0); 
            
            // Material un poco más oscuro para que resalten las luces
            brainModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.roughness = 0.7;
                }
            });

            scene.add(brainModel);
            document.getElementById('loading').style.display = 'none';
        });

        // --- INTERACTIVIDAD ---
        function focusSection(index) {
            // UI Update
            document.querySelectorAll('.info-card').forEach(c => c.classList.remove('active'));
            document.getElementById(`content-${index}`).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.nav-btn')[index].classList.add('active');

            // Configuración de Colores y Posiciones
            let colorHex = '#ffffff';
            let camPos = { x: 0, y: 0, z: 18 };
            let lightPos = { x: 5, y: 10, z: 5 };

            switch(index) {
                case 0: // Global (Cian)
                    colorHex = '#00f3ff';
                    break;
                case 1: // Visión (Magenta/Rojo)
                    colorHex = '#ff0055';
                    camPos = { x: 8, y: 2, z: -10 }; 
                    lightPos = { x: 0, y: 0, z: -8 };
                    break;
                case 2: // Motor (Naranja)
                    colorHex = '#ffaa00';
                    camPos = { x: 0, y: 10, z: 10 };
                    lightPos = { x: 0, y: 8, z: 0 };
                    break;
                case 3: // Frontal (Azul eléctrico)
                    colorHex = '#4444ff';
                    camPos = { x: -8, y: 2, z: 10 };
                    lightPos = { x: 0, y: 2, z: 8 };
                    break;
            }

            // 1. ANIMAR COLOR DE LA RED NEURONAL
            if (neuronSystem && neuronLines) {
                const targetColor = new THREE.Color(colorHex);
                
                // Tween para puntos
                new TWEEN.Tween(neuronSystem.material.color)
                    .to({ r: targetColor.r, g: targetColor.g, b: targetColor.b }, 1000)
                    .start();
                
                // Tween para líneas
                new TWEEN.Tween(neuronLines.material.color)
                    .to({ r: targetColor.r, g: targetColor.g, b: targetColor.b }, 1000)
                    .start();
            }

            // 2. ANIMAR LUZ SPOT
            new TWEEN.Tween(spotLight.color)
                .to(new THREE.Color(colorHex), 1000)
                .start();
            new TWEEN.Tween(spotLight.position)
                .to(lightPos, 1500)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            // 3. ANIMAR CÁMARA
            new TWEEN.Tween(camera.position)
                .to(camPos, 2000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }

        // --- LOOP PRINCIPAL ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // Animación de "Respiración" para la red neuronal
            if (neuronSystem && neuronLines) {
                // Rotación suave independiente del cerebro
                neuronSystem.rotation.y = time * 0.0001;
                neuronLines.rotation.y = time * 0.0001;
                
                // Pulsación (Scale)
                const pulse = 1 + Math.sin(time * 0.001) * 0.02;
                neuronSystem.scale.set(pulse, pulse, pulse);
                neuronLines.scale.set(pulse, pulse, pulse);
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
