<script>
    // --- VARIABLES GLOBALES ---
    const game = new Chess();
    let board = null;
    let engine = null;
    let redoStack = []; 
    let isEnginePlaying = false; // Bandera para saber si la IA está moviendo
    
    // --- 1. EL "OBSERVADOR" (Lógica Lingüística Real) ---
    // Este objeto traduce la posición del tablero a palabras humanas
    const Observer = {
        lastScore: 0,

        evaluate: function(gameInstance, engineScore, playerColor) {
            const fen = gameInstance.fen();
            const turn = gameInstance.turn();
            const history = gameInstance.history({verbose: true});
            const lastMove = history.length > 0 ? history[history.length - 1] : null;

            let comments = [];
            let tags = [];

            // A. ANÁLISIS DEL MOVIMIENTO RECIENTE (Blunders/Errores)
            // Calculamos el cambio de suerte (Delta)
            // Nota: engineScore siempre lo normalizamos a: Positivo = Ventaja para el Jugador Humano
            let delta = engineScore - this.lastScore;
            
            // Si acabas de mover y la puntuación bajó drásticamente...
            if (lastMove && lastMove.color === playerColor) {
                if (delta < -200) { 
                    tags.push({text: "Error Grave", type: "bad"});
                    comments.push("¡Ay! Ese movimiento ha regalado una gran ventaja. Has dejado una pieza colgada o ignorado una amenaza.");
                } else if (delta < -80) {
                    tags.push({text: "Imprecisión", type: "warn"});
                    comments.push("Esa jugada es pasiva. Había opciones más activas.");
                } else if (delta > 50 && engineScore > 50) {
                    tags.push({text: "Buena Jugada", type: "good"});
                    comments.push("¡Bien visto! Aprovechas la posición.");
                }
            }
            this.lastScore = engineScore; // Guardar para el siguiente turno

            // B. ANÁLISIS POSICIONAL (Heurísticas Humanas)
            
            // 1. Control del Centro (e4, d4, e5, d5)
            const centerControl = this.checkCenter(gameInstance, playerColor);
            if (centerControl > 1) {
                // Solo lo mencionamos si no hay errores graves
                if (comments.length === 0) comments.push("Tienes un excelente control del centro del tablero.");
                tags.push({text: "Centro Fuerte", type: "good"});
            } else if (centerControl < -1) {
                if (comments.length === 0) comments.push("Tu oponente domina el centro. Intenta romper con peones.");
                tags.push({text: "Centro Débil", type: "warn"});
            }

            // 2. Seguridad del Rey
            const kingSafety = this.checkKingSafety(gameInstance, playerColor);
            if (!kingSafety.castled && gameInstance.moveNumber() > 10) {
                tags.push({text: "Rey Expuesto", type: "bad"});
                comments.push("Es peligroso mantener al rey en el centro tantas jugadas. ¡Enrócate pronto!");
            }

            // 3. Desarrollo (Piezas en primera fila)
            const dev = this.checkDevelopment(gameInstance, playerColor);
            if (dev.undeveloped > 2 && gameInstance.moveNumber() > 8) {
                tags.push({text: "Desarrollo Lento", type: "warn"});
                if (comments.length === 0) comments.push("Saca tus caballos y alfiles antes de mover la misma pieza dos veces.");
            }

            // C. RESUMEN GENERAL (Si no hay nada específico que decir)
            if (comments.length === 0) {
                if (Math.abs(engineScore) < 50) comments.push("La posición está igualada. Busca debilidades menores.");
                else if (engineScore > 150) comments.push("Vas ganando. Simplifica la posición (cambia piezas) para asegurar la victoria.");
                else if (engineScore < -150) comments.push("Posición difícil. Busca complicaciones tácticas para confundir al rival.");
            }

            // Renderizar en el DOM
            this.render(comments, tags);
        },

        // Cuenta piezas propias en e4,d4,e5,d5
        checkCenter: function(game, color) {
            const centerSquares = ['d4', 'e4', 'd5', 'e5'];
            let score = 0;
            centerSquares.forEach(sq => {
                const piece = game.get(sq);
                if (piece) {
                    if (piece.color === color) score++;
                    else score--;
                }
            });
            return score;
        },

        // Revisa si se ha enrocado
        checkKingSafety: function(game, color) {
            // Revisamos el historial para ver si hubo enroque
            const history = game.history({verbose: true});
            const castled = history.some(m => m.color === color && m.san.includes("O-O"));
            return { castled: castled };
        },

        // Cuenta piezas mayores/menores en la fila trasera
        checkDevelopment: function(game, color) {
            const rank = color === 'w' ? '1' : '8';
            const pieces = ['b'+rank, 'c'+rank, 'f'+rank, 'g'+rank]; // Caballos y Alfiles
            let count = 0;
            pieces.forEach(sq => {
                const piece = game.get(sq);
                if (piece && piece.color === color) count++; // Siguen en casa
            });
            return { undeveloped: count };
        },

        render: function(msgs, tags) {
            // Mostrar máximo 2 mensajes para no saturar
            $('#coachMsg').html(msgs.slice(0, 2).join("<br><br>"));
            $('#coachTags').empty();
            tags.forEach(t => {
                $('#coachTags').append(`<span class="tag ${t.type}">${t.text}</span>`);
            });
        }
    };

    // --- 2. CONFIGURACIÓN DEL MOTOR ---
    function initStockfish() {
        // Carga mediante Blob para evitar problemas de rutas locales
        fetch('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.0/stockfish.js')
            .then(r => r.blob())
            .then(blob => {
                engine = new Worker(URL.createObjectURL(blob));
                engine.postMessage('uci');
                
                engine.onmessage = function(event) {
                    const msg = event.data;
                    
                    // A. LA IA DECIDE MOVER
                    if (msg.startsWith('bestmove')) {
                        // Solo movemos si la IA estaba pensando para JUGAR, no para analizar
                        if (isEnginePlaying) {
                            const bestMove = msg.split(' ')[1];
                            game.move(bestMove, {sloppy: true});
                            board.position(game.fen());
                            redoStack = []; // Romper historial futuro
                            
                            isEnginePlaying = false;
                            $('#thinkingIndicator').hide();
                            updateStatus();
                            
                            // Inmediatamente después de mover, pedimos ANÁLISIS (Coach)
                            triggerAnalysis();
                        }
                    }

                    // B. ANÁLISIS DE EVALUACIÓN (SCORE)
                    if (msg.startsWith('info') && msg.includes('score')) {
                        // Filtramos profundidad baja para evitar parpadeos numéricos
                        if (msg.includes('depth 10') || msg.includes('mate')) {
                            const match = msg.match(/score (cp|mate) (-?\d+)/);
                            if (match) {
                                let score = parseInt(match[2]);
                                let type = match[1];

                                // AJUSTE VITAL: Stockfish da el score relativo al que mueve.
                                // Para el Coach, necesitamos score relativo al JUGADOR HUMANO.
                                const turn = game.turn(); // Turno actual (del que va a mover)
                                const playerColor = $('#playerColor').val();

                                // Convertir a absoluto (Perspectiva Blancas)
                                let absoluteScore = (turn === 'w') ? score : -score;

                                // Convertir a perspectiva Jugador
                                let playerScore = (playerColor === 'w') ? absoluteScore : -absoluteScore;

                                updateEvalBar(type, absoluteScore); // La barra siempre muestra Blancas vs Negras
                                Observer.evaluate(game, playerScore, playerColor);
                            }
                        }
                    }
                };
                updateStatus();
            });
    }

    // --- 3. LÓGICA DEL JUEGO ---
    
    // Función para que la IA mueva (Nivel Configurado)
    function triggerAI() {
        if (game.game_over()) return;
        
        isEnginePlaying = true;
        $('#thinkingIndicator').show().text("La IA está pensando...");
        
        const skill = $('#skillLevel').val(); 
        
        // 1. Configuramos el nivel ELEGIDO por el usuario
        engine.postMessage(`setoption name Skill Level value ${skill}`);
        
        // 2. Tiempo/Profundidad acorde al nivel
        // Nivel bajo = piensa poco. Nivel alto = piensa más.
        let depth = skill < 5 ? 5 : (skill < 15 ? 10 : 15);
        
        engine.postMessage(`position fen ${game.fen()}`);
        engine.postMessage(`go depth ${depth}`);
    }

    // Función para solo Analizar (Siempre Máxima Potencia)
    function triggerAnalysis() {
        // 1. Para analizar, usamos SIEMPRE el máximo nivel para que el consejo sea bueno
        engine.postMessage(`setoption name Skill Level value 20`);
        
        // 2. Pedimos análisis pero NO pedimos que mueva (no activamos isEnginePlaying)
        engine.postMessage(`position fen ${game.fen()}`);
        engine.postMessage('go depth 12'); // Profundidad media para análisis rápido
    }

    function onDrop(source, target) {
        // Intentar mover
        const move = game.move({ from: source, to: target, promotion: 'q' });
        if (move === null) return 'snapback';

        redoStack = []; // Nuevo movimiento borra el "Adelante"
        board.position(game.fen());
        updateStatus();

        // Flujo de turnos
        const mode = $('#gameMode').val();
        const playerColor = $('#playerColor').val();

        if (mode === 'pvc') {
            // Si juego vs IA, y ahora no es mi turno, le toca a ella
            if (game.turn() !== playerColor) {
                // Primero analizamos tu jugada (Coach)
                triggerAnalysis();
                // Luego de un pequeño delay, la IA juega
                setTimeout(triggerAI, 500);
            }
        } else {
            // Si es modo análisis (Jugador vs Jugador), solo analizamos
            triggerAnalysis();
        }
    }

    function onDragStart(source, piece) {
        if (game.game_over() || isEnginePlaying) return false;
        
        const mode = $('#gameMode').val();
        const playerColor = $('#playerColor').val();

        // En modo Vs IA, no dejo que muevas las piezas del rival
        if (mode === 'pvc') {
            if ((playerColor === 'w' && piece.search(/^b/) !== -1) ||
                (playerColor === 'b' && piece.search(/^w/) !== -1)) {
                return false;
            }
        }
    }

    // --- 4. CONTROLES Y NAVEGACIÓN ---

    $('#btnNewGame').click(() => {
        game.reset();
        redoStack = [];
        Observer.lastScore = 0; // Reiniciar coach
        
        const pColor = $('#playerColor').val();
        board.orientation(pColor === 'w' ? 'white' : 'black');
        board.start();
        
        isEnginePlaying = false;
        $('#thinkingIndicator').hide();
        updateStatus();

        // Si soy negras, IA arranca
        if ($('#gameMode').val() === 'pvc' && pColor === 'b') {
            triggerAI();
        } else {
            triggerAnalysis();
        }
    });

    // Undo / Redo
    function handleUndo() {
        if (isEnginePlaying) return;
        
        // Retroceder
        let move = game.undo();
        if (move) redoStack.push(move);

        // Si es Vs IA, retroceder otro más (el de la IA) para que sea mi turno
        if ($('#gameMode').val() === 'pvc') {
            let move2 = game.undo();
            if (move2) redoStack.push(move2);
        }

        board.position(game.fen());
        updateStatus();
        triggerAnalysis(); // Re-analizar la posición anterior
    }

    function handleRedo() {
        if (isEnginePlaying || redoStack.length === 0) return;

        let move = redoStack.pop();
        game.move(move);

        // Si es Vs IA, rehacer también la respuesta de la IA
        if ($('#gameMode').val() === 'pvc' && redoStack.length > 0) {
            let move2 = redoStack.pop();
            game.move(move2);
        }

        board.position(game.fen());
        updateStatus();
        triggerAnalysis();
    }

    $('#btnUndo').click(handleUndo);
    $('#btnRedo').click(handleRedo);
    $('#btnFlip').click(() => board.flip());

    // Teclas
    document.addEventListener('keydown', (e) => {
        if (e.key === "ArrowLeft") handleUndo();
        if (e.key === "ArrowRight") handleRedo();
    });

    // Carga de Aperturas
    const lessons = [
        {name: "Apertura Italiana", pgn: "1. e4 e5 2. Nf3 Nc6 3. Bc4"},
        {name: "Defensa Siciliana", pgn: "1. e4 c5 2. Nf3 d6 3. d4 cxd4"},
        {name: "Gambito de Dama", pgn: "1. d4 d5 2. c4 dxc4"}
    ];
    lessons.forEach((l, i) => $('#openingSelect').append(new Option(l.name, i)));

    $('#openingSelect').change(function() {
        const idx = $(this).val();
        if (idx !== "") {
            game.load_pgn(lessons[idx].pgn);
            board.position(game.fen());
            redoStack = [];
            // Al cargar lección, cambiamos a modo análisis para que la IA no juegue sola
            $('#gameMode').val('analysis'); 
            triggerAnalysis();
        }
    });

    // --- 5. UI UTILS ---
    function updateStatus() {
        let status = '';
        if (game.in_checkmate()) status = "Jaque Mate";
        else if (game.in_draw()) status = "Tablas";
        else status = (game.turn() === 'w' ? "Turno Blancas" : "Turno Negras");
        
        if (game.in_check()) status += " (JAQUE)";
        $('#status').text(status);
    }

    function updateEvalBar(type, score) {
        // La barra es absoluta (Blancas vs Negras)
        let percent = 50;
        let text = "0.0";
        
        if (type === 'mate') {
            percent = score > 0 ? 100 : 0;
            text = "M" + Math.abs(score);
        } else {
            let val = Math.max(-500, Math.min(500, score));
            percent = 50 + (val / 10);
            text = (score / 100).toFixed(1);
            if (score > 0) text = "+" + text;
        }
        
        $('#evalFill').css('width', percent + '%');
        $('#evalText').text(text);
        
        // Colores de la barra
        if (percent > 55) $('#evalFill').css('background', '#fff');
        else if (percent < 45) $('#evalFill').css('background', '#444');
        else $('#evalFill').css('background', '#888');
    }

    // --- INICIALIZACIÓN ---
    $(document).ready(function() {
        board = Chessboard('board', {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        });
        $(window).resize(board.resize);
        
        initStockfish();
    });
</script>
