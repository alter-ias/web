<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Artimotion - Level 8: Harmonic Flow</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; letter-spacing: 2px;
            background: rgba(0, 10, 20, 0.9); padding: 20px 40px; border-radius: 4px;
            border: 1px solid #0ff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            pointer-events: none; z-index: 10;
            text-align: center;
        }

        #bottom-menu {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 5;
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .mode-btn {
            background: rgba(20, 20, 20, 0.8); color: #888; border: 1px solid #444;
            padding: 10px 20px; border-radius: 8px; cursor: pointer;
            font-weight: bold; text-transform: uppercase; font-size: 12px;
            transition: all 0.3s ease;
        }

        .mode-btn:hover { background: #333; color: #fff; border-color: #fff; }
        .mode-btn.active { background: #0ff; color: #000; border-color: #0ff; box-shadow: 0 0 15px #0ff; }
        
        #audio-hint {
            position: absolute; top: 20px; right: 20px; 
            color: rgba(255,255,255,0.5); font-size: 10px; z-index: 5; text-align: right;
        }

        .lil-gui { --background-color: rgba(5, 5, 10, 0.9); --text-color: #ddd; --title-background-color: #111; }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';
        import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.esm.min.js';

        // --- PARÁMETROS GLOBALES ---
        const params = {
            key: 'A', // Tonalidad por defecto
            trailStyle: 'Ribbon', 
            lineWidth: 0.8,
            bloomStrength: 1.5,
            colorSpeed: 1.5,
            opacity: 0.85,
            particleSize: 1.0, 
            mode: 'Spectral',
            inputSensitivity: 1.5,
            soundEnabled: true,
            reset: () => resetCanvas()
        };

        // --- TEORÍA MUSICAL ---
        const NOTES = { 'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88 };
        // Intervalos Pentatónica Menor: Tónica, 3m, 4, 5, 7m (Semitonos: 0, 3, 5, 7, 10)
        const PENTA_INTERVALS = [0, 3, 5, 7, 10];

        function getFrequency(baseFreq, semitones) {
            return baseFreq * Math.pow(2, semitones / 12);
        }

        // Genera 3 octavas de pentatónica basada en la nota raíz
        function generateScale(rootKey) {
            const base = NOTES[rootKey] / 2; // Empezar una octava abajo
            const scale = [];
            for (let oct = 0; oct < 3; oct++) {
                PENTA_INTERVALS.forEach(interval => {
                    scale.push(getFrequency(base * Math.pow(2, oct), interval));
                });
            }
            return scale;
        }

        // Genera acordes funcionales (Tríadas) para la mano izquierda
        // i (Menor), VI (Mayor), VII (Mayor) - Progresión épica estilo Rock/Cine
        function generateChords(rootKey) {
            const base = NOTES[rootKey] / 4; // Bajo profundo
            // Acorde 1: Tónica Menor (i) -> 0, 3, 7
            const chord1 = [getFrequency(base, 0), getFrequency(base, 3), getFrequency(base, 7)];
            // Acorde 2: Sexto Grado Mayor (VI) -> 8, 12, 15
            const chord2 = [getFrequency(base, 8), getFrequency(base, 12), getFrequency(base, 15)];
             // Acorde 3: Séptimo Grado Mayor (VII) -> 10, 14, 17
            const chord3 = [getFrequency(base, 10), getFrequency(base, 14), getFrequency(base, 17)];
            
            return [chord1, chord2, chord3];
        }

        let currentScale = generateScale(params.key);
        let currentChords = generateChords(params.key);

        // --- MOTOR DE AUDIO ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.melodyOsc = null;
                this.chordOscs = []; // Array de osciladores para acordes
                this.gainMelody = null;
                this.gainChord = null;
                this.isInit = false;
            }

            init() {
                if (this.isInit) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                // 1. CANAL MELODÍA (Mano Derecha)
                this.melodyOsc = this.ctx.createOscillator();
                this.melodyOsc.type = 'triangle';
                this.gainMelody = this.ctx.createGain();
                this.gainMelody.gain.value = 0;
                
                // Efecto Melodía (Delay)
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.25;
                const delayGain = this.ctx.createGain();
                delayGain.gain.value = 0.3;
                
                this.melodyOsc.connect(this.gainMelody);
                this.gainMelody.connect(this.ctx.destination);
                this.gainMelody.connect(delay);
                delay.connect(delayGain);
                delayGain.connect(delay); // Feedback loop
                delay.connect(this.ctx.destination);
                this.melodyOsc.start();

                // 2. CANAL ACORDES (Mano Izquierda - Polifónico)
                this.gainChord = this.ctx.createGain();
                this.gainChord.gain.value = 0;
                
                // Filtro para acordes (Pad suave)
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                this.gainChord.connect(filter);
                filter.connect(this.ctx.destination);

                // Crear 3 osciladores para formar tríadas
                for(let i=0; i<3; i++) {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine'; // Suave
                    osc.connect(this.gainChord);
                    osc.start();
                    this.chordOscs.push(osc);
                }

                this.isInit = true;
                document.getElementById('audio-hint').innerHTML = `AUDIO: ACTIVO<br>Tonalidad: ${params.key} Menor`;
            }

            setKey(newKey) {
                currentScale = generateScale(newKey);
                currentChords = generateChords(newKey);
                if(this.isInit) document.getElementById('audio-hint').innerHTML = `AUDIO: ACTIVO<br>Tonalidad: ${newKey} Menor`;
            }

            updateMelody(normX, normY, active) {
                if (!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;

                if (active) {
                    // CUANTIZAR: Mapear 0-1 al índice del array de escala
                    const index = Math.floor(normX * currentScale.length);
                    const safeIndex = Math.min(Math.max(index, 0), currentScale.length - 1);
                    const targetFreq = currentScale[safeIndex];

                    // Volumen controlado por altura (Y)
                    const vol = Math.max(0, (1.0 - normY) * 0.2);

                    // Cambio de frecuencia rápido pero suave (Legato)
                    this.melodyOsc.frequency.setTargetAtTime(targetFreq, t, 0.05);
                    this.gainMelody.gain.setTargetAtTime(vol, t, 0.1);
                } else {
                    this.gainMelody.gain.setTargetAtTime(0, t, 0.2);
                }
            }

            updateChords(normX, normY, active) {
                if (!this.isInit || !params.soundEnabled) return;
                const t = this.ctx.currentTime;

                if (active) {
                    // SELECCIONAR ACORDE SEGÚN POSICIÓN X
                    let chordIndex = 0;
                    if (normX < 0.33) chordIndex = 0;      // Izquierda: i (Menor)
                    else if (normX < 0.66) chordIndex = 1; // Centro: VI (Mayor)
                    else chordIndex = 2;                   // Derecha: VII (Mayor)

                    const targetChord = currentChords[chordIndex];
                    const vol = Math.max(0, (1.0 - normY) * 0.25); // Un poco más fuerte que la melodía para dar base

                    // Actualizar las 3 notas del acorde
                    this.chordOscs.forEach((osc, i) => {
                        osc.frequency.setTargetAtTime(targetChord[i], t, 0.1);
                    });
                    
                    this.gainChord.gain.setTargetAtTime(vol, t, 0.2); // Attack lento (Pad)
                } else {
                    this.gainChord.gain.setTargetAtTime(0, t, 0.5); // Release largo
                }
            }
        }
        
        const audioSys = new AudioEngine();

        // --- VISUALES (Simplificado para ahorrar espacio, misma lógica visual) ---
        function createSoftTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createSoftTexture();

        // Setup THREE.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 12;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Post-Processing
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = params.bloomStrength;
        composer.addPass(bloomPass);

        // Objetos Fondo
        const bgGroup = new THREE.Group();
        scene.add(bgGroup);
        const gridHelper = new THREE.GridHelper(100, 40, 0x00ffff, 0x222222);
        gridHelper.position.y = -10; gridHelper.visible = false; bgGroup.add(gridHelper);
        const gridTop = gridHelper.clone(); gridTop.position.y = 10; gridHelper.add(gridTop);
        const starGeo = new THREE.BufferGeometry();
        const starCount = 2000;
        const posArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) posArray[i] = (Math.random() - 0.5) * 100;
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starMat = new THREE.PointsMaterial({size: 0.2, color: 0xffffff, transparent: true, opacity: 0.8});
        const starField = new THREE.Points(starGeo, starMat);
        starField.visible = false; bgGroup.add(starField);

        function setScenario(name) {
            gridHelper.visible = false; starField.visible = false;
            scene.background = new THREE.Color(0x000000); scene.fog.color.setHex(0x000000);
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${name.toLowerCase()}`).classList.add('active');
            if (name === 'Grid') { gridHelper.visible = true; scene.background = new THREE.Color(0x050510); scene.fog.color.setHex(0x050510); } 
            else if (name === 'Warp') { starField.visible = true; scene.background = new THREE.Color(0x000010); }
        }

        // Classes Visuales (Resumidas)
        class RibbonTrail {
            constructor(idx) {
                this.idx = idx; this.length = 40; this.points = []; this.visible = true;
                this.target = new THREE.Vector3(0,-1000,0); this.current = new THREE.Vector3(0,-1000,0);
                for(let i=0; i<this.length; i++) this.points.push(new THREE.Vector3(0,-1000,0));
                
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.length * 6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: params.opacity, blending: THREE.AdditiveBlending });
                this.mesh = new THREE.Mesh(geometry, this.material); scene.add(this.mesh);
            }
            setTarget(x,y,z) { this.target.set(x,y,z); }
            reset() { this.target.set(0,-1000,0); this.current.set(0,-1000,0); }
            tick(time) {
                if(!this.visible) { this.mesh.visible = false; return; }
                this.mesh.visible = true;
                this.current.lerp(this.target, params.relaxation);
                this.points.shift(); this.points.push(this.current.clone());
                
                const curve = new THREE.CatmullRomCurve3(this.points, false, 'catmullrom', 0.5);
                const splinePoints = curve.getPoints(this.length - 1);
                const pos = this.mesh.geometry.attributes.position.array;
                
                for(let i=0; i < splinePoints.length; i++) {
                    const p = splinePoints[i];
                    // Ribbon simple logic para ahorrar código en esta versión
                    pos[i*6+0]=p.x-params.lineWidth*0.5; pos[i*6+1]=p.y; pos[i*6+2]=p.z;
                    pos[i*6+3]=p.x+params.lineWidth*0.5; pos[i*6+4]=p.y; pos[i*6+5]=p.z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
                let hue = (time * params.colorSpeed * 0.1 + (this.idx * 0.05)) % 1;
                this.material.color.setHSL(hue, 1.0, 0.5);
            }
        }
        
        // Inicializar Ribbons
        const ribbons = [];
        for(let i=0; i<10; i++) ribbons.push(new RibbonTrail(i));

        function resetCanvas() { ribbons.forEach(r => r.reset()); }

        // --- MEDIAPIPE + LÓGICA MUSICAL AVANZADA ---
        const videoElement = document.createElement('video');
        const fingerIndices = [4, 8, 12, 16, 20];
        
        // Variables de estado para audio
        let melodyHandActive = false;
        let chordHandActive = false;
        let visibleWidth = 10, visibleHeight = 10;

        function updateVisibleArea() {
            const vFOV = camera.fov * Math.PI / 180;
            visibleHeight = 2 * Math.tan(vFOV / 2) * camera.position.z;
            visibleWidth = visibleHeight * camera.aspect;
        }
        updateVisibleArea();

        function onResults(results) {
            document.getElementById('loading').innerHTML = "CLIC PARA AUDIO<br>Mano 1: Melodía | Mano 2: Acordes";
            
            melodyHandActive = false;
            chordHandActive = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('loading').style.display = 'none';

                results.multiHandLandmarks.forEach((landmarks, handIndex) => {
                    // Actualizar Visuales (Cintas)
                    fingerIndices.forEach((fingerIdx, i) => {
                        const lm = landmarks[fingerIdx];
                        const x = (lm.x - 0.5) * -visibleWidth * params.inputSensitivity; 
                        const y = (lm.y - 0.5) * -visibleHeight * params.inputSensitivity;
                        const z = -lm.z * 20; 
                        const globalIdx = (handIndex * 5) + i;
                        if(ribbons[globalIdx]) ribbons[globalIdx].setTarget(x, y, z);
                    });

                    // Lógica de Audio
                    // Mano Index 0 -> Melodía (Punta del dedo índice)
                    // Mano Index 1 -> Acordes (Punta del dedo índice)
                    const indexFinger = landmarks[8];
                    
                    if (handIndex === 0) {
                        melodyHandActive = true;
                        audioSys.updateMelody(indexFinger.x, indexFinger.y, true);
                    } else if (handIndex === 1) {
                        chordHandActive = true;
                        audioSys.updateChords(indexFinger.x, indexFinger.y, true);
                    }
                });
            }

            // Si no hay manos detectadas, silenciar
            if (!melodyHandActive) audioSys.updateMelody(0, 0, false);
            if (!chordHandActive) audioSys.updateChords(0, 0, false);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        // --- GUI ---
        const gui = new GUI({ title: 'System Core' });
        
        const folderAudio = gui.addFolder('Music Engine');
        folderAudio.add(params, 'soundEnabled').name('Audio ON/OFF');
        folderAudio.add(params, 'key', ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'])
            .name('Tonalidad (Menor)')
            .onChange(val => audioSys.setKey(val));
            
        const folderVisuals = gui.addFolder('Visuals');
        folderVisuals.add(params, 'lineWidth', 0.1, 2.0);
        folderVisuals.add(params, 'bloomStrength', 0.0, 3.0);
        
        window.addEventListener('click', () => {
            audioSys.init();
            if(audioSys.ctx && audioSys.ctx.state === 'suspended') audioSys.ctx.resume();
        });

        document.getElementById('btn-void').onclick = () => setScenario('Void');
        document.getElementById('btn-grid').onclick = () => setScenario('Grid');
        document.getElementById('btn-warp').onclick = () => setScenario('Warp');

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            ribbons.forEach(r => r.tick(time));
            
            if(gridHelper.visible) gridHelper.position.z = (time * 2) % 10;
            if(starField.visible) {
                starField.rotation.z = time * 0.1;
                starField.rotation.x = Math.sin(time * 0.2) * 0.2;
            }
            composer.render();
        }
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            updateVisibleArea();
        });
        setScenario('Void');
    </script>

    <div id="loading">INICIALIZANDO HARMONIC FLOW...</div>
    <div id="audio-hint">CLICK PARA AUDIO</div>
    <div id="bottom-menu">
        <div id="btn-void" class="mode-btn active">Void</div>
        <div id="btn-grid" class="mode-btn">Cyber Grid</div>
        <div id="btn-warp" class="mode-btn">Warp Hole</div>
    </div>
</body>
</html>
