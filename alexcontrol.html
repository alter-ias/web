<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ALEX CONTROL | V.2.1</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&family=Montserrat:wght@400;800;900&display=swap" rel="stylesheet">
    <style>
        /* --- VARIABLES DE TEMA --- */
        :root {
            --bg-color: #050505;
            --text-main: #E8E4D9;
            --text-sub: #888888;
            /* AJUSTE: Naranja visual en CSS */
            --accent: #FF3300; 
            --glass-panel: rgba(20, 20, 20, 0.8);
            --border-color: #333;
        }

        /* TEMA ULTRAVIOLENCIA */
        [data-theme="ultra"] {
            --bg-color: #FF3300;
            --text-main: #000000;
            --text-sub: #2a0000;
            --accent: #FFFFFF;
            --glass-panel: rgba(255, 60, 0, 0.8);
            --border-color: #aa1100;
        }

        body {
            margin: 0;
            background: var(--bg-color);
            color: var(--text-main);
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
            transition: background 0.5s ease, color 0.5s ease;
        }

        /* --- BOTÓN DE CAMBIO DE TEMA --- */
        #theme-toggle {
            position: fixed; top: 30px; left: 10%; z-index: 100;
            background: transparent; border: 2px solid var(--text-main); color: var(--text-main);
            padding: 10px 20px; font-family: 'Rajdhani'; font-weight: 700; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; font-size: 10px; transition: 0.3s;
        }
        #theme-toggle:hover { background: var(--text-main); color: var(--bg-color); }

        /* --- LAYOUT --- */
        #canvas-container {
            position: fixed; top: 0; right: 0; width: 65%; height: 100vh; z-index: 10;
            mask-image: linear-gradient(to right, transparent 0%, black 20%);
            -webkit-mask-image: linear-gradient(to right, transparent 0%, black 20%);
        }

        #content-sidebar {
            position: relative; width: 45%; height: 100vh; overflow-y: auto; z-index: 20;
            background: transparent; scrollbar-width: none;
        }
        #content-sidebar::-webkit-scrollbar { display: none; }

        section {
            min-height: 100vh; display: flex; flex-direction: column; justify-content: center;
            padding: 0 10% 0 20%; box-sizing: border-box;
        }

        /* --- UI ELEMENTS --- */
        .content-box {
            border-left: 4px solid var(--accent); padding-left: 30px;
            opacity: 0; transform: translateY(30px); transition: 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .content-box.visible { opacity: 1; transform: translateY(0); }

        h1 {
            font-family: 'Montserrat'; font-weight: 900; font-size: 85px; margin: 0;
            line-height: 0.85; letter-spacing: -3px; text-transform: uppercase;
            color: var(--text-main);
        }
        h2 {
            font-family: 'Rajdhani'; font-weight: 700; font-size: 14px; letter-spacing: 6px;
            margin: 0 0 20px 0; color: var(--accent); text-transform: uppercase;
        }
        h3 {
            font-family: 'Montserrat'; font-weight: 800; font-size: 32px; margin: 10px 0;
            color: var(--text-main);
        }
        p {
            font-family: 'Rajdhani'; font-weight: 600; font-size: 18px; line-height: 1.6;
            color: var(--text-sub); margin-bottom: 25px; max-width: 420px;
        }

        .interaction-hint {
            position: fixed; bottom: 30px; right: 30px; z-index: 30;
            text-align: right; font-family: 'Rajdhani'; font-weight: 700; font-size: 10px;
            color: var(--text-sub); letter-spacing: 1px; pointer-events: none;
            padding: 10px; border-right: 2px solid var(--accent);
        }

        .btn-cta {
            padding: 15px 35px; background: var(--text-main); color: var(--bg-color);
            border: 2px solid var(--text-main); font-family: 'Montserrat'; font-weight: 800;
            font-size: 12px; cursor: pointer; transition: 0.3s; text-decoration: none;
            display: inline-block; letter-spacing: 1px; margin-right: 10px; text-transform: uppercase;
        }
        .btn-cta:hover { background: var(--accent); border-color: var(--accent); color: #fff; }
        .btn-cta.secondary { background: transparent; color: var(--text-main); }
        .btn-cta.secondary:hover { background: var(--text-main); color: var(--bg-color); }

        @media (max-width: 768px) {
            #canvas-container { width: 100%; height: 50vh; top: 0; right: 0; mask-image: none; -webkit-mask-image: none; border-bottom: 1px solid var(--border-color);}
            #content-sidebar { width: 100%; height: 50vh; top: 50vh; background: var(--bg-color); }
            section { min-height: 50vh; padding: 40px 30px; justify-content: flex-start; }
            h1 { font-size: 50px; }
            #theme-toggle { top: 10px; left: 10px; padding: 5px 10px; font-size: 9px; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.skypack.dev/three@0.136.0",
                "three/addons/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/"
            }
        }
    </script>
</head>
<body data-theme="ludovico">

    <button id="theme-toggle">CAMBIAR TEMA: LUDOVICO (DARK)</button>

    <div id="canvas-container"></div>

    <div class="interaction-hint">
        SCROLL &darr; : ROTAR<br>
        CTRL + SCROLL : EXPLOSIÓN 3D<br>
        DRAG : ORBITAR
    </div>

    <div id="content-sidebar">
        <section id="sec-intro">
            <div class="content-box visible">
                <h2>HARDWARE V.2.1</h2>
                <h1>ALEX</h1>
                <h1>CONTROL</h1>
                <br>
                <p>Interfaz física de alta densidad. Diseñada para la oscuridad. Ejecuta Alex Vision, Synth y Cine Libre con tacto analógico.</p>
                <br>
                <a href="#" class="btn-cta">RESERVAR</a>
                <a href="#" class="btn-cta secondary">VER DETALLES</a>
            </div>
        </section>

        <section id="sec-contrast">
            <div class="content-box">
                <h2>VISIBILIDAD TOTAL</h2>
                <h3>MODO NOCTURNO NATIVO</h3>
                <p>El chasis se adapta a tu entorno. En la oscuridad, Alex Control es una sombra de metal negro donde solo existe la información.</p>
                <p>Nuevos módulos hápticos: <span style="color:var(--accent); font-weight:bold;">Rollers y Touch Strips</span>.</p>
            </div>
        </section>

        <section id="sec-grid">
            <div class="content-box">
                <h2>MODULARIDAD</h2>
                <h3>GRID MAGNÉTICO DE 9 PUNTOS</h3>
                <p>Intercambia faders por knobs en caliente. El bus de datos óptico elimina la latencia mecánica.</p>
                <p>Construido en aluminio aeroespacial anodizado para disipación térmica pasiva.</p>
            </div>
        </section>

        <div style="height: 20vh;"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

        // --- THEME MANAGEMENT ---
        const themes = {
            ludovico: { 
                label: "LUDOVICO (DARK)",
                bg: 0x050505,
                chassis: 0x151515,
                plate: 0x000000,
                details: 0x333333,
                // CORRECCIÓN COLOR: Usamos un rojo-naranja profundo (#FF2200). 
                // Al sumarse con la luz, se verá NARANJA PURO, no amarillo.
                led: 0xFF2200, 
                ledIntensity: 1.5, // Intensidad controlada
                fogDensity: 0.03
            },
            ultra: { 
                label: "ULTRAVIOLENCIA",
                bg: 0xFF3300,
                chassis: 0x101010,
                plate: 0x000000,
                details: 0x440000,
                led: 0xFFFFFF, // Blanco
                ledIntensity: 2.0,
                fogDensity: 0.015
            }
        };

        let currentThemeKey = 'ludovico';
        const toggleBtn = document.getElementById('theme-toggle');
        const bodyEl = document.body;

        // --- 3D SETUP ---
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.9; // Ligera reducción de exposición para saturar colores
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(10, 14, 14); 

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;

        // --- MATERIALS (Shared & Dynamic) ---
        const matChassis = new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.2 });
        const matPlate = new THREE.MeshStandardMaterial({ roughness: 0.2, metalness: 0.5 });
        const matDetail = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 });
        const matLed = new THREE.MeshStandardMaterial({ toneMapped: false }); // Config dinámica
        const matGlass = new THREE.MeshPhysicalMaterial({ color: 0x000000, roughness: 0.1, transmission: 0.0, clearcoat: 1.0 });

        function applyTheme3D(key) {
            const t = themes[key];
            bodyEl.setAttribute('data-theme', key);
            toggleBtn.innerText = "CAMBIAR TEMA: " + t.label;
            
            scene.background = new THREE.Color(t.bg);
            scene.fog = new THREE.FogExp2(t.bg, t.fogDensity);

            matChassis.color.setHex(t.chassis);
            matPlate.color.setHex(t.plate);
            matDetail.color.setHex(t.details);
            
            matLed.color.setHex(t.led);
            matLed.emissive.setHex(t.led);
            matLed.emissiveIntensity = t.ledIntensity;
        }

        applyTheme3D(currentThemeKey);

        toggleBtn.addEventListener('click', () => {
            currentThemeKey = (currentThemeKey === 'ludovico') ? 'ultra' : 'ludovico';
            applyTheme3D(currentThemeKey);
        });

        // --- LIGHTING ---
        RectAreaLightUniformsLib.init();
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048; mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        const rimLight = new THREE.SpotLight(0xffffff, 2.0);
        rimLight.position.set(-10, 5, -10); rimLight.lookAt(0,0,0);
        scene.add(rimLight);

        // --- IRIS 3D LOGIC ---
        const moduleGroup = new THREE.Group();
        scene.add(moduleGroup);
        const CONFIG = { moduleSize: 2.0, gap: 0.1 };
        const modules = [];

        class Module {
            constructor(x, z, type) {
                this.homePos = new THREE.Vector3(x * (CONFIG.moduleSize + CONFIG.gap), 0, z * (CONFIG.moduleSize + CONFIG.gap));
                this.group = new THREE.Group();
                this.group.position.copy(this.homePos);
                this.parts = []; 
                
                this.createChassis();
                this.createConnectors();

                if (type === 'fader') this.createFader();
                else if (type === 'knob') this.createKnobs(); 
                else if (type === 'pad') this.createPads();
                else if (type === 'touch') this.createTouch();
                else if (type === 'roller') this.createRoller();

                moduleGroup.add(this.group);
                modules.push(this);
            }

            addToParts(mesh, speed = 1.0) {
                this.group.add(mesh);
                // Guardamos posición local original
                this.parts.push({ mesh: mesh, home: mesh.position.clone(), speed: speed });
            }

            createChassis() {
                const geo = new RoundedBoxGeometry(CONFIG.moduleSize, 0.5, CONFIG.moduleSize, 4, 0.05);
                const mesh = new THREE.Mesh(geo, matChassis);
                mesh.position.y = 0; 
                mesh.castShadow = true; mesh.receiveShadow = true;
                this.group.add(mesh); 

                const panelGeo = new RoundedBoxGeometry(CONFIG.moduleSize - 0.2, 0.05, CONFIG.moduleSize - 0.2, 2, 0.02);
                const panel = new THREE.Mesh(panelGeo, matPlate);
                panel.position.y = 0.26;
                panel.receiveShadow = true;
                this.addToParts(panel, 0.2); 
            }

            createConnectors() {
                const geo = new THREE.CylinderGeometry(0.05, 0.05, 0.55, 8);
                geo.rotateZ(Math.PI / 2);
                const sides = [
                    { x: CONFIG.moduleSize / 2, z: 0, rot: 0 },
                    { x: -CONFIG.moduleSize / 2, z: 0, rot: 0 },
                    { x: 0, z: CONFIG.moduleSize / 2, rot: Math.PI / 2 },
                    { x: 0, z: -CONFIG.moduleSize / 2, rot: Math.PI / 2 }
                ];
                sides.forEach(s => {
                    const m = new THREE.Mesh(geo, matDetail);
                    m.position.set(s.x, 0, s.z); 
                    m.rotation.y = s.rot;
                    this.group.add(m); 
                });
            }

            createFader() {
                const track = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.02, 1.4), matDetail);
                track.position.set(0, 0.29, 0);
                this.addToParts(track, 0.25);

                const cap = new THREE.Mesh(new RoundedBoxGeometry(0.3, 0.4, 0.15, 4, 0.02), matChassis);
                cap.castShadow = true; cap.position.set(0, 0.45, 0);
                
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.05, 0.02), matLed);
                line.position.set(0, 0.21, 0); 
                cap.add(line);
                
                this.addToParts(cap, 0.6);
            }

            createKnobs() {
                const kGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.3, 32);
                const ringGeo = new THREE.TorusGeometry(0.3, 0.02, 4, 32); ringGeo.rotateX(Math.PI / 2);
                
                for (let i = 0; i < 4; i++) {
                    const x = (i % 2 === 0) ? -0.5 : 0.5;
                    const z = (i < 2) ? -0.5 : 0.5;
                    
                    const kMesh = new THREE.Mesh(kGeo, matChassis);
                    kMesh.castShadow = true; kMesh.position.set(x, 0.45, z);
                    
                    const ring = new THREE.Mesh(ringGeo, matLed);
                    ring.position.set(x, 0.30, z); 
                    
                    this.addToParts(ring, 0.3);
                    this.addToParts(kMesh, 0.5 + Math.random() * 0.2);
                }
            }

            createPads() {
                const padGeo = new RoundedBoxGeometry(0.3, 0.1, 0.3, 2, 0.02);
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 4; c++) {
                        const pad = new THREE.Mesh(padGeo, matDetail);
                        pad.position.set(-0.6 + c * 0.4, 0.32, -0.6 + r * 0.4);
                        pad.castShadow = true;
                        
                        const dot = new THREE.Mesh(new THREE.CircleGeometry(0.05, 16), matLed);
                        dot.rotation.x = -Math.PI/2;
                        dot.position.y = 0.06; 
                        pad.add(dot);

                        this.addToParts(pad, 0.4 + (r + c) * 0.05);
                    }
                }
            }

            createTouch() {
                const surfaceGeo = new THREE.PlaneGeometry(1.6, 1.6); surfaceGeo.rotateX(-Math.PI / 2);
                const surface = new THREE.Mesh(surfaceGeo, matGlass);
                surface.position.set(0, 0.28, 0); 
                this.addToParts(surface, 0.22);

                const cursor = new THREE.Mesh(new THREE.RingGeometry(0.1, 0.12, 32), matLed);
                cursor.rotation.x = -Math.PI / 2; cursor.position.set(0.2, 0.29, -0.3);
                this.addToParts(cursor, 0.23);
            }

            createRoller() {
                const rGroup = new THREE.Group();
                const geo = new THREE.CylinderGeometry(0.8, 0.8, 0.6, 64, 1, false, 0, Math.PI);
                const roller = new THREE.Mesh(geo, matChassis);
                
                roller.rotateZ(Math.PI / 2); 
                roller.rotateX(-Math.PI / 2); 
                roller.castShadow = true;
                
                const sGeo = new THREE.CylinderGeometry(0.81, 0.81, 0.05, 64, 1, false, 0, Math.PI);
                const stripe = new THREE.Mesh(sGeo, matLed);
                stripe.rotation.copy(roller.rotation);
                
                rGroup.add(roller);
                rGroup.add(stripe);
                rGroup.position.set(0, 0.5, 0); 

                const cradle = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.3, 0.8), matDetail);
                cradle.position.set(0, 0.3, 0);
                this.addToParts(cradle, 0.3);
                
                this.addToParts(rGroup, 0.8);
            }

            update(explodeVal) {
                this.parts.forEach(p => {
                    // 1. Desplazamiento VERTICAL (Y) aumentado
                    p.mesh.position.y = p.home.y + (explodeVal * p.speed * 4.0);

                    // 2. CORRECCIÓN: Desplazamiento HORIZONTAL (X y Z)
                    // Las piezas se alejan del centro (0,0) de su módulo local.
                    // Multiplicamos su posición X/Z original por el valor de explosión.
                    p.mesh.position.x = p.home.x + (p.home.x * explodeVal * 1.5);
                    p.mesh.position.z = p.home.z + (p.home.z * explodeVal * 1.5);
                });
            }
        }

        // --- GRID GENERATION ---
        const layout = [
            ['knob', 'fader', 'knob'],
            ['pad', 'touch', 'pad'],
            ['roller', 'fader', 'roller']
        ];
        
        for(let r=0; r<3; r++){
            for(let c=0; c<3; c++){
                new Module(c-1, r-1, layout[r][c]);
            }
        }

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        // Ajustamos el umbral (0.5) para que solo brillen los LEDs y no todo el metal
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.5);
        composer.addPass(bloomPass);

        // --- INTERACTION ---
        const sidebar = document.getElementById('content-sidebar');
        const contentBoxes = document.querySelectorAll('.content-box');
        let scrollPct = 0;

        sidebar.addEventListener('scroll', () => {
            const max = sidebar.scrollHeight - sidebar.clientHeight;
            scrollPct = Math.max(0, Math.min(1, sidebar.scrollTop / max));
            contentBoxes.forEach(box => {
                const rect = box.getBoundingClientRect();
                if(rect.top < window.innerHeight * 0.7) box.classList.add('visible');
            });
        });

        let explodeTarget = 0;
        let explodeCurrent = 0;

        window.addEventListener('wheel', (e) => {
            if(e.ctrlKey || e.metaKey) {
                e.preventDefault();
                controls.enableRotate = false;
                explodeTarget += e.deltaY * 0.005;
                explodeTarget = Math.max(0, Math.min(5, explodeTarget));
            } else {
                controls.enableRotate = true;
            }
        }, {passive:false});

        window.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') controls.enableRotate = true;
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const targetRotY = scrollPct * 0.5;
            const targetRotX = scrollPct * 0.2;
            moduleGroup.rotation.y += (targetRotY - moduleGroup.rotation.y) * 0.05;
            moduleGroup.rotation.x += (targetRotX - moduleGroup.rotation.x) * 0.05;

            explodeCurrent += (explodeTarget - explodeCurrent) * 0.1;

            modules.forEach(m => m.update(explodeCurrent));

            composer.render();
        }

        window.addEventListener('resize', () => {
            const w = container.clientWidth; const h = container.clientHeight;
            camera.aspect = w/h; camera.updateProjectionMatrix();
            renderer.setSize(w,h); composer.setSize(w,h);
        });

        animate();
        sidebar.dispatchEvent(new Event('scroll'));

    </script>
</body>
</html>
