<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ALEX CONTROL | KOROVA HARDWARE</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&family=Montserrat:wght@400;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-paper: #E8E4D9;     /* Crema Moloko */
            --ink-black: #101010;    /* Negro Bombín */
            --ultra-orange: #FF3300; /* Naranja Mecánica */
            --chrome: #aaaaaa;
        }

        body {
            margin: 0;
            background: var(--bg-paper);
            color: var(--ink-black);
            font-family: 'Montserrat', sans-serif;
            overflow: hidden;
        }

        /* --- LAYOUT SPLIT --- */
        #canvas-container {
            position: fixed;
            top: 0;
            right: 0;
            width: 60%;
            height: 100vh;
            z-index: 10;
            background: var(--bg-paper); /* Fondo sólido limpio */
        }

        /* Degradado lateral para que el texto se lea sobre el 3D si se cruzan */
        #canvas-container::after {
            content: ''; position: absolute; top:0; left:0; width: 20%; height: 100%;
            background: linear-gradient(90deg, var(--bg-paper), transparent);
            pointer-events: none;
        }

        #content-sidebar {
            position: relative;
            width: 40%;
            height: 100vh;
            overflow-y: auto;
            z-index: 20;
            background: transparent;
            scrollbar-width: none;
        }
        #content-sidebar::-webkit-scrollbar { display: none; }

        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 10% 0 15%; /* Más padding izquierdo */
            box-sizing: border-box;
        }

        /* --- TYPOGRAPHY & UI --- */
        .content-box {
            padding: 40px 0;
            border-left: 6px solid var(--ultra-orange); /* Línea gruesa Naranja */
            padding-left: 30px;
            opacity: 0;
            transform: translateY(30px);
            transition: 0.8s cubic-bezier(0.16, 1, 0.3, 1); /* Easing "Snappy" */
        }

        .content-box.visible {
            opacity: 1;
            transform: translateY(0);
        }

        h1 {
            font-family: 'Montserrat';
            font-weight: 900;
            font-size: 90px;
            margin: 0;
            line-height: 0.8;
            letter-spacing: -4px;
            text-transform: uppercase;
            color: var(--ink-black);
        }

        h2 {
            font-family: 'Rajdhani';
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 4px;
            margin: 0 0 25px 0;
            color: var(--ultra-orange);
            text-transform: uppercase;
        }

        h3 {
            font-family: 'Montserrat';
            font-weight: 800;
            font-size: 40px;
            margin: 0 0 10px 0;
            color: var(--ink-black);
            line-height: 1;
        }

        p {
            font-family: 'Rajdhani';
            font-weight: 600;
            font-size: 18px;
            line-height: 1.5;
            color: #555;
            margin-bottom: 20px;
            max-width: 400px;
        }

        .accent { color: var(--ultra-orange); font-weight: 700; }

        /* Interfaz de Ayuda Estilo Técnico */
        .interaction-hint {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 30;
            text-align: right;
            font-family: 'Rajdhani';
            font-weight: 700;
            font-size: 11px;
            color: var(--ink-black);
            letter-spacing: 1px;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border: 2px solid var(--ink-black);
            line-height: 1.8;
        }

        .key {
            background: var(--ink-black);
            color: var(--bg-paper);
            padding: 1px 5px;
            border-radius: 2px;
        }

        /* Botones Sólidos */
        .btn-cta {
            padding: 18px 40px;
            background: var(--ink-black);
            color: #fff;
            border: none;
            font-family: 'Montserrat';
            font-weight: 800;
            font-size: 14px;
            cursor: pointer;
            transition: 0.2s;
            text-decoration: none;
            display: inline-block;
            letter-spacing: 1px;
            margin-right: 10px;
            margin-bottom: 10px;
            text-align: center;
            text-transform: uppercase;
        }

        .btn-cta:hover {
            background: var(--ultra-orange);
            color: var(--ink-black);
            transform: translateY(-2px);
            box-shadow: 5px 5px 0px rgba(0,0,0,0.1);
        }

        .btn-cta.secondary {
            background: transparent;
            border: 3px solid var(--ink-black);
            color: var(--ink-black);
        }

        .btn-cta.secondary:hover {
            background: var(--ink-black);
            color: #fff;
            border-color: var(--ink-black);
        }

        .eco-list {
            list-style: none; padding: 0; margin-bottom: 20px;
            display: flex; flex-wrap: wrap; gap: 10px;
        }
        .eco-badge {
            background: #dcd8cc; color: #666; 
            padding: 5px 10px; font-size: 10px; font-weight: 700; font-family: 'Rajdhani';
            border: 1px solid #bbb;
        }

        /* --- MOBILE RESPONSIVE --- */
        @media (max-width: 768px) {
            #canvas-container { width: 100%; height: 50vh; top: 0; left: 0; }
            #content-sidebar { width: 100%; height: 50vh; top: 50vh; background: var(--bg-paper); border-top: 4px solid var(--ultra-orange); }
            section { min-height: 50vh; padding: 40px 30px; border-bottom: 1px solid #ccc; justify-content: flex-start;}
            h1 { font-size: 60px; }
            h3 { font-size: 28px; }
            #canvas-container::after { display: none; }
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.skypack.dev/three@0.136.0",
                "three/addons/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="interaction-hint">
        SCROLL &darr; : ROTAR<br>
        <span class="key">CTRL</span> + SCROLL : EXPLOSIÓN<br>
        DRAG : ORBITAR
    </div>

    <div id="content-sidebar">
        <section id="sec-intro">
            <div class="content-box visible" style="border:none; padding-left:0;">
                <h2>KOROVA HARDWARE V.1.0</h2>
                <h1 style="color:var(--ultra-orange)">ALEX</h1>
                <h1>CONTROL</h1>
                <br>
                <p>La batuta física para la ultra-violencia digital. <br>Controla todo el ecosistema con precisión quirúrgica.</p>
                
                <div style="margin-top: 40px; font-size: 10px; font-weight:800; letter-spacing: 2px; color: var(--ink-black);">
                    ▼ DESPLAZA PARA INICIAR
                </div>
            </div>
        </section>

        <section id="sec-ecosystem">
            <div class="content-box">
                <h2>CENTRO DE COMANDO</h2>
                <h3>ECOSISTEMA UNIFICADO</h3>
                <p>Un solo controlador para dominarlos a todos. Mapeo instantáneo al cambiar de software.</p>
                <ul class="eco-list">
                    <li class="eco-badge">ALEX VISION 1.6</li>
                    <li class="eco-badge">CINE LIBRE</li>
                    <li class="eco-badge">KOROVA SYNTH</li>
                    <li class="eco-badge">VOICE ASSIST</li>
                </ul>
                <p>Detecta automáticamente qué módulo de Alex estás usando y reconfigura los LEDs y la sensibilidad.</p>
            </div>
        </section>

        <section id="sec-materials">
            <div class="content-box">
                <h2>DISEÑO MOLOKO</h2>
                <h3>CERÁMICA & FUEGO</h3>
                <p>Chasis de compuesto cerámico blanco de alto impacto. Placa frontal de aluminio anodizado negro mate.</p>
                <p>Retroiluminación <span class="accent">Naranja Puro</span> para feedback visual en tiempo real sin distracciones neón.</p>
            </div>
        </section>

        <section id="sec-tech">
            <div class="content-box">
                <h2>ARQUITECTURA</h2>
                <h3>ANATOMÍA DEL CONTROL</h3>
                <p>Despiece del sistema. Sensores magnéticos Hall Effect en todos los faders y knobs para una vida útil infinita.</p>
                <p>Mantén presionada la tecla <span class="key">CTRL</span> y usa el scroll para ver el interior.</p>
            </div>
        </section>

        <section id="sec-cta">
            <div class="content-box" style="border:none;">
                <h2>ESTADO: PROTOTIPO</h2>
                <h3>ÚNETE A LA SINFONÍA</h3>
                <p>El hardware está listo. El software está vivo. ¿Estás listo para el control total?</p>
                <br>
                <a href="#" class="btn-cta">RESERVAR AHORA</a>
                <a href="#" class="btn-cta secondary">VER SPECS</a>
                <div style="margin-top: 40px; font-size: 10px; color: #888; font-family:'Rajdhani'; font-weight:700;">
                    DISEÑADO POR ALTERLAB GENERATIVE SYSTEMS<br>
                    HECHO EN MÉXICO
                </div>
            </div>
        </section>
        
        <div style="height: 10vh;"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- SCROLL & UI LOGIC ---
        const sidebar = document.getElementById('content-sidebar');
        const sections = document.querySelectorAll('section');
        let scrollY = 0;
        let pScroll = 0;

        function updateScroll() {
            scrollY = sidebar.scrollTop;
            const max = sidebar.scrollHeight - sidebar.clientHeight;
            pScroll = Math.max(0, Math.min(1, scrollY / max));

            sections.forEach(sec => {
                const rect = sec.getBoundingClientRect();
                if (rect.top < window.innerHeight * 0.6) {
                    const box = sec.querySelector('.content-box');
                    if (box) box.classList.add('visible');
                }
            });
        }
        sidebar.addEventListener('scroll', updateScroll);
        updateScroll();

        // --- 3D CONFIGURATION (ALEX PALETTE) ---
        const CONFIG = {
            moduleSize: 2.0,
            gap: 0.15, // Un poco más de separación para elegancia
            colors: {
                chassis: 0xffffff, // Blanco Cerámica (Fondo papel)
                plate: 0x101010,   // Negro Tinta
                accent: 0xFF3300,  // Naranja Mecánica
                metal: 0x888888,   // Cromo botones
                text: 0xaaaaaa     // Texto serigrafiado
            }
        };

        const container = document.getElementById('canvas-container');

        // Renderer Setup
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        // Fog Crema para fundirse con el HTML
        scene.fog = new THREE.FogExp2(0xE8E4D9, 0.02); 

        const camera = new THREE.PerspectiveCamera(30, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(12, 16, 12); // Ángulo isométrico clásico

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 40;
        controls.enableZoom = false; // Zoom controlado manualmente por lógica

        // --- POST PROCESSING (BLOOM SUTIL) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        // Bloom muy selectivo: Solo el naranja brillará, lo blanco no.
        // Threshold alto (0.9), Radio bajo, Intensidad media.
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.0, 0.3, 0.92);
        composer.addPass(bloomPass);

        // --- LIGHTING (ESTUDIO FOTOGRÁFICO) ---
        RectAreaLightUniformsLib.init();
        
        // Luz ambiente suave
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        // Luz Principal (Key Light) - Proyecta sombras definidas
        const spot1 = new THREE.DirectionalLight(0xffffff, 1.5);
        spot1.position.set(10, 20, 5);
        spot1.castShadow = true;
        spot1.shadow.mapSize.width = 2048;
        spot1.shadow.mapSize.height = 2048;
        spot1.shadow.bias = -0.0001;
        scene.add(spot1);

        // Luz de Relleno (Fill Light) - Naranja muy sutil
        const spot2 = new THREE.SpotLight(0xffaa88, 1.0);
        spot2.position.set(-10, 10, -5);
        scene.add(spot2);

        // Luz de Acento (Rim Light) - Para resaltar bordes negros
        const rectLight = new THREE.RectAreaLight(0xffffff, 2, 20, 20);
        rectLight.position.set(0, 10, -10);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        // --- MATERIALS ---
        const materials = {
            // Cerámica Blanca
            chassis: new THREE.MeshPhysicalMaterial({ 
                color: CONFIG.colors.chassis, 
                roughness: 0.2, 
                metalness: 0.1, 
                clearcoat: 0.5 
            }),
            // Metal Negro Mate (Placa superior)
            plate: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.plate, 
                roughness: 0.4, 
                metalness: 0.6 
            }),
            // Cromo Oscuro (Conectores)
            connector: new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                roughness: 0.2, 
                metalness: 1.0 
            }),
            // LED Apagado vs Encendido
            led: new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.accent, 
                emissive: CONFIG.colors.accent, 
                emissiveIntensity: 2.0 
            }),
            plasticKnob: new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.5,
                metalness: 0.0
            })
        };

        // --- MODULAR SYSTEM LOGIC ---
        const moduleGroup = new THREE.Group(); 
        scene.add(moduleGroup);
        const modules = [];

        class Module {
            constructor(x, z, type) {
                this.homePos = new THREE.Vector3(x * (CONFIG.moduleSize + CONFIG.gap), 0, z * (CONFIG.moduleSize + CONFIG.gap));
                this.group = new THREE.Group();
                this.group.position.copy(this.homePos);
                this.parts = []; // { mesh, homeLocalPos, speed }
                
                this.createBase();
                
                if (type === 'fader') this.createFader();
                else if (type === 'knob') this.createKnobs();
                else if (type === 'pad') this.createPads();
                else if (type === 'screen') this.createScreen(); // Nuevo tipo: Pantalla
                
                moduleGroup.add(this.group);
                modules.push(this);
            }

            createBase() {
                // Base Blanca (Cuerpo)
                const geo = new RoundedBoxGeometry(CONFIG.moduleSize, 0.6, CONFIG.moduleSize, 4, 0.05);
                const mesh = new THREE.Mesh(geo, materials.chassis);
                mesh.position.y = 0.3;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                this.group.add(mesh);

                // Placa Negra (Top)
                const panelGeo = new RoundedBoxGeometry(CONFIG.moduleSize - 0.1, 0.05, CONFIG.moduleSize - 0.1, 2, 0.02);
                const panel = new THREE.Mesh(panelGeo, materials.plate);
                panel.position.y = 0.61;
                panel.receiveShadow = true;
                this.group.add(panel);
                
                // Tornillos decorativos (Naranja)
                const screwGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.05);
                const screwPos = [
                    {x: 0.8, z: 0.8}, {x: -0.8, z: 0.8}, {x: 0.8, z: -0.8}, {x: -0.8, z: -0.8}
                ];
                screwPos.forEach(p => {
                    const s = new THREE.Mesh(screwGeo, new THREE.MeshStandardMaterial({color: 0x333}));
                    s.position.set(p.x, 0.64, p.z);
                    this.group.add(s);
                });
            }

            addToParts(mesh, speed = 1.0) {
                this.group.add(mesh);
                this.parts.push({ mesh: mesh, home: mesh.position.clone(), speed: speed });
            }

            createFader() {
                // Slot
                const track = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 1.4), new THREE.MeshStandardMaterial({ color: 0x050505 }));
                track.position.set(0, 0.64, 0);
                this.group.add(track);
                
                // Cap
                const cap = new THREE.Mesh(new RoundedBoxGeometry(0.3, 0.5, 0.15, 4, 0.05), materials.plasticKnob);
                cap.castShadow = true; 
                cap.position.set(0, 0.8, 0);
                
                // Línea naranja en el fader
                const line = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.05, 0.02), materials.led);
                line.position.set(0, 0.26, 0); 
                cap.add(line);
                
                this.addToParts(cap, 2.5);
            }

            createKnobs() {
                const kGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.4, 32);
                for (let i = 0; i < 1; i++) { // Un knob gigante central estilo "Master"
                    const kMesh = new THREE.Mesh(kGeo, materials.plasticKnob);
                    kMesh.castShadow = true; 
                    kMesh.position.set(0, 0.8, 0);
                    
                    // Indicador led
                    const ind = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.2), materials.led);
                    ind.position.set(0, 0.21, 0.2);
                    kMesh.add(ind);

                    this.addToParts(kMesh, 2.0);
                }
            }

            createPads() {
                const padGeo = new RoundedBoxGeometry(0.35, 0.1, 0.35, 2, 0.05);
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        // Algunos pads prendidos, otros apagados
                        const active = (r+c) % 2 === 0; 
                        const mat = active ? materials.led : new THREE.MeshStandardMaterial({color:0x333, roughness:0.8});
                        
                        const pad = new THREE.Mesh(padGeo, mat);
                        pad.position.set(-0.45 + c * 0.9, 0.68, -0.45 + r * 0.9);
                        pad.castShadow = true;
                        this.addToParts(pad, 1.5 + (r + c) * 0.2);
                    }
                }
            }
            
            createScreen() {
                // Un módulo especial con "pantalla" (Cine Libre / Alex Vision)
                const screenGeo = new THREE.PlaneGeometry(1.4, 1.4);
                screenGeo.rotateX(-Math.PI/2);
                const screenMat = new THREE.MeshBasicMaterial({ color: 0x000 });
                const screen = new THREE.Mesh(screenGeo, screenMat);
                screen.position.set(0, 0.64, 0);
                this.group.add(screen);
                
                // Texto en pantalla (simulado con geometría simple o textura)
                const bar = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.02, 0.05), materials.led);
                bar.position.set(0, 0.65, 0);
                
                // Onda de audio simple
                const wave1 = bar.clone(); wave1.scale.set(0.5,1,1); wave1.position.z = 0.2;
                const wave2 = bar.clone(); wave2.scale.set(0.7,1,1); wave2.position.z = -0.2;
                
                this.addToParts(bar, 1.2);
                this.addToParts(wave1, 1.4);
                this.addToParts(wave2, 1.6);
            }

            update(explodeVal) {
                // Mover el módulo completo (Expandir Grid)
                const centerDist = this.homePos.clone().normalize();
                // Expansión radial del chasis
                this.group.position.x = this.homePos.x + (centerDist.x * explodeVal * 1.5);
                this.group.position.z = this.homePos.z + (centerDist.z * explodeVal * 1.5);
                
                // Explosión vertical de componentes (Despiece)
                this.parts.forEach(p => {
                    p.mesh.position.y = p.home.y + (explodeVal * p.speed);
                    // Rotación sutil al explotar para dinamismo
                    p.mesh.rotation.y = explodeVal * p.speed * 0.5;
                });
            }
        }

        // --- GRID GENERATION ---
        // Layout asimétrico para parecer un controlador real pro
        const layout = [
            ['knob', 'screen', 'knob'],
            ['fader', 'screen', 'fader'],
            ['pad', 'knob', 'pad']
        ];

        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                new Module(c - 1, r - 1, layout[r][c]);
            }
        }

        // Suelo para sombras
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.05, color: 0x000000 }));
        floor.rotation.x = -Math.PI / 2; 
        floor.position.y = 0;
        scene.add(floor);

        // --- INTERACTION LOGIC (CTRL to Explode) ---
        let explodeTarget = 0.0;
        let explodeCurrent = 0.0;

        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                controls.enableRotate = false; // Bloquear rotación al explotar
                explodeTarget += e.deltaY * 0.003;
                explodeTarget = Math.max(0, Math.min(3.0, explodeTarget));
            } else {
                controls.enableRotate = true;
            }
        }, { passive: false });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'Control' || e.key === 'Meta') controls.enableRotate = true;
        });

        // Mobile Gestures
        let lastScale = 1;
        document.addEventListener('gesturestart', (e) => { e.preventDefault(); lastScale = 1; controls.enabled = false; });
        document.addEventListener('gesturechange', (e) => {
            e.preventDefault();
            const delta = e.scale - lastScale;
            lastScale = e.scale;
            explodeTarget += delta * 2.0;
            explodeTarget = Math.max(0, Math.min(3.0, explodeTarget));
        });
        document.addEventListener('gestureend', (e) => { e.preventDefault(); controls.enabled = true; });

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 1. Rotación automática sutil basada en scroll HTML
            const targetRotY = pScroll * 0.8; 
            const targetRotX = pScroll * 0.4;
            
            // Suavizado de rotación
            moduleGroup.rotation.y += (targetRotY - moduleGroup.rotation.y) * 0.05;
            moduleGroup.rotation.x += (targetRotX - moduleGroup.rotation.x) * 0.05;

            // 2. Lógica de Explosión
            explodeCurrent += (explodeTarget - explodeCurrent) * 0.1;
            modules.forEach(m => m.update(explodeCurrent));

            // 3. Render
            composer.render();
        }

        // --- RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            const w = container.clientWidth;
            const h = container.clientHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            composer.setSize(w, h);
        });

        animate();
    </script>
</body>
</html>
