<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bajo Hackeado - Modelo 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: sans-serif; }
        
        /* UI Overlay */
        #ui-container {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 80%; max-width: 400px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 12px;
            color: #ffae00; text-align: center; border: 1px solid #444;
        }

        /* Pantalla de inicio para activar audio */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
            color: white; cursor: pointer;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.5rem; text-transform: uppercase; }
        p { color: #aaa; font-size: 0.9rem; }
        
        input[type=range] { width: 100%; margin-top: 10px; cursor: pointer; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>Bajo Hackeado V2</h1>
        <p>Toca la pantalla para iniciar</p>
        <p style="font-size: 0.7rem; margin-top: 20px;">(Pasa el mouse/dedo por las cuerdas para sonar)</p>
    </div>

    <div id="ui-container">
        <label>Nivel de Despiece (Hack Mode)</label>
        <input type="range" id="explodeSlider" min="0" max="1" step="0.01" value="0">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. ESCENA BÁSICA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222); // Fondo gris oscuro
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 16); // Posición alejada para ver todo

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. LUCES (Esencial para que se vea) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Luz base fuerte
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        // --- 3. CONSTRUCCIÓN DEL BAJO (Basado en la foto) ---
        const bassGroup = new THREE.Group();
        scene.add(bassGroup);

        // Materiales
        const woodMat = new THREE.MeshStandardMaterial({ color: 0xcc8833, roughness: 0.4 });
        const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
        const silverMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
        const stringMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee });

        // A. CUERPO (Forma de Guitarra Acústica)
        const shape = new THREE.Shape();
        // Dibujo de la silueta "8"
        shape.moveTo(0, -3);
        shape.bezierCurveTo(2.5, -3, 3, -1, 2.2, 0); // Curva abajo derecha
        shape.bezierCurveTo(2, 0.5, 2, 1.5, 2.2, 2); // Cintura derecha
        shape.bezierCurveTo(2.5, 3, 1.5, 4, 0.8, 4); // Hombro derecho
        shape.lineTo(-0.8, 4); 
        shape.bezierCurveTo(-1.5, 4, -2.5, 3, -2.2, 2); // Hombro izq
        shape.bezierCurveTo(-2, 1.5, -2, 0.5, -2.2, 0); // Cintura izq
        shape.bezierCurveTo(-3, -1, -2.5, -3, 0, -3); // Curva abajo izq

        const extrudeSettings = { depth: 0.8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.1, bevelThickness: 0.1 };
        const bodyGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        bodyGeo.center();
        const body = new THREE.Mesh(bodyGeo, woodMat);
        
        // Grupo auxiliar para mover el cuerpo al explotar
        const bodyPart = new THREE.Group();
        bodyPart.add(body);
        bassGroup.add(bodyPart);

        // B. BOCINA CENTRAL (Incrustada)
        const speakerGroup = new THREE.Group();
        
        // Cono negro
        const coneGeo = new THREE.ConeGeometry(1.6, 0.5, 32, 1, true);
        const cone = new THREE.Mesh(coneGeo, blackMat);
        cone.rotation.x = Math.PI / 2;
        cone.position.z = 0.5;
        speakerGroup.add(cone);

        // Domo plateado centro
        const domeGeo = new THREE.SphereGeometry(0.4, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const dome = new THREE.Mesh(domeGeo, silverMat);
        dome.rotation.x = Math.PI / 2;
        dome.position.z = 0.55;
        speakerGroup.add(dome);

        // Aro del parlante
        const rimGeo = new THREE.TorusGeometry(1.6, 0.1, 16, 50);
        const rim = new THREE.Mesh(rimGeo, blackMat);
        rim.position.z = 0.45;
        speakerGroup.add(rim);

        bassGroup.add(speakerGroup); // Añadir al grupo principal

        // C. BRAZOS FLEXIBLES (Goosenecks)
        const armsGroup = new THREE.Group();
        
        function createArm(direction) {
            // Tubo curvo
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(direction * 1.5, 1, 0.4),
                new THREE.Vector3(direction * 2.2, 2.5, 1.0),
                new THREE.Vector3(direction * 1.0, 2.0, 1.5)
            ]);
            const tubeGeo = new THREE.TubeGeometry(path, 20, 0.08, 8, false);
            const tube = new THREE.Mesh(tubeGeo, silverMat);
            
            // Punta (Micrófono)
            const micGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.6);
            const mic = new THREE.Mesh(micGeo, blackMat);
            mic.position.copy(path.getPoint(1));
            mic.lookAt(0,0,5);

            const arm = new THREE.Group();
            arm.add(tube);
            arm.add(mic);
            return arm;
        }

        armsGroup.add(createArm(1)); // Brazo derecho
        armsGroup.add(createArm(-1)); // Brazo izquierdo
        bassGroup.add(armsGroup);

        // D. MÁSTIL
        const neckGroup = new THREE.Group();
        const neckGeo = new THREE.BoxGeometry(0.7, 6, 0.2);
        const neck = new THREE.Mesh(neckGeo, woodMat);
        neck.position.set(0, 4.5, -0.1);
        neckGroup.add(neck);
        
        // Cabeza
        const headGeo = new THREE.BoxGeometry(1.2, 1.5, 0.2);
        const head = new THREE.Mesh(headGeo, woodMat);
        head.position.set(0, 7.5, -0.1);
        neckGroup.add(head);
        
        bassGroup.add(neckGroup);

        // E. CUERDAS (Interactuables)
        const strings = [];
        const freqs = [98, 73, 55, 41]; // G, D, A, E
        
        for(let i=0; i<4; i++) {
            const strGeo = new THREE.CylinderGeometry(0.015, 0.015, 11);
            const str = new THREE.Mesh(strGeo, stringMat);
            const x = -0.25 + (i * 0.17);
            str.position.set(x, 2.5, 0.6); // Flotando sobre el parlante
            str.userData = { note: freqs[i] };
            strings.push(str);
            bassGroup.add(str);
        }

        // --- 4. AUDIO ---
        let audioCtx;
        function initAudio() {
            if(!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                document.getElementById('start-screen').style.display = 'none';
            }
        }
        document.getElementById('start-screen').addEventListener('click', initAudio);

        function playTone(freq) {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'triangle'; // Suena más a cuerda
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 1);
        }

        // --- 5. INTERACCIÓN (RAYCASTER) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let lastObj = null;

        function checkIntersection(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(strings);
            
            if(intersects.length > 0) {
                const obj = intersects[0].object;
                if(obj !== lastObj) {
                    playTone(obj.userData.note);
                    
                    // Animación visual cuerda
                    obj.material = new THREE.MeshBasicMaterial({color: 0xffaa00});
                    setTimeout(() => obj.material = stringMat, 100);
                    
                    // Animación visual bocina
                    speakerGroup.scale.set(1.1, 1.1, 1.1);
                    
                    lastObj = obj;
                }
            } else {
                lastObj = null;
            }
        }

        window.addEventListener('mousemove', (e) => checkIntersection(e.clientX, e.clientY));
        window.addEventListener('touchmove', (e) => checkIntersection(e.touches[0].clientX, e.touches[0].clientY));

        // --- 6. ANIMACIÓN ---
        const slider = document.getElementById('explodeSlider');

        function animate() {
            requestAnimationFrame(animate);
            
            // Lógica de despiece
            const val = parseFloat(slider.value);
            
            // La bocina sale hacia el frente
            speakerGroup.position.z = THREE.MathUtils.lerp(0, 2, val);
            
            // Los brazos se abren
            armsGroup.rotation.y = THREE.MathUtils.lerp(0, Math.PI/2, val);
            
            // El mástil sube
            neckGroup.position.y = THREE.MathUtils.lerp(0, 2, val);

            // Recuperación golpe bocina
            if(speakerGroup.scale.x > 1) speakerGroup.scale.lerp(new THREE.Vector3(1,1,1), 0.1);

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
    <div id="loading">Cargando Modelo 3D...</div>

    <div id="overlay">
        <h1>PROYECTO: BOCINA-BAJO</h1>
        <p>Click en cualquier lugar para iniciar</p>
        <p style="font-size: 0.8rem; margin-top: 10px; opacity: 0.6;">(Pasa el mouse sobre las cuerdas para tocar)</p>
    </div>

    <div id="ui-container">
        <label>Despiece / Hack Mode</label>
        <input type="range" id="explodeRange" min="0" max="1" step="0.01" value="0">
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. CONFIGURACIÓN BÁSICA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        // Niebla suave para profundidad
        scene.fog = new THREE.Fog(0x222222, 10, 50);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 18);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        document.getElementById('loading').style.display = 'none';

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. ILUMINACIÓN ---
        const spotLight = new THREE.SpotLight(0xffffff, 500);
        spotLight.position.set(5, 10, 10);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        const ambientLight = new THREE.AmbientLight(0xffae00, 0.3); // Luz cálida ambiental (madera)
        scene.add(ambientLight);
        
        const rimLight = new THREE.PointLight(0x0088ff, 200); // Contraluz azulado
        rimLight.position.set(-10, 5, -10);
        scene.add(rimLight);

        // --- 3. CONSTRUCCIÓN DEL MODELO (Basado en la foto) ---
        const bassGroup = new THREE.Group();
        scene.add(bassGroup);

        // MATERIALES
        const woodMat = new THREE.MeshStandardMaterial({ 
            color: 0xcd853f, // Peru / Wood color
            roughness: 0.6,
            metalness: 0.1 
        });
        
        const speakerMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 });
        const silverMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 });
        const tubeMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7, roughness: 0.3 });
        const stringMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // A. CUERPO DE GUITARRA (Shape Extrude)
        const guitarShape = new THREE.Shape();
        // Dibujando la silueta "8" de la guitarra
        guitarShape.moveTo(0, -3.5);
        guitarShape.bezierCurveTo(2.5, -3.5, 3, -1.5, 2.2, -0.5); // Lóbulo inferior der
        guitarShape.bezierCurveTo(2, 0, 2, 1, 2.2, 1.5); // Cintura der
        guitarShape.bezierCurveTo(2.5, 2.5, 1.5, 3.5, 0.8, 3.5); // Lóbulo superior der
        guitarShape.lineTo(-0.8, 3.5); // Top
        guitarShape.bezierCurveTo(-1.5, 3.5, -2.5, 2.5, -2.2, 1.5); // Lóbulo superior izq
        guitarShape.bezierCurveTo(-2, 1, -2, 0, -2.2, -0.5); // Cintura izq
        guitarShape.bezierCurveTo(-3, -1.5, -2.5, -3.5, 0, -3.5); // Lóbulo inferior izq

        const extrudeSettings = { depth: 0.8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 0.1, bevelThickness: 0.1 };
        const bodyGeo = new THREE.ExtrudeGeometry(guitarShape, extrudeSettings);
        bodyGeo.center(); // Centrar geometría
        
        const bodyMesh = new THREE.Mesh(bodyGeo, woodMat);
        bodyMesh.castShadow = true;
        
        // Grupo contenedor del cuerpo para explotarlo
        const bodyPart = new THREE.Group();
        bodyPart.add(bodyMesh);
        bassGroup.add(bodyPart);

        // B. BOCINA CENTRAL (Como en la foto)
        const speakerGroup = new THREE.Group();
        
        // Cono
        const coneGeo = new THREE.ConeGeometry(1.6, 0.5, 32, 1, true); // Open ended
        const coneMesh = new THREE.Mesh(coneGeo, speakerMat);
        coneMesh.rotation.x = Math.PI / 2;
        coneMesh.position.z = 0.45; // Sobresaliendo un poco
        speakerGroup.add(coneMesh);

        // Domo central (plateado/dorado en la foto)
        const domeGeo = new THREE.SphereGeometry(0.4, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
        const domeMesh = new THREE.Mesh(domeGeo, silverMat);
        domeMesh.rotation.x = Math.PI / 2;
        domeMesh.position.z = 0.5;
        speakerGroup.add(domeMesh);

        // Aro de goma (Surround)
        const torusGeo = new THREE.TorusGeometry(1.6, 0.15, 16, 50);
        const torusMesh = new THREE.Mesh(torusGeo, new THREE.MeshStandardMaterial({color: 0x222222}));
        torusMesh.position.z = 0.65;
        speakerGroup.add(torusMesh);

        bassGroup.add(speakerGroup); // Añadir al grupo principal

        // C. LOS BRAZOS FLEXIBLES (Goosenecks)
        const armsGroup = new THREE.Group();

        function createGooseneck(xDir) {
            // Ruta curva usando CatmullRom
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(xDir * 1.8, 1, 0.4), // Salida del cuerpo
                new THREE.Vector3(xDir * 2.2, 2, 1.5), // Curva hacia afuera y arriba
                new THREE.Vector3(xDir * 0.5, 1.5, 2.0)  // Apuntando a las cuerdas
            ]);
            
            const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.08, 8, false);
            const tube = new THREE.Mesh(tubeGeo, tubeMat);
            
            // Micrófono en la punta
            const micGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.5);
            const mic = new THREE.Mesh(micGeo, new THREE.MeshStandardMaterial({color: 0x111111}));
            mic.rotation.x = Math.PI / 2;
            mic.position.copy(curve.getPoint(1)); // Posición final
            mic.lookAt(0, 0, 1); // Apuntar vagamente al centro

            const arm = new THREE.Group();
            arm.add(tube);
            arm.add(mic);
            return arm;
        }

        const leftArm = createGooseneck(-1);
        const rightArm = createGooseneck(1);
        armsGroup.add(leftArm);
        armsGroup.add(rightArm);
        bassGroup.add(armsGroup);

        // D. MÁSTIL Y CABEZA
        const neckGroup = new THREE.Group();
        
        const neckGeo = new THREE.BoxGeometry(0.7, 6, 0.3);
        const neckMesh = new THREE.Mesh(neckGeo, woodMat);
        neckMesh.position.set(0, 4.5, -0.2); // Arriba del cuerpo
        neckGroup.add(neckMesh);

        const headGeo = new THREE.BoxGeometry(1.2, 1.8, 0.3);
        const headMesh = new THREE.Mesh(headGeo, woodMat);
        headMesh.position.set(0, 7.8, -0.2);
        neckGroup.add(headMesh);

        bassGroup.add(neckGroup);

        // E. CUERDAS (Interactuables)
        const strings = [];
        const stringNotes = [41, 55, 73, 98]; // Frecuencias
        
        for(let i=0; i<4; i++) {
            const sGeo = new THREE.CylinderGeometry(0.01, 0.01, 10);
            const sMesh = new THREE.Mesh(sGeo, stringMat);
            const xPos = -0.25 + (i * (0.5/3));
            sMesh.position.set(xPos, 2.5, 0.7); // Flotando sobre la bocina
            
            sMesh.userData = { 
                note: stringNotes[i], 
                isString: true 
            };
            strings.push(sMesh);
            bassGroup.add(sMesh);
        }

        // --- 4. LÓGICA DE AUDIO ---
        let audioCtx;
        
        function initAudio() {
            if(!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                document.getElementById('overlay').style.display = 'none';
            }
        }

        document.getElementById('overlay').addEventListener('click', initAudio);

        function playString(freq) {
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            // Sonido más "acústico" (Triángulo + Sine)
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start();
            osc.stop(audioCtx.currentTime + 1.5);
        }

        // --- 5. INTERACCIÓN ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let lastString = null;

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(strings);

            if(intersects.length > 0) {
                const s = intersects[0].object;
                if(s !== lastString) {
                    // Tocar cuerda
                    playString(s.userData.note);
                    
                    // Efecto visual (vibración color)
                    s.material = new THREE.MeshBasicMaterial({color: 0xffaa00});
                    setTimeout(() => { s.material = stringMat; }, 100);
                    
                    // Movimiento de cono (Bass kick visual)
                    speakerGroup.scale.set(1.1, 1.1, 1.1);
                    
                    lastString = s;
                }
            } else {
                lastString = null;
            }
        });

        // --- 6. ANIMACIÓN Y EXPLOSIÓN ---
        const slider = document.getElementById('explodeRange');

        function animate() {
            requestAnimationFrame(animate);
            
            const explodeVal = parseFloat(slider.value);

            // 1. Efecto Bocina (Latido suave)
            if(speakerGroup.scale.x > 1) {
                speakerGroup.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
            }

            // 2. Lógica de "Despiece" (Explode)
            // La bocina sale hacia adelante
            speakerGroup.position.z = THREE.MathUtils.lerp(0, 3, explodeVal);
            
            // Los brazos se abren hacia los lados
            armsGroup.position.z = THREE.MathUtils.lerp(0, 1, explodeVal);
            armsGroup.rotation.y = THREE.MathUtils.lerp(0, Math.PI/4, explodeVal);
            
            // El mástil sube
            neckGroup.position.y = THREE.MathUtils.lerp(0, 2, explodeVal);

            // Rotación general suave
            // bassGroup.rotation.y += 0.001;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
        
        label { display: block; margin-bottom: 10px; font-size: 0.8rem; letter-spacing: 1px; }
        
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ff0055;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px #ff0055;
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #333;
            border-radius: 2px;
        }

        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99;
            flex-direction: column;
            cursor: pointer;
        }
        
        .blink { animation: blinker 1.5s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h1 style="font-size: 3rem; color: #ff0055;">SYSTEM: OFFLINE</h1>
        <p class="blink" style="text-align: center; border: none; font-size: 1.2rem;">[ CLICK ANYWHERE TO INITIALIZE SYSTEM ]</p>
    </div>

    <div id="ui-layer">
        <h1>PROJECT: HACK_BASS_V1</h1>
        <p>
            > STATUS: ONLINE<br>
            > AUDIO ENGINE: SYNTHESIS<br>
            > INSTRUCTION: Hover over strings to trigger sound. Use slider to inspect internal components.
        </p>
    </div>

    <div id="controls">
        <label for="explodeSlider">EXPLODED VIEW DIAGNOSTICS</label>
        <input type="range" id="explodeSlider" min="0" max="1" step="0.01" value="0">
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- 1. CONFIGURACIÓN DE ESCENA ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(5, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // --- 2. ILUMINACIÓN & POST-PROCESADO (GLOW) ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(-5, 10, 5);
        scene.add(dirLight);

        // Bloom Effect para el estilo Cyberpunk
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // Intensidad del brillo
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. MOTOR DE AUDIO (WEB AUDIO API) ---
        let audioCtx;
        const startOverlay = document.getElementById('start-overlay');
        let audioEnabled = false;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioEnabled = true;
                startOverlay.style.display = 'none';
                
                // Efecto de sonido de encendido
                playTone(200, 'square', 0.1, 0.5);
            }
        }

        // Función para tocar nota
        function playTone(freq, type = 'sawtooth', duration = 1, volume = 0.3) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

            // Filtro Lowpass para sonar más como un bajo
            filter.type = "lowpass";
            filter.frequency.setValueAtTime(800, audioCtx.currentTime);

            // Envolvente (Envelope)
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + 0.05); // Attack
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration); // Decay

            osc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        startOverlay.addEventListener('click', initAudio);

        // --- 4. CONSTRUCCIÓN DEL BAJO (MODELO PROCEDIMENTAL) ---
        // Usamos geometrías básicas para que no dependa de archivos externos
        
        const bassGroup = new THREE.Group();
        scene.add(bassGroup);

        // Materiales
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.2, metalness: 0.8 });
        const accentMat = new THREE.MeshStandardMaterial({ color: 0xff0055, emissive: 0xff0055, emissiveIntensity: 0.5 });
        const circuitMat = new THREE.MeshStandardMaterial({ color: 0x111111, wireframe: true });
        const stringMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc });

        // Array para guardar las partes que se van a mover (explotar)
        const explodeParts = [];

        // Función auxiliar para crear partes
        function createPart(geometry, material, pos, explodeDir, name) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pos.x, pos.y, pos.z);
            mesh.userData = { 
                originalPos: pos, 
                explodeDir: explodeDir, // Vector hacia donde se mueve
                name: name 
            };
            bassGroup.add(mesh);
            explodeParts.push(mesh);
            return mesh;
        }

        // A. CUERPO (Body) - Dividido en capas para efecto "hacked"
        const bodyGeoMain = new THREE.BoxGeometry(3, 4, 0.5);
        createPart(bodyGeoMain, bodyMat, {x:0, y:-1, z:0}, {x:0, y:0, z:0}, "body_main");

        const bodyGeoTop = new THREE.BoxGeometry(2.8, 3.8, 0.1);
        createPart(bodyGeoTop, circuitMat, {x:0, y:-1, z:0.26}, {x:0, y:0, z:1.5}, "body_plate");

        // B. CUELLO (Neck)
        const neckGeo = new THREE.BoxGeometry(0.6, 6, 0.3);
        createPart(neckGeo, bodyMat, {x:0, y:3.5, z:0.1}, {x:0, y:2, z:0}, "neck");

        // C. CABEZA (Headstock)
        const headGeo = new THREE.BoxGeometry(1.2, 1.5, 0.3);
        createPart(headGeo, bodyMat, {x:0, y:7, z:0.1}, {x:0, y:3, z:0}, "headstock");

        // D. PASTILLAS (Pickups)
        const pickupGeo = new THREE.BoxGeometry(2, 0.5, 0.2);
        createPart(pickupGeo, accentMat, {x:0, y:-1.5, z:0.3}, {x:0, y:0, z:2}, "pickup_neck");
        createPart(pickupGeo, accentMat, {x:0, y:-2.5, z:0.3}, {x:0, y:0, z:2.5}, "pickup_bridge");

        // E. CUERDAS (Strings) - Interactuables
        const strings = [];
        const stringNotes = [41.20, 55.00, 73.42, 97.99]; // E, A, D, G (Frecuencias base)
        
        for(let i=0; i<4; i++) {
            // Usamos cilindros muy finos
            const stringGeo = new THREE.CylinderGeometry(0.015, 0.015, 9, 8); 
            const xPos = -0.3 + (i * 0.2); // Espaciado
            const stringMesh = new THREE.Mesh(stringGeo, stringMat);
            
            stringMesh.position.set(xPos, 2.5, 0.4);
            stringMesh.userData = {
                originalPos: {x:xPos, y:2.5, z:0.4},
                explodeDir: {x: xPos * 2, y: 0.5, z: 4}, // Explotan hacia afuera
                isString: true,
                note: stringNotes[i],
                id: i
            };
            
            bassGroup.add(stringMesh);
            explodeParts.push(stringMesh);
            strings.push(stringMesh);
        }

        // --- 5. LÓGICA DE INTERACCIÓN (RAYCASTER) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Variable para controlar que no se dispare el sonido 60 veces por segundo
        let hoveredString = null; 

        window.addEventListener('mousemove', (event) => {
            // Normalizar coordenadas del mouse (-1 a +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Detectar intersección SOLO con cuerdas
            const intersects = raycaster.intersectObjects(strings);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                
                // Si tocamos una cuerda nueva
                if (hoveredString !== object) {
                    hoveredString = object;
                    
                    // Efecto visual
                    object.material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    object.scale.set(3, 1, 3); // Engrosar cuerda momentáneamente

                    // Sonido
                    if (audioEnabled) {
                        playTone(object.userData.note, 'sawtooth', 1.5, 0.2);
                        playTone(object.userData.note * 2, 'sine', 0.5, 0.1); // Armónico
                    }
                }
            } else {
                // Resetear estado si salimos de la cuerda
                if (hoveredString) {
                    hoveredString.scale.set(1, 1, 1);
                    hoveredString.material = stringMat; // Volver al color original
                    hoveredString = null;
                }
            }
        });

        // --- 6. ANIMACIÓN Y "EXPLOSIÓN" ---
        const slider = document.getElementById('explodeSlider');
        
        function animate() {
            requestAnimationFrame(animate);

            // 1. Lógica de Explosión
            const explodeVal = parseFloat(slider.value);
            
            explodeParts.forEach(part => {
                const targetX = part.userData.originalPos.x + (part.userData.explodeDir.x * explodeVal);
                const targetY = part.userData.originalPos.y + (part.userData.explodeDir.y * explodeVal);
                const targetZ = part.userData.originalPos.z + (part.userData.explodeDir.z * explodeVal);

                // Lerp (interpolación lineal) para suavizar movimiento
                part.position.x += (targetX - part.position.x) * 0.1;
                part.position.y += (targetY - part.position.y) * 0.1;
                part.position.z += (targetZ - part.position.z) * 0.1;
            });

            // 2. Vibración de cuerdas activa
            if(hoveredString) {
                hoveredString.position.x += (Math.random() - 0.5) * 0.05;
            }

            // 3. Rotación sutil del modelo completo
            bassGroup.rotation.y += 0.002;

            controls.update();
            // Usamos composer en lugar de renderer normal para el efecto Glow
            composer.render();
        }

        // Manejo de resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
